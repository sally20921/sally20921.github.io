<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Mundana Free Jekyll Theme | Seri Lee Blog</title>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Page 2 of 2 for Mundana Free Jekyll Theme | Seri Lee Blog</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="Mundana Free Jekyll Theme">
<meta property="og:locale" content="en_US">
<meta name="description" content="A great Jekyll theme developed by Sal @wowthemesnet.">
<meta property="og:description" content="A great Jekyll theme developed by Sal @wowthemesnet.">
<link rel="canonical" href="https://sally20921.github.io/page2/">
<meta property="og:url" content="https://sally20921.github.io/page2/">
<meta property="og:site_name" content="Seri Lee Blog">
<link rel="prev" href="https://sally20921.github.io/">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Mundana Free Jekyll Theme">
<script type="application/ld+json">
{"url":"https://sally20921.github.io/page2/","headline":"Mundana Free Jekyll Theme","description":"A great Jekyll theme developed by Sal @wowthemesnet.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://sally20921.github.io/assets/images/logo.png"}},"@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	
    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

    <!-- Google Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!-- Theme Stylesheet -->
    <link rel="stylesheet" href="/assets/css/theme.css">

    <link rel="stylesheet" href="/assets/css/custom.css">
    <link rel="stylesheet" href="/assets/css/colorful.css">
<!-- IMPORTANT -->
    
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">-->
    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>

    <!-- This goes before </head> closing tag, Google Analytics can be placed here --> 
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="/assets/js/lib.js" defer></script>
    <script> 
	    MathJax = {
		    loader: {load: ['input/tex', 'ui/menu']},
		    tex: {
			    inlineMath: {'[+]': [['$','$']]},
			    displayMath: {'[+]':[['$$', '$$']]}
			}
	    }
   </script>
    <script type="text/javascript" id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
 <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js"></script>
  <script>
    function convert() {
      //
      //  Get the MathML input string, and clear any previous output
      //
      var input = document.getElementById("input").value.trim();
      output = document.getElementById('output');
      output.innerHTML = '';
      //
      //  Convert the MathMl to an HTML node and append it to the output
      //
      output.appendChild(MathJax.mathml2chtml(input));
      //
      //  Then update the document to include the adjusted CSS for the
      //    content of the new equation.
      //
      MathJax.startup.document.clear();
      MathJax.startup.document.updateDocument();
    }
    </script>

    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
    <script>mermaid.initialize({startOnLoad:true});</script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body class="">

    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <a class="navbar-brand" href="/index.html"><strong>Seri Lee Blog</strong></a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02" style="">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               <!--  Replace menu links here -->

<li class="nav-item">
<a class="nav-link" href="/index.html">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" href="/authors-list.html">Author</a>
</li>
<li class="nav-item">
<a class="nav-link" href="/contact.html">Contact</a>
</li>




            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <script src="/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});
    

var documents = [{
    "id": 0,
    "url": "https://sally20921.github.io/_posts/2021-08-31-homogeneous.html",
    "title": "Homogeneous Coordinates and Projective Geometry",
    "body": "Introduction to Projective Geometry: Most of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and $Z$). However, there are certain situations where it is useful to think in terms of projective geometry instead. Projective geometry has an extra dimension, called $W$, in addition to the $X$, $Y$, and $Z$ dimensions. This four-dimensional space is called projective space and coordinates in projective space are called homogenous coordinates. For the purposes of 3D software, the terms projective and homogeous are basically interchangeable with 4D. Not Quaternions: Quaternions look a lot like homogeneous coordinates. Both are 4D vectors, commonly depicted as $(X,Y,Z,W)$. However, quaternions and homogeneous coordinates are different concepts, with different uses. An Analogy in 2D: First, let‚Äôs look at how projective geometry works in 2D, before we move on to 3D.  Imagine a projector that is projecting a 2D image onto a screen. It‚Äôs easy to identify the $X$ and $Y$ dimensions of the projected image.  Now, if you step back from the 2D image and look at the projector and the screen, you can see the $W$ dimension, too. The $W$ dimension is the distance from the projector to the screen .  So what does the $W$ dimension do, exactly? Imagine what would happen to the 2D image if you increased or decreased $W$-that is, if you increased or decreased the distance between the projector and the screen. If you move the projector closer to the screen, the whole 2D image becomes smaller. If you move the projector away from the screen, the 2D image becomes larger. As you can see, the value of $W$ affects the size (a. k. a scale) of the image . Applying it to 3D: There is no such thing as a 3D projector (yet), so its‚Äô harder to imagine projective geometry in 3D, but the $W$ value works exactly the same as it does in 2D. When $W$ increases, the coordinates expands (scales up). When $W$ decreases, the coordinates shrinks (scales down). The $W$ is basically a scaling transformation for the 3D coordinates . When $W = 1$: The usual advice for 3D programming beginners is to always set $W=1$ whenever converting a 3D coordinate to 4D coordinate. The reason for that is that when you scale a coordinate by a 1 it doesn‚Äôt shrink or grow, it just stays the same size. So, when $W=1$, it has no effect on the $X$, $Y$, or $Z$ values . For this reason, when it comes to 3D computer graphics, coordinates are said to be correct only when $W=1$. If you tried to render with $W=0$ your program would crash when it attempted to divide by zero. With $W&lt;0$ everything would flip unside-down and back-to-front. Mathematically speaking, there is no such thing as an incorrect homogeneous coordinate.  Using coordinates with $W=1$ is just a useful convention for the 3D computer grahics . The Math: Now, let‚Äôs look at some actual numbers, to see how the math works.  Let‚Äôs say that the projector is $3$ meters away from the screen, and there is a dot on the 2D image at the coordinate $(15, 21)$. This gives us the projective coordinate vector $(X,Y,W) = (15,21,3)$.  Now imagine that the projector was pushed closer to the screen so that the distance was $1$ meter. The closer the project gets to the screen, the smaller the image becomes. The projector has moved three times closer, so the image becomes three times smaller. If we take the original coordinate vector and divide all the values by three, we get the new vector where $W=1$:  $$(\frac{15}{3}, \frac{21}{3}, \frac{3}{3}) = (5,7,1)$$. The dot is now at coordinate $(5,7)$. This is how an incorrect homogeneous coordinate is converted to a correct coordinate: divide all the values by $W$. The process is exactly the same for 2D and 3D coordinates. Dividing all the values in a vector is done by a scalar multiplication with the reciprocal of the divisor. Here is a 4D example:  $$\frac{1}{5}(10, 20, 30, 5) = (\frac{10}{5}, \frac{20}{5}, \frac{30}{5}, \frac{5}{5}) = (2,4,6,1)$$ Uses of Homogeneous Coordinates in Computer Graphics: As mentioned earlier, in regard to 3D computer graphics, homogeneous coordinates are useful in certain situations. We will look at some of those situations here. Translation Matrices for 3D Coordinates:  A four-column matrix can only be multiplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors. Rotation and scaling transformation matrices only require three columns. But, in order to do translation, the matrices need to have at least four columns . This is why transformations are often $4 \times 4$ matices. However, a matrix with four columns cannot be multiplied by a 3D vector, due to the rules of matrix multiplication. A four-column matrix can only be mulitplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors. The 4th dimension $W$ is usually unchanged, when using homogeneous coordinates in matrix transformation. $W$ is set to $1$ when converting 3D coordinates into 4D, and is usually still $1$ after the transformation matrices are applied, at which point it can be converted back into a 3D coordinate by ignoring $W$. This is true for all translation, rotation, and scaling transformations, which by far are the most common types of transformations. The notable exception is projection matrices, which do affect the $W$ dimension. Perspective Transformation: In 3D, perspective is the phenomenon where an object appears smaller the further away it is from the camera. A far-away mountain can appear to be smaller than a cat, if the cat is close enough to the camera. Perspective is implemented in 3D computer graphics by using a transformation matrix that changes the $W$ element of each vertex. After the camera matrix is applied to each vertex, but before the projection matrix is applied, the $Z$ element of each vertex represents the distance away from the camera. Therefore, the larger $Z$ is, the more the vertex should be scaled down. The $W$ dimension affects the scale, so the projection matrix just changes the $W$ based on the $Z$ value. Here is an example of a perspective projection matrix being applied to a homogeneous coordinate:  $$ \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0&amp; \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;1&amp;0 \end{bmatrix} \begin{bmatrix} 2 \\ 3 \\ 4 \\ 1\end{bmatrix} = \begin{bmatrix} 2 \\ 3 \\ 4 \\ 1 \end{bmatrix} $$ Notice how the $W$ value is changed to $4$, which comes from the $Z$ value. After the perspective projection matrix is applied, each vertex undergoes perspective division. Perspective division is just a specific term for converting the homogeneous coordinate back to $W=1$, as explained earlier in the article. Continuing with the example above, the perspective division step would look like this:  $$\frac{1}{4}(2,3,4,4) = (0. 5,0. 75, 1,1)$$ After perspective division, the $W$ value is discarded, and we are left with a 3D coordinate that has been correctly scaled according to a 3D perspective projection. Positioning Directional Lights: One property of homogeneous coordinates is that they allow you to have points at infinity (infinite length vectors), which is not possible with 3D coordinates. Points at infinity occur when $W=0$. If you try to convert a $W=0$ homogeneous coordinate into a normal $W=1$ coordinate, it results in a bunch of divide-by-zero operations:  $$ \frac{1}{0}(2,3,4,0) = (\frac{2}{0}, \frac{3}{0}, \frac{4}{0}, \frac{0}{0})$$. This means that homogeneous coordinates with $W=0$ can not be converted back into 3D coordinates. What use does this have? Well, directional lights can be thought of as point lights that are infinitely far away. When a point light is infinitely far away, the rays of light become parallel, and all of the light travels in a single direction. This is basically the definition of a directional light. So, traditionally, in 3D graphics, directional lights are differentiated from point lights by the value of $W$ in the position vector of the light. If $W=1$, then it is a point light. If $W=0$, then it is a directional light. This is more of a traditional convention, rather than a useful way to write lighting code. Directional lights and point lights are usually implemented with separate code, because they behave differently. Summary: Homogeneous coordinates have an extra dimension called $W$, which scales the $X$, $Y$, and $Z$ dimensions. Matrices for translation and perspective projection can only be applied to homogeneous coordinates, which is why they are so common in 3D computer graphics. The $X$, $Y$, and $Z$ values are said to be correct when $W=1$. Any homogeneous coordinates can be converted to have $W=1$ by dividing all four dimensions by the $W$ value, except if $W=0$. When $W=0$, the coordinate represents a point at infinity (a vector with infinite length), and this is often used to denote the direction of directional lights. References:  Tomdalling‚Äôs Blog Post Image Processing and Computer Vision Lecture Notes"
    }, {
    "id": 1,
    "url": "https://sally20921.github.io/_posts/2021-08-31-rigid.html",
    "title": "3D Rigid Body Motion (Part 1)",
    "body": "Introduction: In this article, I will introduce one of the fundamental problems of visual SLAM: How to describe a rigid body‚Äôs motion in 3-dimensional space ? Intuitively, we certainly know that this consists of one rotation plus one translation . The translation part does not really have any problems, but the rotation part is questionable. I will introduce the meaning of rotation matrices, quaternions, Euler angles and how they are computed and transformed. Rotation Matrix: Points, Vectors, and Coordinate Systems: The space of our daily life is 3-dimensional, so we are born to be used to 3D movements. The 3D space consists of three axes, so the position of one spatial point can be specified by three coordinates. However, we should now consider a rigid body , which has its position and orientation . The camera can also be viewed as a rigid body in three dimensions, so what we care about in Visual SLAM are the problem of the camera‚Äôs position and orientation. Combined, we can say, ‚Äúthe camera is at the $(0,0,0)$ point, facing the front‚Äù. Let‚Äôs describe this in a mathematical term. We start from the basic content: points and vectors. Points are the basic element in space, no length, no volume. Connecting the two points forms a vector. A vector can be thought of as an arrow pointing from one point to another. Here we need to warn you not to confuse the vector with its coordinates. A vector is one thing in space, such as $a$. Here, $a$ does not need to be associated with several real numbers. We can naturally talk about the plus or minus operation of two vectors, without relating to any real numbers. Only when we specify a coordinate system in this 3D space can we talk about the vector‚Äôs coordinates in this system, finding several real numbers corresponding to this vector. With the knowledge of linear algebra, the coordinates of a point in 3D space can be described as $\mathbb{R}^3$. How to do we describe this? Suppose that in this linear space, we fined a set of base $(e_1, e_2, e_3)$ , then, an arbitrary vector $a$ has a coordinate under this base: $$ a = \begin{bmatrix} e_1 &amp; e_2 &amp; e_3 \end{bmatrix} \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = a_1 e_1 + a_2 e_2 + a_3 e_3 $$. Here, $(a_1, a_2, a_3)^T$ is called $a$‚Äôs coordinates. The coordinates‚Äô specific values are related to the vector itself and the selection of the bases. In $\mathbb{R}^3$, the coordinate system usually consists of $3$ orthogonal coordinate axes (it can also be non-orthogonal, but it is rare in practice). For example, given $x$ and $y$ axis, the $z$ axis can be determined using the right-hand (or left-hand) rule. According to different definitions, the coordinate system is divided into left-handed and right-handed. The third axis of the left-hand rule is opposite to the right-hand rule. Most 3D libraries use right-handed coordinates. Based on basic linear algebra knowledge, we can talk about the operations between vectors/vectors, vectors/numbers, such as scalar multiplication, vector addition, subtraction, inner product, outer product and so on. For $a,b \in \mathbb{R}^3$, the inner product of $a,b$ can be written as: \$\$ a \cdot b = a^Tb = \sum_{i=1}^3 a_i b_i = |a\||b| \cos(&lt;a,b&gt;)\$\$where $ &lt;a. b&gt; $ refers to the angle between the vector $a, b$. The inner product can also describe the projection relationship between vectors. $$ a \times b = \begin{Vmatrix} e_1 &amp; e_2 &amp; e_3 \\ a_1 &amp; a_2 &amp; a_3 \\ b_1 &amp; b_2 &amp; b_3 \end{Vmatrix} = \begin{bmatrix} a_2b_3 - a_3 b_2 \\ a_3 b_1 - a_1 b_3 \\ a_1 b_2 - a_2 b_1 \end{bmatrix} = \begin{bmatrix} 0 &amp; -a_3 &amp; a_2 \\ a_3 &amp; 0 &amp; -a_1 \\ -a_2 &amp; a_1 &amp; 0 \end{bmatrix} b = a \wedge b$$. The result of the outer product is a vector whose direction is perpendicular to the two vectors, and the length is $|a||b|\sin(&lt;a,b&gt;)$, which is also the area of the quadrilateral of the two vectors. From the outer product operation, we introduce the $\wedge$ operator here, which means writing $a$ as a skew-symmetric matrix . You can take $\wedge$ as a skew-symmetric symbol. It turns the outer product $a \times b$ into the multiplication of the matrix and the vector $a \wedge b$ is a linear operation. This symbol will be used frequently in the following sections. It is a one-to-one mapping, meaning that for any vector, it corresponds to a unique anti-symmetric matrix, and vice versa: $$ a \wedge = \begin{bmatrix} 0 &amp; -a_3 &amp; a_2 \\ a_3 &amp; 0 &amp; -a_1 \\ -a_2 &amp; a_1 &amp; 0 \end{bmatrix}$$ At the same time, note that the vector operations such as addition, subtraction, inner and outer products can be calculated even when we do not have their coordinates. For example, although the inner product can be expressed by the sum of the two vectors‚Äô product when we know the coordinates, the length and angle can also be calculated even if their coordinates are unknown. Therefore, the inner product result of the two vectors is independent of the selection of the coordinate system. Euclidean Transforms between Coordinate Systems: We often define a variety of coordinate systems in the real scene. In robotics, you define one coordinate system for each link and joint; in 3D mapping, we also define a coordinate system for each cuboid and cylinder. If we consider a moving robot, it is common practice to set a stationary inertial coordinate system (or world coordinate system), such as the $x_W, y_W, z_W$ defined in the picture above. Meanwhile, the camera or robot is a moving coordinate system, such as coordinate system defined by $x_C, y_C, z_C$. We might ask: a vector $p$ in the camera system may have coordinates $p_c$; and in the world coordinate system, its coordinates maybe $p_w$ .  Then what is the conversion between two coordinates? It is necessary to first obtain the coordinate values of the point in the camera system and then use the transform rule to do the coordinate transform. We need a mathematical way to describe this transformation. As we will see later, we can describe it with a transform matrix $T$. Intuitively, the motion between two coordinate systems consists of a rotation plus a translation , which is called rigid body motion . Obviously, the camera movement is rigid. During the rigid body motion, the length and angle of the vector will not change. Imagine that you throw your phone into the air and there may be differences in spatial position and orientation. But the length and the angle of each face will not change. At this point, we say that the phone‚Äôs motion is Euclidean. The Euclidean transform consists of rotation and translation . Let‚Äôs first consider the rotation. We have a unit-length orthogonal base $(e_1, e_2, e_3)$. After a rotation it becomes $(e_1‚Äô, e_2‚Äô, e_3‚Äô)$. Then, for the same vector $a$ (the vector does not move with the rotation of the coordinate system). its coordinates in these two coordinate systems are $[a_1, a_2, a_3]^T$ and $[a_1‚Äô, a_2‚Äô, a_3]^T$. Because the vector itself has not changed, according to the definition of coordinates, there are: $$ [e_1, e_2, e_3] \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = [e_1‚Äô, e_2‚Äô, e_3‚Äô] \begin{bmatrix} a_1‚Äô \\ a_2‚Äô \\ a_3‚Äô \end{bmatrix}$$ To describe the relationship between the two coordinates, we multiply the left and right side of the above equation by $\begin{bmatrix} e_1^T \\ e_2^T \\ e_3^T \end{bmatrix}$, then the matrix on the left becomes an identity matrix, so: $$\begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} \triangleq Ra‚Äô$$. We take the intermediate matrix out and define it as a matrix $R$. This matrix consists of the inner product between the two sets of bases, describing the same vector‚Äôs coordinate transformation relationship before and after the rotation. It can be said that the matrix $R$ describes the rotation itself . So we call it the rotation matrix. Meanwhile, the components of the matrix are the inner product of the two coordinate system bases. Since the base vector‚Äôs length is $1$, it is actually the cosine of the angle between the base vectors. So this matrix is also called direction cosine matrix. The rotation matrix has some special properties.  In fact, it is an orthogonal matrix with a determinant of $1$. Conversely, an orthogonal matrix with a determinant of 1 is also a rotation matrix. So you can define a set of $n$ dimensional rotation matrices as follows:       $$SO(n) = \{ R \in \mathbb{R}^{n \times n}   RR^T = I, det(R) =1 \} $$   $SO(n)$ refers to the special orthogonal group. This set consists of a rotation matrix of $n$ dimensional space, in particular, $SO(3)$ refers to the rotation of the three-dimensional space. In this way, we can talk directly about the rotation transformation between the two coordinate systems without having to start from the bases. Since the rotation matrix is orthogonal, its inverse (i. e. , transpose) describes an opposite rotation. According to the above definition, there are: $$a‚Äô = R^{-1}a = R^Ta$$ Obviously, the $R^T$ represents an opposite rotation. In the Euclidean transformation, there is a translation in addition to rotation. Consider the vector $a$ in the world coordinate system. After a rotation (depicted by $R$) and a translation of $t$, we get $a‚Äô$. Then we can put the rotation and translation together, and have:$$a‚Äô= Ra+t$$,where $t$ is called a translation vector. Compared to the rotation, the translation part simply adds the translation vector to the coordinates after the rotation , which si very simple. By the above formula, we completely describe the coordinate transformation relationship using a rotation matrix $R$ and a translation vector $t$. In practice, we may define the coordinate system 1 and 2, then the vector $a$ under the two coordinates is $a_1, a_2$. The relationship between the two systems should be: $$a_1 = R_{12} a_2 + t_{12}$$. Here, $R_{12}$ means the ‚Äúrotation of the vector from system 2 to system 1‚Äù. About $t_{12}$, readers may just take it as a translation vector without wondering about its physical meaning. In fact, it corresponds to a vector from the system 1‚Äôs origin pointing to system 2‚Äôs origin, and the coordinates are taken under tsystem 1. So I suggest you to understand it as ‚Äúa vector from 1 to 2‚Äù. But the reverse $t_{21}$, which is a vector from $2$‚Äôs origin to $1$‚Äôs origin, whose coordinates are taken in system $2$, is not equal to $-t_{12}$. It is also related to the rotation of the two systems. Therefore, when beginners ask the question ‚ÄúWhat are my coordinates?‚Äù, we need to clearly explain this sentence‚Äôs meaning. Here, ‚Äúmy coordinates‚Äù normally refers to the vector from the world system $W$ pointing to the origin of the camera system $C$, and then take the coordinates in the world‚Äôs base. Corresponding to the mathematical symbol, it should be the value of $t_{WC}$. For the same reason, it is not $-t_{CW}$ but actually $-R^T_{CW} t_{CW}$. Transform Matrix and Homogeneous Coordinates: The formula $a‚Äô = Ra+t$ fully expresses the rotation and the translation of Euclidean space, but there is still a small problem: the transformation relationship here is not a linear relationship. Suppose we made two transformations: $R_1,t_1$ and $R_2,t_2$:$$b = R_1 a + t_1, c = R_2 b + t_2$$. So the transformation from $a$ to $c$ is: $$c = R_2 (R_1 a + t_1) + t_2$$. This form is not elegant after multiple transformations. Therefore, we introduce homogeneous coordinates and transformation matrices, rewriting the formula:$$ \begin{bmatrix} a‚Äô \\ 1 \end{bmatrix} = \begin{bmatrix} R &amp; t \\ 0^T &amp; 1 \end{bmatrix} \begin{bmatrix} a \\ 1 \end{bmatrix} \triangleq T \begin{bmatrix} a \\ 1 \end{bmatrix}$$. This is a mathematical trick: we add $1$ at the end of the 3D vector and turn it into a 4D vector called homogeneous coordinates. For this four-dimensional vector, we can write the rotation and translation matrix, making the whole relationship a linear relationship. In this formula, the matrix $T$ is called transform matrix. We temporarily use $\tilde{a}$ to represent the homogeneous coordinates of $a$. Then, relying on homogeneous coordinates and transformation matrices, the superposition of the two transformations can have a good form: $$\tilde{b} = T_1 \tilde{a}, \tilde{c} = T_2 \tilde{b} \Rightarrow T_2 T_1 \tilde{a}$$. But the symbols that distinguish between homogeneous and non-homogeneous coordinates are annoying, because here we only need to add 1 at the end of the vector or remove 1 to turn it into a normal vector. So, without ambiguity, we will write it directly as $b = Ta$ and by default we just assume a homogeneous coordinate conversion is made if needed. The transformation matrix $T$ has a special structure: the upper left corner is the rotation matrix, the right side is the translation vector, the lower-left corner is $0$ vector, and the lower right corner is $1$. This set of transform matrix is also known as the special Euclidean group: $$SE(3) = \{ T = \begin{bmatrix} R &amp; t \\ 0^T &amp; 1 \end{bmatrix} \in \mathbb{R}^{4 \times 4}| R \in SO(3), t \in \mathbb{R}^3 \}$$. Like $SO(3)$, the inverse of the transformation matrix represents an inverse transformation: $$T^{-1} = \begin{bmatrix} R^T &amp; -R^T t \\ 0^T &amp; 1 \end{bmatrix}$$. Again, we use the notation of $T_{12}$ to represent a transformation from 2 to 1. Because the conversion between homogeneous and non-homogeneous coordinates is actually very easy, it is assumed that the conversion from homogeneous coordinates to normal coordinates is already done. Summary: First, we introduced the vector and its coordinate representation and introduced the operation between the vectors; then, the motion between the coordinate systems is described by the Euclidean transformation, which consists of translation and rotation. The rotation can be described by the rotation matrix $SO(3)$, while the translation is directly described by an $\mathbb{R}^3$ vector. Finally, if the translation and rotation are placed in a matrix, the transformation matrix $SE(3)$ is formed. References:  Introduction to Visual SLAM"
    }, {
    "id": 2,
    "url": "https://sally20921.github.io/_posts/2021-09-02-depth.html",
    "title": "Depth Estimation: Basics and Intuition",
    "body": " Depth Estimation in Computer Vision : Depth estimation is also known as the inverse problem , where we seek to recover unknowns given insufficient information. So how do machines actually perceive depth? The earliest algorithm with impressive results began with depth estimation using stereo vision back in the 90s. A lot of progress was made on dense stereo correspondence algorithm Researchers were able to utilize geometry to constrain and replicate the idea of stereopsis mathematically. As for monocular depth estimation, it recently started to gain popularity by using neural networks. We will talk about this shortly after discussing stereo vision.  Depth Estimation from Stereo Vision : The main idea of solving depth using a stereo camera involves the concept of triangulation and streo matching . The former depends on good calibration and rectification to constrain the problem so that it can be modelled on a 2D plane known as epipolar plane . Epipolar plane greatly reduces the stereo matching problem to a line search along the epipolar line. Once we are able to match pixel correspondences between 2 views, the next task is to obtain a representation that encodes the difference .  This representation is known as disparity . The formula to obtain depth from disparity can be worked out from similar triangles.  Why is Measuring Depth So Difficult? : Before we move on, let‚Äôs try to understand some fundamental problems of depth estimation. The main culprit lies in the projection of 3D views to 2D images where depth information is lost . Another problem is deeply seeded when there are motion and moving objects .  Depth Estimation is Ill-Posed : Estimating depth from a single RGB image is an ill-posed inverse problem. What this means is that many 3D scenes observed in the 3D world can indeed correspond to the same 2D image plane.  Scale Ambiguity for Monocular Depth Estimation : The uncertain scale factor require current methods to have an additional sensor like LiDAR to provide depth ground-truth or stereo camera as additional training input, which makes them difficult to implement. Note that this issue exists only for monocular-based techniques , as the scale can be recovered for a stereo rig with a known baseline.  References : medium article medium article 2 medium article 3 paper about absolute depth "
    }, {
    "id": 3,
    "url": "https://sally20921.github.io/_posts/2021-09-05-camera.html",
    "title": "Dissecting the Camera Matrix (Part 1)",
    "body": " Camera Calibration and Decomposition : Primarily, camera calibration is about finding the quantities internal to the camera that affect the imaging process. Here are some of the factors that will be taken care of:  image center : we need to find the position of the image center in the image. Wait, isn't the image center located at $(width/2, height/2)$? Well, no. Unless we calibrate the camera, the image will almost always appear to be off-center.  focal length : this is a very important parameter. Remember how people using DSLR cameras tend to focus on things before capturing the image? this parameter is directly related to the focus of the camera and it is very critical.  scaling factors : the scaling factors for row pixels and column pixels might be different. If we don't take care of this thing, the image will look stretched (either horizontally or vertically).  skew factor : this refers to shearing. the image will look like a parallelogram otherwise.  lens distortion : this refers to the pseudo zoom effect that we see near the center of any image.  shearing refers to a transformation in which all points along a given line $L$ remain fixed while other points are shifted parallel to $L$ by a distance proportional to their perpendicular distance from $L$.  Pinhole Camera Model : Before we jump into anything, let's see where this all began. When we capture an image, we are basically mapping the 3D scene to a 2D scene. It means that every point in the 3D world gets mapped to the 2D plane of our image. This is called the pinhole camera model . It basically describes the relationship between the coordinates of the 3D point and its projection on the 2D image. This, of course, is the ideal case where there is absolutely no distortion of any kind. Every camera is modeled based on this, and every camera aspires to simulate this as close as possible. But in the real world, we have to deal with things like geometric distortions, blurring, finite sized apertures, etc. The figure shown here depicts a pinhole camera model. The camera is placed at the origin $O$. The point $P$ represents a point in the real world. We are trying to capture that onto a 2D plane. The image plane represents the 2D plane that you get after capturing the image. The image plane actually contains the image that you see after capturing a picture. So basically, we are trying to map every 3D point to a point on the image plane. In this case, the point $P$ gets mapped to $P_c$. The distance between the origin $O$ and this image plane is called the focal length of the camera. This is the parameter you modify when you adjst the focus of the camera.  Intrinsic and Extrinsic Parameters : In the above figure, we want to estimate $(u,v)$ from $(X,Y,Z)$. Let's say the focal length is denoted by $f$. If you look at the triangle formed using the origin-$P_c$-and the $Z$-axis with the origin-$P$ and $Z$-axis, you will notice that they are similar triangles. This means that $u$ depends on the $f$, $X$ and $Z$. Similarly, $v$ depends on $f$, $Y$ and $Z$. \$\$\displaylines{u = fX/Z \\\v = fY/Z}\$\$Next, if the origin of the 2D image coordinate system does not coincide with where the $Z$-axis intersects the image plane, we need to translate $P_c$ into the desired origin. Let this translation be defined by $(t_u, t_v)$. So now, $u$ and $v$ are given by:\$\$\displaylines{u = fX/Z + t_u \\\v = fY/Z + t_v}\$\$So up until now, we have something that can translate $(X,Y,Z)$ to $(u,v)$. Let's denote this matrix $M$. So we can write:\$\$ P_c = MP\$\$Since this is a camera image, we need to express it in inches. For this, we will need to know the resolution of the camera in pixels/inch. If the pixels are square the resolution will be identical in both $u$ and $v$ directions of the camera image coordinates. However, for a more general case, we assume rectangular pixels with resolution $m_u$ and $m_v$ pixels/inch in $u$ and $v$ directions respectively. Therefore, to measure $P_c$ in pixels, its $u$ and $v$ coordinates should be multiplied by $m_u$ and $m_v$ respectively. So now, this new transformation matrix depends on $f, X, Y, Z, t_u, t_v, m_u, m_v$. Let's denote this by:\$\$P_c = KP\$\$Here, $K$ is called the intrinsic parameter matrix for the camera. Now, if the camera does not have its center of projection at $(0,0,0)$ and is oriented in an arbitrary fashion (not necessarily $z$-perpendicular to the image plane), then we need roation and translation to make the camera coordinate system coincide with the configuration in that pinhole camera figure. Let the rotation applied to coincide the principal axis with $Z$-axis given by a $3 \times 3$ rotation matrix $R$. Then the matrix is formed by first applying the translation followed by the rotation is given by the $3 \times 4$ matrix. \$\$E = \\( R|RT \\)\$\$This is called the extrinsic parameter matrix for the camera . So, the complete camera transformation can now be represented as: \$\$ K \\( R|RT \\) = KR \\( I|T \\)\$\$Hence, $P_c$ the projection of $P$ is given by:\$\$P\_c = KR \\( I|T \\) P = CP\$\$$C$ is a $3 \times 4$ matrix usually called the complete camera calibration matrix. So basically, camera calibration matrix is used to transform a 3D point in the real world to a 2D point on the image plane considering all the things like focal length of the camera, distortion, resolution, shifting of origin, etc.  References :  ksimek blog prateekvjoshi blog "
    }, {
    "id": 4,
    "url": "https://sally20921.github.io/_posts/2021-09-05-disparity.html",
    "title": "Depth from Disparity",
    "body": " üåü 3D Reconstruction from 2D Signals : We are going to look at depth estimation as a multi-view problem. Multi-view problems can span into different domains including stereo vision, Structure from Motion and optical flow. Although each carries great importance in the problem of Virtual Reality (VR) and robotics, we will focus on stereo vision in this multi-part series. Specifically, the progress of deep learning in stereo vision technology. How can we automatically compute 3D geometry from images ? What cues in the image provide 3D information? Before looking at binocular, let‚Äôs consider single view characteristics. Well, we humans do so naturally. Here are several cues we use to infer depth information: shading texture  focus motion  perspective occlusion  symmetry Nonetheless, structure and depth are inherently ambiguous from a single view. As seen from the optical center (i. e. , camera location), $P1$ and $P2$ are projected onto the image plane as equivalent.  The Stereo Problem : Stereo vision systems reference the knowledge of two images captured simultaneously from a pair of cameras (left and right) with camera parameters (extrinsic and intrinsic). Stereo is heavily motivated by biology. Classic stereo problem include disparity, depth, occlusion, Structure from Motion, motion parallax etc. Provided left and right images, the ambiguity problem of the aforementioned is satisfied via triangulation from the two image planes by matching correspondences of a point in the world coordinate to the ones that can be seen in both images. The basic principle of triangulation is shown above: the reconstruction via the intersection of two rays. Requirements? Calibration and correspondences. Furthermore,  the Epipolar Constraint reduces the correspondence problem to $1D$ search along conjugate epipolar lines shown in the above figure. Thus, Epipolar Constraint assumes that stereo pairs are rectified images, meaning the same epipolar line aligns across rows such that it is orthogonal to both and aligned with one another. Rectification is achieved by learning a transformation based on intrinsic and extrinsic parameters: a process that dates back several decades. From the rectified image pair, the depth $Z$ can be determined by its inversely proportionate relationhip with disparity $d$, where the disparity is defined as the pixel difference along the horizontal when comparing correspondences of left and right. This can be written as: $$I(x,y) = D(x+d, y)$$ This relationship is easiest to grasp visually. Provided a point in the left image plane $P_L(x,y)$ along with the correspondence in the right image plane and the world coordinates $(X,Y,Z)$ projected as a point in a 3D scene, our goal is to reconstruct the missing $Z$ (depth) provided the stereo pair. We set the relative coordinates (red axis) along with having known baseline $b$ between the two camera centers. Then $/frac{x_L}{f}$ can be expressed as $\frac{X+b/2}{Z}$ and $\frac{x_R}{f} = \frac{X-b/2}{Z}$. Therefore, $$\frac{y_L}{f} = \frac{y_R}{f} = \frac{Y}{Z}$$ and the world coordinate can be expressed as $$X = \frac{b(x_L+x_R)}{2(x_L - x_R)} Y = \frac{b(y_L + y_R}{2(x_L-x_R} Z = \frac{bf}{(x_L - x_R)}$$ $d = x_L - x_R$ is the disparity between corresponding left and right image points References :  article from medium "
    }, {
    "id": 5,
    "url": "https://sally20921.github.io/_posts/2021-09-08-group-norm.html",
    "title": "Batch Normalization and Group Normalization",
    "body": " Batch Normalization: the Principles : Batch Normalization is an algorithmic method which makes the training of Deep Neural Networks faster and more stable . Batch normalization is computed differently during the training and the testing phase. At training , the BN layer determines the mean and standard deviation of the activation values across the batch. It then normalizes the activation vector with $\mu$ and $\sigma$. That way, each neuron‚Äôs output follows a standard normal distribution across the batch . It finally applies a linear transformation with $\gamma$ and $\beta$ which are the two trainable parameters. Such step allows the model to choose the optimum distribution for each hidden layer. $\gamma$ allows to adjust the standard deviation while $\beta$ allows to adjust the bias, shifting the curve on the right or on the left side. At each iteration, the network computes the mean $\mu$ and the standard deviation $\sigma$ corresponding to the current batch. Then it trains $\gamma$ and $\beta$ through gradient descent using an Exponential Moving Average (EMA) to give more importance to the latest iterations.  We mostly use Exponential Moving Average algorithm to reduce the noise or to smooth the data. The weight of each element decreases progressively over time, meaning the EMA gives greater weight to recent data points . EMA reacts faster to changes compared to Simple Moving Average. At the evaluation phase , we may not have a full batch to feed into the model. To tackle this issue, we compute $\mu_{pop}$ and $\sigma_{pop}$ as the estimated mean and standard deviation of the studied population . Those values are computed using all the $\mu_{batch}$ and $\sigma_{batch}$ during training, and directly fed during the evaluation phase.  Why Normalization? : What we can conclude from the original Batch Normalization paper is that:  Adding BN layers leads to better convergence and higher accuracy  Adding BN layers allows us to use higher learning rate without compromising convergence. To quote Ian Goodfellow about the use of batch normalization: Before BN, we thought it was almost impossible to efficiently train deep models using sigmoid in the hidden layers. Batch Normalization makes those unstable networks trainable. In practice, it is widely admitted that: For CNNs, Batch Normalization is better  For Recurrent Networks, Layer Normalization is better While BN uses the current batch to normalize every single value, LN uses all the current layer to do so.  The normalization is performed using other features from a single example instead of using the same feature across all current batch examples. The best way to understand why BN works is to understand the optimization landscape smoothness . BN reparameterizes the underlying optimization problem , making the training faster and easier. In additional recent studies, researchers observed that this effect is not unique to BN, but applies to other normalization methods (i. e. L1 normalization or L2 normalization).  The Drawbacks of BN : For BN to work, the batch size is required to be sufficiently large , usually at least 32 . However, there are situations when we have to settle for a small batch size. For example, when each data sample is highly memory consuming or when we train a very large neural network which leaves little GPU memory for processing data. For computer vision applications other than image classification, the restriction on batch sizes are more demanding and it is difficult to have higher batch sizes.  Comparisions of Normalization Methods : Group Normalization is one of the latest normalization methods that avoids exploiting the batch dimension, thus is independent of batch size. But there are other normalization methods as well.  Layer Normalization : Layer Normalization computes $\mu_i$ and $\sigma_i$ along the (C,H,W) axes. The computation for an input feature is entirely independent of other input features in a batch.  Instance Normalization : Instance Normalization computes $\mu_i$ and $\sigma_i$ along the (H,W) axes. Since the computation of IN is the same as that of BN with batch_size=1, IN actually makes the situation worse in most cases. However, for style transfer tasks , IN is better at discarding contrast information of an image, thus having superior performance than BN.  Group Normalization : Also notice that IN can be viewed as applying Layer Normalization to each channel individually as if the num_channels = 1. Group Normalization is the middle ground between IN and LN. It organizes the channels into different groups and computes $\mu_i$ and $\sigma_i$ along the (H,W) axes and along a group of channels. First, the batch with dimension (N,C,H,W) is reshaped to (N,G,C//G,H,W). The number of group $G$ is a pre-defined hyperparameter . Then we normalize along the (C//G,H,W) dimension and return the result after reshaping the batch back to (N,C,H,w). Group Normalization is better than Layer Normalization as GN allows different distribution to be learned for each group of channels. GN is also thought to be better than IN because GN can exploit the dependence across channels. If `C = G`, that is, if the number of groups are set to be equal to the number of channels, GN becomes IN . Likewise, if `G = 1` GN becomes LN .  References :  blog post medium article medium article2 "
    }, {
    "id": 6,
    "url": "https://sally20921.github.io/_posts/2021-09-09-no-bullshit.html",
    "title": "Guide to Linear Algebra (Part 1)",
    "body": " Computational Linear Algebra : This chapter covers the computational aspects of performing matrix calculations. Understanding matrix computations is important because all later chapters depend on them. Suppose we‚Äôre given a huge matrix $ A \in R^{n \times n} $ with $ n=1000 $. Hidden behind the innocent-looking mathematical notation of the matrix inverse $A^{-1}$, the matrix product $AA$, and the matrix determinant $ | A |$, lie monster coputations involving all the $1000 \times 1000 = 1$ million entries of the matrix $A$. Millions of arithmetic operations must be performed, so I hope you have at least a thousand pencil ready! Okay, calm down. I won‚Äôt actually make you calculate millions of arithmetic operations. In fact, to learn linear algebra, it is sufficient to know how to carry out calculations with $3 \times 3$ and $4 \times 4$ matrices. Even for such moderately sized matrices, computing products, inverses, and determinants by hand are serious computational tasks. If you‚Äôre ever required to take a linear algebra final exam, you need to make sure you can do these calculations quickly. Even if no exam looms in your imminent future, it‚Äôs important to practice matrix operations by hand to get a feel for them. This chapter will introduce you to the following computational tasks involving matrices: Gauss-Jordan elimination Suppose we're trying to solve two equations in two unknowns $x$ and $y$:\$\$ \displaylines{ax+by = c \\\dx+ ey= f}\$\$If we add $\alpha$\times the first equation to the second equation, we obtain an equivalent system of equations:\$\$\displaylines{ax + by = c \\\(d + \alpha a)x + (e + \alpha b)y = f + \alpha c}\$\$This is called a row operation : we added $\alpha$-times the first row to the second row. Row operations change the coefficient of the system of equations, but leave the solution unchanged. Gauss-Jordan elimination is a systematic procedure for solving systems of linear equations using row operations.  Matrix product The product $AB$ between matrices $A \in \mathbb{R}^{m \times l}$ and $B \in \mathbb{R}^{l \times n}$ is the matrix $C \in \mathbb{R}^{m \times n}$ whose coefficients $c_{ij}$ are defined by the formula $c_{ij} = \sum_{k=1}^{l}a_{ik}b_{kj}$ for all $i \in \lbrack 1, \dots, m \rbrack $ and $j \in \lbrack 1, \dots, n \rbrack $. We'll soon unpack this formula and learn about its intuitive interpretation: that computing $C = AB$ is computing all the dot products between the rows of $A$ and the columns of $B$.  Determinant The determinant of a matrix $A$, denoted $|A|$ is an operation that gives us useful information about the linear independence of the rows of the matrix. The determinant is connected to many notions of linear algebra: linear independence, geometry of vectors, solving systems of equations, and matrix invertibility. We'll soon discuss these aspects.  Matrix inverse We'll build upon our knowledge of Gauss-Jordan elimination, matrix products, and determinants to derive three different procedures for computing the matrix inverse $A^{-1}$. Reduced Row Echelon Form : In this section, we‚Äôll learn to solve systems of linear equations using the Gauss-Jordan elimination procedure. A system of equations can be represented as a matrix of coefficients. The Gauss-Jordan elimination procedure converts any matrix into its  reduced row echelon form (RREF) . We can easily find the solution (or solutions of the system of equations from the RREF. Listen up: the material covered in this section requires your full on, caffeinated attention, as the procedures you‚Äôll learn are somewhat tedious. Gauss-Jordan elimination involves many repetitive mathematical manipulations of arrays of numbers. It‚Äôs important you hang in there and follow through the step-by-step manipulations, as well as verify each step I present on your own with pen and paper.  Solving Equations : Suppose you‚Äôre asked to solve the following system of equations: $$\displaylines{1x_1 + 2x_2 = 5 \3x_1 + 9x_2 = 21}$$ The standard approach is to use one of the equation-solving tricks we learned to combine the equations and find the values of the two unknowns $x_1$ and $x_2$. Observe that the names of the two unknowns are irrelevant to the solution of the system of equations. Indeed, the solution $(x_1, x_2)$ to the above system of equations is the same as the solution $(s,t)$ to the system of equations $$\displaylines{1s+ 2t = 5 \3s+ 9t = 21}$$ The important parts of a system of linear equations are the coefficients in front of the variables and the constants on the right-hand side of each equation.  Augmented Matrix : The system of linear equations can be written as an augmented matrix : $$\begin{pmatrix} 1 &amp; 2 &amp;\bigm | &amp; 5 \        3 &amp; 9 &amp;\bigm | &amp; 21\end{pmatrix}$$ The first column corresponds to the coefficients of the first variable, the second column is for the second variable, and the last column corresponds to the constants of the right-hand side. It is customary to draw a vertical line where the equal signs in the equations would normally appear. This line helps distinguish the coefficients of the equations from the column of constants on the right-hand side. Once we have the augmented matrix, we can simplify it by using row operations (which we‚Äôll discuss shortly) on its entries. After simplification by row operations, the augmented matrix will be transformed to $$\begin{pmatrix}1 &amp; 0 &amp;\bigm | &amp; 5 \0 &amp; 1 &amp;\bigm | &amp; 2\end{pmatrix} $$ which corresponds to the system of equations $$\displaylines{x_1 = 1 \x_2 = 2}$$ This is a trivial system of equations; there is nothing left to solve and we can see that the solutions are $x_1 = 1$ and $x_2 = 2$. This example illustrates the general idea of the Gauss-Jordan elimination procedure for solving the system of equations by manipulating an augmented matrix.  Row Operations : We can manipulate the rows of an augmented matrix without changing its solutions. We‚Äôre allowed to perform the following three types of row operations: Add a multiple of one row to another row Swap the position of the two rows Multiply a row by a constant Let‚Äôs trace the sequence of row operations needed to solve the system of equations $$\displaylines{x_1 + 2x_2 = 5 \3x_1 + 9x_2 = 21}$$ starting from its augmented matrix: $$\begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \3 &amp; 2 &amp;\bigm | &amp; 21\end{pmatrix}$$  As a first step, we eliminate the first variable in the second row by subtracting three times the first row from the second row. $$ \begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \0 &amp; 3 &amp;\bigm | &amp; 6\end{pmatrix}$$ We denote this row operation as $R_2 \leftarrow R_2 - 3R_1$.  To simplify the second row, we divide it by 3 to obtain$$ \begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \0 &amp; 1 &amp;\bigm | &amp; 2 \end{pmatrix}$$ This row operation is denoted $R_2 \leftarrow \frac{1}{3}R_2$.  The final step is to eliminate the second variable from the first row. We do this by subtracting two times the second row from the first row $R_1 \leftarrow R_1 - 2 R_2$:$$\begin{pmatrix}1 &amp; 0 &amp;\bigm | &amp; 1 \0 &amp; 1 &amp;\bigm | &amp; 2\end{pmatrix}$$ We can now read off the solution: $x_1 =1$ and $x_2 = 2$. Note how we simplified the augmented matrix through a specific procedure: we followed the Gauss-Jordan elimination algorithm to bring the matrix into its reduced row echelon form. The reduced row echelon form (RREF) is the simplest form for an augmented matrix. Each row contains a leading one (a numeral 1) also known as a pivot . Each column‚Äôs pivot is used to eliminate the numbers that lie below and above it in the same column. The end result of this procedure is the reduced row echelon form: $$\begin{pmatrix}1 &amp; 0 &amp; \ast &amp; 0 &amp;\bigm | \ast \0 &amp; 1 &amp; \ast &amp; 0 &amp;\bigm | \ast \0 &amp; 0 &amp; 0 &amp; 1 &amp;\bigm | \ast\end{pmatrix}$$ Note the matrix contains only zero entries below and above the pivots. The asterisks $\ast$ denote arbitrary numbers that could not be eliminated because no leading one is present in these columns. The solution to a system of linear equations in the variables $x_1, x_2, \dots, x_n$ is the set of values $\{(x_1, x_2, \dots, x_n)\}$ that satisfy all the equations. Gaussian elimination is the process of bringing a matrix into row echelon form.  A matrix is said to be in row echelon form (REF) if all entries below the leading ones are zero. This form can be obtained by adding or subtracting the row with the leading one from the rows below it.  Gaussian-Jordan elimination is the process of bringing a matrix into reduced row echelon form.  A matrix is said to be in reduced row echelon form (RREF) if all the entries below and above the pivots are zero. Starting from the REF, we obtain the RREF by subtracting the row containing the pivots from the rows above them. the rank of the matrix $A$ is the number of pivots in the RREF of $A$.  Number of Solutions : A system of linear equations in three variables could have: one solution If the RREF of a matrix has a pivot in each row, we can read off the values of the solution by inspection. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; c_1 \\\0 &amp; 1 &amp; 0 &amp; c_2 \\\0 &amp; 0 &amp; 1 &amp; c_3\end{bmatrix}\$\$The unique solution is $x_1 = c_1$, $x_2 = c_2$, and $x_3 = c_3$.  Infinitely many solutions 1 If one of the equations is redundant, a row of zeros will appear when the matrix is brought to the RREF. This happens when one of the original equations is a linear combination of the other two. In such cases, we're really solving two equations in three variables, so can't pin down one of the unknown variables. We say the solution contains a free variable . For example, consider the following RREF:\$\$\begin{bmatrix} 1 &amp; 0 &amp; a_1 &amp; c_1 \\\0 &amp; 1 &amp; a_2 &amp; c_2 \end{bmatrix}\$\$The column that doesn't contain a leading one corresponds to the free variable. To indicate that $x_3$ is a free variable, we give it a special label $x_3 \equiv t$. The variable $t$ could be any number $t \in \mathbb{R}$. In other words, when we say $t$ is free, it means $t$ can take on any value from $-\infty$ to $+\infty$. The information in the augmented matrix can now be used to express $x_1$ and $x_2$ in terms of the right-hand constants and the free variable $t$:\$\$\begin{Bmatrix} x_1 = c_1 - a_1 t \\\ x_2 = c_2 - a_2 t \\\ x_3 = t, \forall t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} c_1 \\\ c_2 \\\ 0 \end{bmatrix} + t \begin{bmatrix} -a_1 \\\ -a_2 \\\ 1 \end{bmatrix}, \forall t \in \mathbb{R}\end{Bmatrix}\$\$. The solution corresponds to the equation of a line passing through the point $(c_1, c_2, 0)$ with direction vector $(-a_1, -a_2, 1)$. We'll discuss the geometry of lines in the next section. For now, it's important that you understand that a system of equations can have more than one solution; any point on the line $l \equiv \{(c_1, c_2, 0) + t(-a_1, -a_2, 1), \forall t \in \mathbb{R}\}$ is a solution to the above system of equations.  Infinitely many solutions 2 It's also possible to obtain a two-dimensional solution space. This happens when two of the three equations are redundant. In this case, there will be a single leading one, and thus two free variables. For example, in the RREF\$\$\begin{bmatrix} 0 &amp; 1 &amp; a_1 &amp; c_1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}\$\$the variables $x_1$ and $x_3$ are free. As in the previous infinitely-many-solutions case, we define new labels for the free variables $x_1 \equiv s$ and $x_3 \equiv t$, where $ s \in \mathbb{R}$ and $t \in \mathbb{R}$ are two arbitrary numbers. The solution to this system of equations is \$\$ \begin{Bmatrix} x_1 = s \\\ x_2 = c_2 - a_2 t \\\ x_3 = t , \\\ \forall s,t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} 0 \\\ c_2 \\\ 0 \end{bmatrix} + s \begin{bmatrix} 1 \\\ 0 \\\ 0 \end{bmatrix} + t \begin{bmatrix} 0 \\\ -a_2 \\\ 1 \end{bmatrix}, \forall s,t \in \mathbb{R} \end{Bmatrix} \$\$This solution set corresponds to the parametric equation of a plane that contains the point $(0,c_2, 0)$ and the vectors $(1,0,0)$ and $(0, -a_2, 1)$. The general equation for the solution plane is $0x+1y+a_2z = c_2$, as can be observed from the first row of the augmented matrix. In the next section, we'll learn more about the geometry of planes and how to convert between their general and parametric forms.  no solutions If there are no numbers $(x_1, x_2, x_3)$ that simultaneously satisfy all three equations, the system of equations has no solution. An example of a system of equations with no solution is the pair $ s+t = 4$ and $s+t = 44$. There are no numbers $(s,t)$ that satisfy both these equations. A system of equations has no solution if its reduced row echelon form contains a row of zero coefficients with a nonzero constant in the right-hand side:\$\$\begin{Bmatrix}\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; c_1 \\\\ 0 &amp; 1 &amp; 0 &amp; c_2 \\\\ 0 &amp; 0 &amp; 0 &amp; c_3 \end{array}\end{Bmatrix}\$\$If $c_3 \neq 0$ this system of equations is impossible to satisfy. There is no solution because there are no numbers $(x_1, x_2, x_3)$ such that $0x_1 + 0x_2 + 0x_3 = c_3$. Dear reader, we've reached the first moment in this book where you'll need to update your math vocabulary. The solution to an individual equation is a finite set of points. The solution to a system of equations can be an entire space containing infinitely many points, such as a line or a plane. The solution set of a system of three linear equations in three unknowns could be either the empty set $\{0\}$ (no solution), a set with one element $\{(x_1, x_2, x_3)\}$, or a set with infinitely many elements like a line $\{p_o + t \overrightarrow{v}, t \in \mathbb{R}\}$ or a plane $\{p_o + s \overrightarrow{v} + t \overrightarrow{w}, s,t \in \mathbb{R}\}$. Another possible solution set is all of $\mathbb{R}^3$; every vector $ \overrightarrow{x} \in \mathbb{R}^3 $ is a solution to the equation \$\$\begin{bmatrix} 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0 \end{bmatrix} \begin{bmatrix} x_1 \\\ x_2 \\\ x_3 \end{bmatrix} = \begin{bmatrix} 0 \\\ 0 \\\ 0 \end{bmatrix}\$\$Note the distinction between the three types of infinite solution sets. A line is one-dimensional, a plane is two-dimensional, and $\mathbb{R}^3$ is three-dimensional. Describing all points on a line requires one parameter, describing all points on a plane takes two parameters, and-of course-describing a point in $\mathbb{R}^3$ takes three parameters.  Geometric Interpretation : We can gain some intuition about solution sets by studying the geometry of the intersections of lines in $\mathbb{R}^2$ and planes in $\mathbb{R}^3$.  Lines in two dimensions : Equations of the form $ax+by = c$ corresponds to lines in $\mathbb{R}^2$. Solving systems of linear equations of the form\$\$\displaylines{a_1 x + b_1 y = c_1 \\\a_2 x + b_2 y = c_2}\$\$requires finding the point $(x,y) \in \mathbb{R}^2$ where these lines intersect. There are three possibilities for the solution set:- one solution if the two lines intersect at a point. - infinitely many solutions if the lines are superimposed. - no solution if the two lines are parallel and never intersect. Planes in three dimensions : Equations of the form $ax+by+cz = d$ correspond to planes in $\mathbb{R}^3$. When solving three such equations, \$\$ \displaylines{a_1 x + b_1 y + c_1 z = d_1 \\\a_2 x + b_2 y + c_2 z = d_2 \\\a_3 x + b_3 y + c_3 z = d_3}\$\$we want to find a set of points $(x,y,z)$ that satisfy all three equations simultaneously. There are four possibilities for the solution set:1.  one solution three non-parallel planes intersect at a point. 2.  infinitely many solutions 1 if only one of the plane equations is redundant, the solution corresponds to the intersection of two planes which is a line. 3.  infinitely many solutions 2 if two of the equations are redundant, then the solution space is a two-dimensional space. 4.  if two (or more) of the planes are parallel, they will never intersect.  Determinants : Overview : What is the volume of a rectangular box of length $1m$, width $2$ and height $3m$? It's easy to compute the volume of this box because its shape is right rectangular prism. The volume of this prism is $V = l \times w \times h = 6m^3$. What if the shape of the box was a parallelpiped instead? A parallelpiped is a box whose opposite faces are parallel but whose sides are slanted. How do we compute the volume of a parallelpiped? The determinant operation, specifically the $3 \times 3$ determinant, is the perfect tool for this purpose. The determinant of a matrix, denoted $det(A)$ or $|A|$, is a particular way to multiply the entries of the matrix to produce a single number. We use determinants for all kinds of tasks: to compute areas and volumes, to solve systems of linear equations, to check whether a matrix is invertible or not, etc. We can interpret the determinant of a matrix intuitively as a geometrical calculation. The determinant is the volume of the geometric shape whose edges are the rows of the matrix. For $2 \times 2$ matrices, the determinant corresponds to the area of a parallelogram. For $3 \times 3$ matices, the determinant corresponds to the volume of a parallelpiped. For dimensions $d &gt; 3$, we say the determinant measures a $d$-dimensional hyper-volume . Consider the linear transformation $T: \mathbb{R}^2 \rightarrow \mathbb{R}^2$ defined through the matrix-vector product with a matrix $A_T: T(\overrightarrow{x}) \equiv A_T \overrightarrow{x}$. The determinant of the matrix $A_T$ is the scale factor associated with the linear transformation $T$. The scale factor of the linear transformation $T$ describes how the area of a unit square in the input space (a square with dimensions $1 \times 1$) is transformed by $T$ . After passing through $T$, the unit square is transformed to a parallelogram with with area $det(A_T)$. Linear transformations that shrink areas have $det(A_T) &lt; 1$, while linear transformations that enlarge areas have $det(A_T) &gt; 1$. A linear transformation that is area preserving has $det(A+T) = 1$. The determinant is also used to check linear independence for a given set of vectors. We construct a matrix using the vectors as the matrix rows , and compute its determinant. The determinant of a matrix tells us whether or not that matrix is invertible . If $det(A) \neq 0$, then $A$ is invertible; if $det(A) = 0$, $A$ is not invertible. The determinant shares a connection with the vector cross product , and is used in the definition of the eigenvalue equation . Formulas : The determinant of a $2 \times 2$ matrix is \$\$det(\begin{bmatrix} a_{11} &amp; a_{12} \\\ a_{21} &amp; a_{22} \end{bmatrix}) = \begin{vmatrix} a_{11} &amp; a_{12} \\\ a_{21} &amp; a_{22} \end{vmatrix} = a_{11}a_{22} - a_{12}a{21}\$\$The formulas for the determinants of larger matrices are defined recursively. For example, the determinant of $3 \times 3$ matirx is defined in terms of $2 \times 2$ determinants:\$\$ \begin{vmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\ a_{21} &amp; a_{22} &amp; a_{23} \\\ a_{31} &amp; a_{32} &amp; a_{33} \end{vmatrix} = a_{11} = a_{11} \begin{vmatrix}a_{22} &amp; a_{23} \\\ a_{32} &amp; a_{33} \end{vmatrix} -a_{12} \begin{vmatrix} a_{21} &amp; a_{23} \\\ a_{31} &amp; a_{33} \end{vmatrix}+ a_{13} \begin{vmatrix} a_{21} &amp; a_{22} \\\ a_{31} &amp; a_{32} \end{vmatrix}\$\$ There's a neat computational trick for computing $3 \times 3$ determinants by hand. The trick consists of extending the matrix $A$ into a $3 \times 5$ array that contains copies the columns of $A$: the $1^{st}$ column of $A$ is copied to the $4^{th}$ column of the extended array, and the $2^{nd}$ column of $A$ is copied to the $5^{th}$ column. The determinant is then computed by summing the products of the entries on the three positive diagonals and subtracting the products of the entries on the three negative diagonals. The general formula for the determinant of an $n \times n$ matrix is\$\$det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}\$\$where $M_{ij}$ is called the minor associated with the entry $a_{ij}$. The minor $M_{ij}$ is the determinant of the submatrix obtained by removing the $i^{th}$ row and the $j^{th}$ column of the matrix $A$. Note the alternating factor $(-1)^{i+j}$ that changes value between $+1$ and $-1$ for different terms in the formula. The determinant of a $4 \times 4$ matrix $B$ is \$\$ det(B) = b_{11}M_{11} - b_{12}M_{12} + b_{13}M_{13} - b_{14}M_{14}\$\$The general formula for determinants $det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}$ assumes we're expanding the determinant along the first row of the matrix. In fact, a determinant formula can be obtained by expanding the determinant along anyrow or column of the matrix. The expand-along-any-row-or-column nature of determinants can be very handy: if you need to calculate the determinant of a matrix with one row (or column) containing many zero entries, it makes sense to expand along that row since many of the terms in the formula will be zero. If a matrix contains a row (or column) consisting entirely of zeros, we can immediately tell its determinant is zero.  Geometric interpretation : Area of a parallelogram Suppose we're given vectors $overrightarrow{v} = (v_1, v_2)$ and $\overrightarrow{w} = (w_1, w_2)$ in $\mathbb{R}^2$ and we construct a parallelogram with corner points $(0,0), \overrightarrow{v}, \overrightarrow{w}$ and $\overrightarrow{v} + \overrightarrow{w}$. The area of this parallelogram is equal to the determinant of the matrix that contains $(v_1, v_2)$ and $(w_1, w_2)$ as rows:\$\$area = \begin{vmatrix} v_1 &amp; v_2 \\\ w_1 &amp; w_2 \end{vmatrix} = v_1 w_2 - v_2 w_1 \$\$ Theoretical Linear Algebra : The things we are going to learn now are less concerned with calculations and more about mind expansion. This section extends what we know about the vector space $\mathbb{R}^n$ to the realm of abstract vector spaces of vector-like mathematical objects.  Eigenvalues and Eigenvectors : The set of eignevectors of a matrix is a special set of input vectors for which the action of the matrix is described as simple scaling . Decomposing a matrix in terms of its eigenvalues and its eigenvectors gives valuable insights into the properties of the matrix. Certain matrix calculations, like computing the power of the matrix, become much easier when use the eigendecomposition of the matrix For example, suppose we're given a square matrix $A$ and want to compute $A^7$. To make this example more concrete, we'll analyze the matrix \$\$A = \begin{bmatrix} 9 &amp; -2 \\\ -2 &amp; 6 \end{bmatrix}\$\$We want to compute $A^7$. That would be an awful lot of matrix multiplications. Every matrix corresponds to some linear operation. This means it's legit to ask,  what does the matrix A do?  Once we figure out this part, we can compute $A^{77}$ by simply doing what $A$ does $77$ times. The best way to see what a matrix does is to look inside it and see what it's made of. To understand the matrix $A$, you must find it its eigenvectors and its eigenvalues. The eigenvectors of a matrix are a natural basis for describing the action ofthe matrix. The eigendecomposition is a change-of-basis operation that expresses the matrix $A$ with respect to its eigenbasis (own-basis). The eigendecompositions of the matrix $A$ is a product of three matrices:"
    }, {
    "id": 7,
    "url": "https://sally20921.github.io/_posts/2021-09-12-pytorch.html",
    "title": "Advanced PyTorch: Things You Didn't Know",
    "body": " Flatten Operation for a Batch of Image Inputs to a CNN : Flattening specific tensor axis is often required with CNNs because we work with batches of inputs opposed to single inputs. A tensor flatten operation is a common operation inside convolutional neural networks. This is because convolutional layer outputs that are passed to fully connected layers must be flattened out so that the fully connected layer can accept them as the input. A flatten operation is a specific type of reshaping operation where by all of the axes are smooshed or squashed together. To flatten a tensor, we need to have at least two axes. This makes it so that we are starting with something that is not already flat. For example, in the MNIST dataset, we will look at an handwritten image of eight. This image has 2 distinct dimensions, height and width. The height and width are $18 \times 18$ respectively. These dimensions tell use that this is a cropped image becaue the MNIST dataset contains $28 \times 28$ images. Let‚Äôs see how these two axes of height and width are flattened out into a single axis of length 324 (c. f. 324 what we get when multiplying 18 with 18).  Flattening Specific Axes of a Tensor : Tensor inputs to a convolutional neural network typically have 4 axes, one for batch size, one for color channels, and one each for height and width. $$[B,C,H,W]$$ Suppose we have the following three tensors: t1 = torch. tensor([  [1,1,1,1],  [1,1,1,1],  [1,1,1,1],  [1,1,1,1]])t2 = torch. tensor([  [2,2,2,2],  [2,2,2,2],  [2,2,2,2],  [2,2,2,2]])t3 = torch. tensor([  [3,3,3,3],  [3,3,3,3],  [3,3,3,3],  [3,3,3,3]])Each of these has a shape of $4 \times 4$, so we have three rank-2 tensors. For our purpose, we‚Äôll consider these to be three $4 \times 4$ images that we will use to create a batch that can be passed to a CNN. Batches are represented using a single tensor, so we‚Äôll need to combine these three tensors into a single larger tensor that has 3 axes instead of 2. t = torch. stack((t1, t2, t3))t. shape &gt; torch. Size([3,4,4])Here, we used the stack() method to concatenate our sequence of tensors along a new axis. Since we have three tensors along a new axis, we know that the length of this axis should be 3. At this point, we have a rank-3 tensor that contains a batch of three $4 \times 4$ images. All we need to do now to get this tensor into a form that a CNN expects is add an axis for the color channels. We basically have an implicit single color channel for each of these image tensors, so in practice, these would be grayscale images. torch. reshape(3,1,4,4)Notice how the additional axis of length 1 doesn‚Äôt change the number of elements in the tensor. This is because the product of the components values doesn‚Äôt change when we multiply by one. The first axis has 3 elements. Each element of the first axis represents an image. For each image, we have a single color channel on the channel axis. Each of these channels contain 4 arrays that contain 4 numbers or scalar components.  Flattening the Tensor Batch : Let‚Äôs see how to flatten images in this batch. Remember the whole batch is a single tensor that will be passed to the CNN, we don‚Äôt want to flatten the whole thing We only want to flatten the image tensors within the batch tensor. For example, if we do the following operations on t: t. flatten() &gt;&gt; tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,  2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])# this is the same operation as t. flatten()t. reshape(-1)What I want you to notice about this output is that we have flattened the entire batch, and this smashes all the batches together into a single axis. The flattened batch won‚Äôt work well inside our CNN because we need individual predictions for each image within our batch tensor, and now we have a flattened mess. The solution here, is to flatten each image while still maintaining the batch axis . This means we want to flatten only part of the tensor . We want to flatten the color channel axis with the height and width axes.  The Axes that Need to be Flattened: $[C,H,W]$ This can be done with PyTorch‚Äôs built in flatten() function. t. flatten(start_dim=1). shape&gt;&gt; torch. Size([3,16])t. flatten(start_dim=1)&gt;&gt; [  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]])Notice how we specified the start_dim parameter. This tells the flatten() method which axis it should start the flatten operation. Now we have a rank-2 tensor with three single color channel images that have been flattened out into 16 pixels.  Flattening an RGB Image : If we flatten an RGB image, what happens to the color? Each color channel will be flattened first, then the flattened channels will be lined up side by side on a single axis of the tensor. For example, we build an RGB image tensor like the following code: r = torch. ones(1,2,2)g = torch. ones(1,2,2)+1b = torch. ones(1,2,2)+2img = torch. cat((r,g,b),dim=0)img. shape&gt;&gt; torch. Size([3,2,2])By flattening the image tensor, this is how it is going to look like. img. flatten(start_dim=0)&gt;&gt; tensor([1. , 1. , 1. , 1. , 2. , 2. , 2. , 2. , 3. , 3. , 3. , 3. ]) Broadcasting and Element-Wise Operations with PyTorch : Remember, all these rules apply to PyTorch Tensors! Python built-in types such as list will not behave this way. Element-Wise Operations : An element-wise operation is an operation between two tensors that operates on corresponding elements within the respective tensors. Two elements are said to be corresponding if the two elements occupy the same position within the tensor. The position is determined by the indexes used to locate each element. Therefore, we can deduce that tensors must have the same shape in order to perform an element-wise operation.  Broadcasting Tensors : Broadcasting describes how tensors with different shapes are treated during element-wise operations. For example, suppose we have the following two tensors: t1 = torch. tensor([[1,1],[1,1]],dtype=torch. float32)t1. shape&gt;&gt; torch. Size([2,2])t2 = torch. tensor([2,4], dtype=torch. float32)t2. shape&gt;&gt; torch. Size([2])What will be the result of this two tensors‚Äô element-wise addition operation? Even though these two tensors have differing shapes, the element-wise operation is possible, and broadcasting is what makes the operation possible. The lower rank tensor t2 will be transformed via broadcasting to match the shape of the higher rank tensor t1, and the element-wise operation will be performed as usual. The concept of broadcasting is the key to understanding how this operation will be carried out. We can check the broadcast transformation using the broadcast_to() numpy function. np. broadcast_to(t2. numpy(), t1. shape)&gt;&gt; array([[2. , 4. ],    [2. , 4. ]], dtype=float32)t1 + t2&gt;&gt; tensor([[3. , 5. ],    [3. , 5. ]])When do we actually use broadcasting? We often need to use broadcasting when we are preprocessing and especially during normalization routines.  Element-Wise Operation Applies to Comparision and Functions : Comparison operations are also element-wise operations. For a given comparison operation between two tensors, a new tensor of the same shape is returned with each element containing torch. bool value of True or False. It is also fine to assume that the function is applied to each element of the tensor.  there are other ways to refer to element-wise operations, such as component-wise or point-wise Argmax and Reduction Operations for Tensors : Now, we will focus in on the frequently used argmax() function, and we‚Äôll see how to access the data inside our tensors.  Tensor Reduction Operation : A reduction operation on a tensor is an operation that reduces the number of elements contained within the tensor. Reduction operations allow us to perform operations on element within a single tensor. Let‚Äôs look at an example. Suppose we have the following rank-2 tensor: t = torch. tensor([[0,1,0],[2,0,2],[0,3,0]],dtype=torch. float32)t. sum()&gt;&gt; tensor(8. )t. numel()&gt;&gt; 9t. sum(). numel()&gt;&gt; 1The sum of our tensor‚Äôs scalar components is calculated using the sum() tensor method. The result of this call is a scalar-valued tensor . Since the number of elements have been reduced by the operation, we can conclude that the sum() method is a reduction operation. Other common reduction functions include t. sum(), t. prod(), t. mean() or t. std(). All of these tensor methods reduce the tensor to a single element scalar valued tensor by operating on all the tensor‚Äôs elements. Reduction operations in general allow us to compute aggregate values across data structures. But do reduction operations always reduce to a tensor with a single element? The answer is no. In fact, we often reduce specific axes at a time. This process is important.  References : deeplizard "
    }, {
    "id": 8,
    "url": "https://sally20921.github.io/_posts/2021-09-14-extrinsic.html",
    "title": "Dissecting the Camera Matrix (Part 2)",
    "body": " Overview of the Camera Calibration Parameters The Extrinsic Camera Matrix : The extrinsic matrix takes the form of a rigid transformation matrix: a $3 \times 3$ rotation matrix in the left-block, and $3 \times 1$ translation column-vector in the right. $$ \begin{bmatrix}\begin{array}{ccc|c} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_1  r_{21} &amp; r_{22} &amp; r_{23} &amp; t_2  r_{31} &amp; r_{32} &amp; r_{33} &amp; t_3\end{array}\end{bmatrix} $$ It is common to see a version of this matrix with extra row of $(0,0,0,1)$ added to the bottom. This makes the matrix square, which allows us to further decompose this matrix into a rotation followed by translation: $$ \begin{bmatrix}\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; t_1 0 &amp; 1 &amp; 0 &amp; t_2 0 &amp; 0 &amp; 0 &amp; t_3 \hline0 &amp; 0 &amp; 0 &amp; 1\end{array}\end{bmatrix} \times \begin{bmatrix}\begin{array}{ccc|c}r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \hline0 &amp; 0 &amp; 0 &amp; 1\end{array}\end{bmatrix} $$ The matrix describes how to transform points in world coordinates to camera coordinates. The important thing to remember about the extrinsic matrix is that it describes how the world is transformed relative to the camera . This if often counter-intuitive, because we usually want to specify how the camera is transformed relative to the world .  Building the Extrinsic Matrix from Camera Pose : Like I said before, it is often more natural to specify the camera‚Äôs pose directly rather than specifying how world points should transform to camera coordinates . Luckily, building an extrinsic camera matrix this way is easy: just build a rigid transformation matrix that describes the camera‚Äôs pose and then take its inverse . $$ \begin{bmatrix}\begin{array}{c|c}R &amp; t 0 &amp; 1 \end{array}\end{bmatrix} = \begin{bmatrix}\begin{array}{c|c}R_c &amp; C 0 &amp; 1 \end{array}\end{bmatrix}^{-1} $$ Let $C$ be a column vector describing the location of the camera-center in world coordinates, and let $R_c$ be the rotation matrix describing the camera‚Äôs orientation with respect to the world coordinate axes. Then extrinsic matrix is obtained by inverting the camera‚Äôs pose matrix.  Algebraically a rotation matrix in $n$-dimensions is a $n \times n$ special orthogonal matrix, i. e. an orthogonal matrix whose determinant is 1.  We can define matrix $R$ that rotates in the $xy$-Cartesian plane counterclock-wise through an angle $\theta$ about the origin of the Cartesian system as follows:\$\$R = \begin{bmatrix}\cos\theta &amp; -\sin\theta \\\sin\theta &amp; \cos\theta\end{bmatrix}\$\$ The set of all rotation matrices form a group, known as the special orthogonal group. The inverse of a rotation matrix is its transpose, which is also a rotation matrix. \$\$\displaylines{R^T = R^{-1} \\det(R) = 1}\$\$ the extrinsic matrix is obtained by inverting the camera's pose matrix We here use the fact that the inverse of a rotation matrix is its transpose, and inverting a translation matrix simply negates the translation vector. Relationship between the extrinsic matrix parameters and the camera‚Äôs pose is straightforward: $$\displaylines{R = R^T_c t = -RC}$$ References :  ksimek blog prateekvjoshi blog "
    }, {
    "id": 9,
    "url": "https://sally20921.github.io/_posts/2021-09-14-gan.html",
    "title": "All About Training GAN",
    "body": " 1.  Generative Adversarial Networks : Ultimately, if everything goes well, the generator learns the true distribution of the training data and becomes really good at generating fake images. The discriminator should not be able to distinguish between real and fake images. Another way to look at the GAN setup is that the discriminator is trying to guide the generator by telling what real images look like. The two networks try to achieve what is called the Nash Equilibrium with respect to each other.  2.  Training GANs : GAN networks are a dynamic system where the optimization process is seeking not a minimum, but a equilibrium between two forces. There are no good objective metrics for evaluating whether a GAN is performing well during training, e. g. reviewing the loss is not sufficient. Instead the best approach is to visually inspect the generated examples and use subjective evaluation. Other quantitative measures, such as Inception Score (IS) or Frechet Inception Distance (FID) rely on pretrained models with a specific set of object classes. They lack an upper bound (which means hypothetically the highest possible score is infinity).  2. 1 Look at the Loss : In a discriminative model,the loss measures the accuracy of the prediction and we use it to monitor the progress of training. However, the loss in GAN measures how well we are doing compared with our opponent. Often, the generator cost increases but the image quality is actually improving. If you see the discriminator loss rapidly approaching, there is probably no chance of recovery and it is time to change something.  2. 1 Look at the Gradients : Monitor the gradients along with the losses in the networks. These can give you a good idea about the progress of training and can even help in debugging if things are not really working well. Ideally, the generator should receive large gradients early in the training because it needs to learn how to generate real-looking data. The discriminator on the other hand does not always get large gradients early on, because it can easily distinguish real and fake images. If the gradients at the layer of generator are too small, learning might be slow or not happening at all. The generator should get large gradients early on and the discriminator getting consistently high gradients at the top layer once the generator has been trained enough.  3. Detecting GAN Failure Modes : The reason why GANs are difficult to train is that both generator and the discriminator are trained simultaneously in a zero-sum game. This means that improvements to one model come at the expense of the other model. The goal of training two models involves finding a point of equilibrium between the two competing concerns. It also means that everytime the parameters of one model are updated the nature of the optimization problem that is being solved is updated as well. The technical challenge of training two competing neural networks at the same time is that they can fail to converge.  Convergence Failure The fact that GANs are composed by two networks, and each of them has its loss function leads to GANs unstability. In GAN architecture, the discriminator tries to minimize a cross-entropy while the generator tries to maximize it. When discriminator confidence is high and the discriminator starts to reject the samples that are produced by the generator, generator's gradient vanishes. This scenario happens when the generator score reaches near zero and the discriminator score reaches near one. The discriminator is overpowering the generator. If the score does not recover from these values for many iterations, it is better to stop training.  Mode Collapse  Mode collapse is when the GAN produces a small variety of images with many duplicates. This happens when the generator is unable to learn a rich feature representation because it learns to associate similar outputs to multiple different inputs. The most promising way to check for mode collapse is to inspect the generated images. If there is little diversity in the output and some of them are almost identical, there is likely mode collapse. If you observe this happening, you should try to increase the ability of the generator to create more diverse outputs or impair the discriminator by randomly giving false labels to real images. Another type of behavior you should look out for is when the generator oscillates between generating specific examples in the domain. They progress from generating one kind of sample to generating another kind of sample without eventually reaching equilibrium.  Diminisheed Gradient  This situation happens when the discriminator gets too successful that the generator gradient vanishes and learns nothing. Lessons I Learned : Use a batch size smaller than or equal to 64. In my experience, using bigger batch sizes often hurt the performance. I suspect it fuels the problem of discriminator getting too good at discriminating the real and fake images, since large batch size means providing a lot of examples to train on.  Add noise to both real and synthetic data.  It is well known that making the training of discriminator more difficult is beneficial for the overall stability. Adding noise increases the complexity of the discriminator training and stabilizes the data distribution of the two competing networks.  Use Label Smoothing If the label for real images is set to 1, change it to a lower value like 0. 9. This solution discourages the discriminator from being overconfident.  Different learning rates for the generator and discriminator a. k. a. Two Time-Scale Update Rule In my experience, choosing a higher learning rate for the discriminator(i. e. 0. 0004) and a lower one(i. e. 0. 0001) for the generator works well in practice. I guess the reason is that the generator has to make small steps to fool the discriminator so it does not choose fast but not precise solutions to win the adversarial game.  Use some kind of normalization method For me, applying Spectral Normalization, a particular kind of normalization applied on the convolutional kernels, greatly helped the stability of training. I learned that hyperparameter tuning takes a lot of time and patience especially for training GANs. "
    }, {
    "id": 10,
    "url": "https://sally20921.github.io/_posts/2021-09-16-geometry.html",
    "title": "Geometry",
    "body": " Coordinate Systems : Introducing Coordinate Systems : Coordinate systems play an essential role in the graphics pipeline. They are not complicated; However, learning a few things about them will make it easier to understand matrices. I mentioned that points and vectors (as used in computer vision/graphics) are represented with 3 real numbers. But what do these numbers mean? Each number represents a signed distance from the origin of a line to the position of the point on that line. Consider drawing a line and putting a mark in the middle. We will call this mark origin. This mark becomes our point of reference: the position from which we will measure the distance to any other points. If a point lies to the right side of the origin, we take the signed distance to be greater than zero. On the other hand, if it is on the left side of the origin, the values will be negative. Now that we have a line and an origin, we add some additional marks at a regular interval (unit length) on each side of the origin, effectively turning our line into a ruler. With the ruler established, we can simply use it to measure the coordinate of a point from the origin (coordinate is another way of saying the signed distance from the origin to the point). In mathematics, the ruler defines what we call axis . We have just learned to define the coordinate of a point along an axis.  Dimensions and Cartesian Coordinate Systems : By placing two axes called $x$-axis and $y$-axis, we have defined a two dimensional space called a plane . These two axes are said to define a coordinate system.  If these two rulers are perpendicular to each other, they define what we call a Cartesian coordinate system.  We now know how to make a two-dimensional Cartesian coordinate system and define the coordinates of a 2D point in that coordinate system. Note that the coordinates of points defined in a coordinate system are unique &lt;/span&gt;. The same point cannot be represented by two different sets of coordinates in one system. We are free to choose any coordinate system that we please. In fact, we can choose to define infinitely many coordinate systems in a plane. Let‚Äôs assume we drew two Cartesian coordinate system like the figure above. On this paper, we place one point.  The coordinates of that point will be different depending on which of the two coordinate system we consider.  If you know the coordinates of $P$ in coordinate system $A$, what do you need to do to find the coordinate of the same point in another coordinate system $B$? This represents an extremely important operation in computer vision, and we will soon learn why and how to find the map which translates the coordinates of a point from one coordinate system to another. Another common operation is to move the point in the coordinate system $A$ to another location in the same coordinate system. This is called a translation and is certainly one of the basic operations you can do on points. Note that all sorts of other linear operators can be applied to point coordinates. A multiplication of a real number to the coordinate of point produces scale . A scale moves $P$ along the line that is going through the point and the origin. That is because when we are transforming a point we are actually transforming the vector going from origin to the point.  The Third Dimension : The 3D coordinate system is a simple extension of the 2D case. We will be adding a third axis orthogonal to both the $x$- and $y$-axis called the $z$-axis (representative of depth). In geometry, 3D coordinate system defines what is more formally known as Euclidean Space . In linear algebra, the three axes from what we call the basis of that coordinate system. A basis is a set of linearly independent vectors that, in a linear combination, can represent every vector (or point) in a given vector space (the coordinate system).  Vectors from a set are said to be linearly independent if and only if none of the vectors in the set can be written as a linear combination of other vectors in that set. Change of basis, or change of coordinate system, is a common operation in mathematics and computer vision pipeline.  Left-Handed vs Right-Handed Coordinate Systems : Unfortunately, due to various conventions concerning handedness, coordinate systems are not that simple. The problem can be illustrated in the following figure: when the up and forward vectors are oriented in the same way, an appropriate right vector can either point to the left or to the right. To differentiate the two conventions, we call the first coordinate system the left-handed coordinate system, and the other, the right-handed coordinate system.  Remember that the middle finger always represent the right vector when checking the coordinate handedness.  The handedness of the coordinate system also plays a role in the orientation of normals computed from the edges of polygonal faces. If the orientation is right-handed, then polygons whose vertices were specified in counterclockwise order will be front-facing. This will be explained in the part on rendering polygon objects.  The Right, Up and Forward Vectors : The Cartesian coordinate system is only defined by three perpendicular vectors of unit length. As far as the mathematical notation is concerned, this coordinate system does not convey anything about what these three axes actually mean. The developer is the one that decides how these axes should be interpreted. It is thus very important to make a clear distinction between the handedness of the coordinate system and the conventions used to label the corresponding axes. The choice of coordinate system handedness also plays a critical role when it comes to rotation and the cross product of two vectors. It‚Äôs actually easy enough (but painful) to go from one coordinate system to another. All that is needed is to scale the point coordinates and the camera-to-world matrix by $(1,1,-1)$.  The World Coordinate System : In most 3D applications, each different type of coordinate system is defined with respect to a master coordinate system called the world coordinate system. It defines the origin and the main $x$,$y$,$z$-axes from which all other coordinate systems are defined.  Math Operations on Points and Vectors : I have explained the concept of (Cartesian) coordinate system. Now we can look at some of the most common operations which can be performed on points and vectors.  Vector Length : The vector itself indicates not only the direction of point $B$ from $A$ but also can be used to find out the distance between $A$ and $B$. This is given by the length of a vector which can easily be computed with the following formula: $$\lVert V \rVert = \sqrt{x^2 + y^2 + z^2}$$ The vector's length is sometimes also called norm or magnitude.  Note that the axes of the three-dimensional Cartesian coordinate systems are unit vectors.  Normalizing a Vector : A normalized vector is a vector whose length is 1. Such a vector is also called a unit vector (it is a vector which has unit length). Normalizing a vector is very simple. We first compute the length of the vector and divide each one of the vector coordinates with this length. $$\hat{V} = \frac{V}{\lVert V \rVert}$$ In mathematics, you will also find the term norm to define a function that assigns a length or size (or distance) to a vector. The function we have just described is called the Euclidean norm.  Dot Product : The dot product or scalar product requires two vectors $A$ and $B$ and can be seen as the projection of one vector onto the other. The result of the dot product is a real number. A dot product between two vectors is denoted with the dot sign: $A \cdot B$ (it can also sometimes be written as $&lt;A,B&gt;$). The dot product consists of multiplying each element of the $A$ vector with its counterpart from vector $B$ and taking the sum of each product. In the case of 3D vectors (they have three coefficients of elements which are $x$, $y$ and $z$), it consists of the following operation: $$A \cdot B = A. x * B. x + A. y * B. y + A. z * B. z$$ Note that this is quite similar to the way we compute the length of a vector. If we take the square root of the dot product between two vectors ($\sqrt{A \cdot B}$) that are equal ($A=B$), then what we get is the length of the vector. We can write: $${\lVert V \rVert}^2 = V \cdot V$$ The dot product between two vectors is an extremely important and common operation in any 3D application because the result of this operation relates to the cosine of the angle between the two vectors. In this example vector $A$ is projected in the direction of vector $B$.  If $B$ is a unit vector then the product $A \cdot B$ gives $\lVert A \rVert \cos (\theta)$, the magnitude of the projection of $A$ in the direction of $B$, with a minus sign if the direction is opposite. This is called the scalar projection of $A$ onto $B$.  When neither $A$ nor $B$ is a unit vector, we can write that $A \cdot B / \lVert B \rVert$, since $B$ as a unit vector is $B/\lVert B rVert$.  In mathematics, $ {\cos}^{-1}$ is the inverse of the cosine function. When the two vectors are normalized ($A \cdot B / \lVert A \rVert \lVert B \rVert$), taking the arc cosine of the dot product gives you the angle $\theta$ between two vectors: $\theta = {\cos}^{-1}(A \cdot B / \lVert A \rVert \lVert B \rVert)$ or $\theta = {\cos}^{-1}(\hat{A} \cdot \hat{B})$.  The dot product is a very important operation in 3D. It can be used for many things. As a test of orthogonality. When two vectors $A$,$B$ are perpendicular to each other, the result of the dot product between these two vectors is $0$. It is also used intensively to find out the angle between two vectors or compute the angle between a vector and the axis of a coordinate system.  Cross Product : The cross product is also an operation on two vectors. The difference between cross product and dot product is that the dot product returns a number, whereas the cross product returns a vector. The particularity of this operation is that the vector resulting from the cross product is perpendicular to the other two.  The cross product operation is written using the following syntax:\$\$C = A \times B\$\$To compute the cross product we will need to implement the following formula:\$\$C_x = A_Y * B_Z - A_Z * B_YC_Y = A_Z * B_X - A_X * B_ZC_Z = A_X * B_Y - A_Y * B_X\$\$The result of this cross product is another vector which is  orthogonal to the other two. The two vectors $A$ and $B$ define a plane and the resulting vector $C$ is perpendicular to that plane. $A$ and $B$ don't have to be perpendicular to each other, but when they are, the resulting $A$, $B$ and $C$ vectors form a Cartesian coordinate system (assuming the vectors have unit length). If you need a mnemonic way of remembering this formula, we like to use the technique that consists of asking ourselves the question  why z? . $y$ and $z$ being the coordinates of vector $A$ and $B$ used to compute the $x$ coordinates of the resulting vector $C$. It is important to note that the order of the vectors involved in the cross product has an effect on the resulting vector $C$. You can see that $A \times B$ doesn't give you the same result as $B \times A$.  How Does Matrix Work : Point-Matrix Multiplication : Two matrices need to have compatible sizes in order to be multiplied with each other. For instance, the matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. Point can be written in a matrix form $P = [xyz]$. There is two things we need to remember. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point. The second thing we need to remember is that a $m \times p$ matrix multiplied by $p \times n$ matrix, gives a $m \times n$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point. The Identity Matrix : The identity matrix or unit matrix is a square matrix whose coefficients are all 0 except the coefficients along the diagonal which are set to $1$. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}\$\$The result of $P$ multiplied by the identity matrix is $P$.  The Scaling Matrix : When these coefficients of the identity matrix are different than 1 (whether smaller or bigger than 1), then they act as a multiplier on the point's coordinates. In other words, the points coordinates are scaled up or down by some amount. \$\$\begin{bmatrix}S_X &amp; 0 &amp; 0 \\0 &amp; S_Y &amp; 0 \\0 &amp; 0 &amp; S_Z\end{bmatrix}\$\$Note that if either one of the scaling coefficiuent in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped (it will be mirrored to the other side of the matrix). The Rotation Matrix : We are now talking about building a matrix that will rotate a point or a vector around one axis of the cartesian coordinate system. And for doing so, we will need to use trigonometric functions.  Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of a rotation (we could do this with a translation but using a rotation will be easier). $P_T$ coordinates are $(0,1,0)$. As you can see, this can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ into $P_T$. \$\$\begin{aligned}P_T. x = P. x * R_{00} + P. y * R_{10} + P. z * R_{20} \\P_T. y = P. x * R_{01} + P. y * R_{11} + P. z * R_{21} \\P_T. z = P. x &amp; R_{02} + P. y * R_{12} + P. z * R_{22}\end{aligned}\$\$As we said, we don't care so much about $P_T. z$ for now which represents the $z$-coordinate of $P_T$. Let's concentrate instead on $P_T. x$ and $P_T. y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. It means that $R_{00}$ has to be equal to $0$. Considering that $P. y$ and $P. z$ are 0 anyway we don't care much about the values that $R_{10}$ and $R_{20}$ may be for now. What do we know about $P$? We know that $P. x$ is 1 and that all the other coordinates of $P$ are $0$. Which necessarily means that $R_{01}$ has to be 1. Let's recap. We know that $R_{00}$ is 0 and $R_{01}$ is 1. Let's write it down and see what $R$ looks like: (compare this matrix with the identity matrix)\$\$R_z = \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\$\$If you use this matrix to transform $P=(1,0,0)$ you will get $P_T = (0,1,0)$. How Does Matrix Work? : Point-Matrix Multiplication : We will start to put all the things we have learned on points, vectors, matrices and coordinate systems together. We mentioned that two matrices needed to have compatible sizes in order to be multiplied with each other. The matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. A point or a vector is a sequence of three numbers and for this reason they too can be written as a $1 \times 3$ matrix, a matrix that has one row and three columns. Point written in a matrix form $P=[xyz]$. The trick here is that, if we can write points and vectors as $1 \times 3$ matrices, we can multiply them by other matrices. Remember that the matrix $m \times p$ can be multiplied by the matrix $p \times n$ to give the matrix $m \times n$. So this implies that we can multiply something of the form $3 \times n$ where n can be any number greater than 1. There is two things we need to remember now to make sense of what we are going to explain. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point. If it wasn't the case, we wouldn't be using matrices as a convenient way of transforming points. The second thing we need to remember is that a $m \times p$ matrix multiplied by a $p \times n$ matrix, gives a $m \times n$ matrix. If we look at our point as a $1 \times 3$ matrix, we need the result of the multiplication to be another point, that is a $1 \times 3$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point.  The Identity Matrix : The identity matrix or unit matrix is a square matrix whose coefficients are all $0$ except the coefficients along the diagonal which are set to $1$. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}\$\$The result of $P$ multiplied by the identity matrix is $P$. The Scaling Matrix : If you look at the code of the point-matrix multiplication, you can see that the coordinates of the point $P$ are respectively multiplied by the coefficients $R_{00}$ for $x$, $R_{11}$ for $y$, and $R_{22}$ for $z$. When these coefficients are set to $1$ (and all the other coefficients are set to $0$), we get the identity matrix. However, when these coefficients (along the diagonal) are different than $1$ (whether smaller or bigger than $1$), then they act as a multiplier on the point's coordinates (in other words, the points coordinates are scaled up or down by some amount). If you remember what we have said about coordinate systems, multiplying the coordinates ofa point by some real numbers result in scaling the point's coordinates. The scaling matrix can therefore be written as:\$\$\begin{bmatrix}S_X &amp; 0 &amp; 0 \\0 &amp; S_Y &amp; 0 \\0 &amp; 0 &amp; S_Z\end{bmatrix}\$\$Note that if either one of the scaling coefficients in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped (it will be mirrored to the other side of the axis).  The Rotation Matrix : What we will be talking about now is about building a matrix that will rotate a point or a vector around one axis of the Cartesian coordinate system. And for doing so, we will need to use trigonometric functions. Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Let's ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of rotation (we could do this with a translation but using a rotation will make our demonstration easier). $P_T$ coordinates are $(0,1,0)$. This can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ to $P_T$. Considering what we know about matrix multiplication let's see how we can re-write a point-matrix multiplication and isolate the computation of each of the transformed coordinates. \$\$\begin{aligned}P_T. x = P. x * R_{00} + P. y * R_{10} + P. z * R_{20} \\P_T. y = P. x * R_{01} + P. y * R_{11} + P. z * R_{21} \\P_T. z = P. x * R_{02} + P. y * R_{12} + P. z * R_{22}\end{aligned} \$\$As we said, we don't care so much about $P_T. z$ for now which represents the $z$-coordinate of $P_T$. Let's concentratte instead on $P_T. x$ and $P_T. y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. If we look at the first line of the code we wrote to compute $P_T$, it means that $R_{00}$ has to be equal to 0. Considering that $P. y$ and $P. z$ are $0$ anyway we don't care so much about the values that $R_{10}$ and $R_{20}$ may have for now. From P to $P_T$, the $y$-coordinate goes from $0$ to $1$. Let's have a look at the second line of code. What do we know about $P$? We know that $P. x$ is $1$ and that all the other coordinates of $P$ are $0$, which necessarily means that $R_{01}$ has to be $1$. Let's recap. We know that $R_{00}$ is $0$ and $R_{01}$ is $1$. Let's write it down and see what $R$ looks like (compare this matrix with the identity matrix):\$\$R_z = \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \end{bmatrix}\$\$Don't worry for now if you don't understand why the coefficients have the value they have. That will be explained soon. All you want to see, is that if you use this matrix to transform $P=(1,0,0)$ you will get $P_T=(0,1,0)$. \$\$\begin{aligned}P_T. x = P. x * 0 + P. y * 1 + P. z * 0 = 0 \\P_T. y = P. x * 1 + P. y * 0 + P. z * 0 = 1 \\P_T. z = P. x * 0 + P. y * 0 + P. z * 1 = 0\end{aligned}\$\$This is where our knowledge of trigonometric functions will become handy. If we look at a point on the unit circle we know that its $x$ and $y$ coordinates can be computed using the sine and cosine of the angle $\theta$. \$\$\begin{aligned}x = cos(\theta) = 0 \\y = sin(\theta) = 1 \\\theta = \frac{\pi}{2}\end{aligned}\$\$When $\theta=0$, $x=1$ and $y=0$. When $\theta = 90$ degrees (or $\frac{\pi}{2}$), $x=0$ and $y=1$. That is interesting because you will notice that $x=0$ and $y=1$ are values of $R_{00}/R_{11}$ and $R_{01}/R_{10}$ respectively. So we could re-write the matrix $R$ as:\$\$R_z(\theta) = \begin{bmatrix}cos(\theta) &amp; sin(\theta) &amp; 0 \\sin(\theta) &amp; cos(\theta) &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}= \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \end{bmatrix}\$\$ Combining Rotation Matrices : We have learned that multiplying matrices together combines their transformations. Now that we know how to rotate points around individual axis, it is possible to multiply $R_x$, $R_y$, $R_z$ together to create more complex rotations. If for instance you want to rotate a point around the $x$-axis, and then the $y$-axis, you can create two matrices using the matrices $R_x$ and $R_y$ and combine them using matrix multiplication $R_x * R_y$ to create a $R_{xy}$ matrix encoding the two individual rotations. Note that the order of the rotation is important and makes a difference. If you rotate a point around the $x$-axis first and then the $y$-axis second, you will end up with a result which is different from a rotation around the $y$-axis and then around the $x$-axis.  Relation Between Matrices and Cartesian Coordinate System : If you imagine that you have a point $P_x$ with coordinates $(1,0,0)$ and want to rotate this point around the $z$-axis by 10 degrees clockwise, we know that these new coordinates can be found using simple trigonometry.  Orthogonal Matrices : In fact, the type of matrices we ahve described (the rotation matrices) are called in linear algebra, orthogonal matrices. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors. We have mentioned previously that each row from the matrix represents an axis of a Cartesian coordinate system. If the matrix is a rotation matrix or the result of several rotation matrices multiplied with each other, then each row necessarily represents an axis of unit length (because the elements of the rows are constructed from the sine and cosine trigonometric functions which are used to compute the coordinates of points lying on the unit circle). You can see them as a Cartesian coordinate system which is originally aligned with the world coordinate system (the identity matrix's rows represent the axes of the world coordinate system) and rotated around one particular axis or a random axis. Orthogonal matrices have a few interesting properties but maybe the most useful one in computer vision, is that the transpose of an orthogonal matrix is equal to its inverse. Assuming $Q$ is an orthogonal matrix, we can write:\$\$Q^T = Q^{-1}\$\$ which entials that $QQ^T = I$, where $I$ is the identity matrix. Affine Transformations : You will sometimes find the terms affine transformations used in place of matrix transformation. This technical term is actually more accurate to designate the transformations that you get from using the type of matrices we have described so far. In short, an affine transformation, is a transformation that preserves straight lines. The translation, rotation, shearing matrix are all affine transformations as are their combinations. The other type of transformation we will be studying in computer vision are called projective transformations (perspective projection is a projective transformation). As you may have guessed, such transformations do not necessarily preserve parallelism between lines. Not only you have learned how to create rotation matrices but we have also given you a way of visualizing what a matrix is: each row of the matrix represents one axis of a Cartesian coordinate system. The orientation (rotation), size (scale), and position (translation) of this coordinate system represents the transformation that will be applied to the points when they are multiplied by this matrix. The key idea is that points are originally defined in a certain coordinate system. If a point is attached to a local coordinate system $B$ (the matrix) and that we move, rotate, and translate that local coordinate system (i. e. the matrix), the point coordinates will not change in regard to the local coordinate system $B$. The point is somehow constrained to the transformation applied to the local coordinate system $B$. However, the coordinates of that point will change in the coordinate system $A$. Multiplying the point whose coordinates are expressed in regards to $A$ by the matrix $B$ will provide us with the point's new coordinates in the coordinate system $A$. What you need to remember is how to find the formula for the basic rotation matrices. That the order by which you multiply this basic matrices is important. And finally (and that's almost the most important) that a matrix can be seen as a local Cartesian system where each row of the matrix represents one axis of that local coordinate system. Such matrix is called an orientation matrix.  Transforming Points and Vectors : Even though translation seems to be the easiest linear operator that can be applied to point, we haven't mentioned it often in the previous chapter. Because to get the translation working with the theory of matrix multiplication, we need to make a change to the point structure that might confuse you slightly. As we mentioned in the last two chapters, a matrix-matrix multiplication can only work if the two matrices involved have a compatible size. That is if they have the size $m \times p$ and $p \times n$. Let's keep that in mind. Let's start from a $3 \times 3$ identity matrix. We know that a point multiplied by this matrix have its coordinates unchanged. Let's see what changes we need to bring to that matrix to handle translation. Translation on a point is nothing more than adding a number to each of its coordinates (these numbers can be positive or negative). For instance if we want to move the point $(1,1,1)$ to the coordinate $(2,3,4)$ we need to add values $1$,$2$ and $3$ respectively to each of the points' $x$, $y$ and $z$ coordinates. It is very simple. Note that from now on, we will keep looking at points and vectors as matrix of size $1 \times 3$. Let's get back to the code that transforms a point using a matrix. What do we need to get the rotation matrix extended so that it handles translation as well? We would need to be able to have a fourth term to the right that would encode translation. Now remember that we want to come up with a matrix that encodes scale, rotation, and translation. So, somehow we need to get $T_x$, $T_y$, $T_z$ to fit within the code of point-matrix multiplication (and store these three values somewhere in the matrix). Look at the first line for now. Note that to compute $x', we only use the coefficients ofthe matrix first column. If the column had four coefficients instead of three, then $T_x$ would be $M_{30}$. The same reasoning can be done with $T_y$ and $T_z$. However, this is assuming that our matrix now has the size $4 \times 3$ not $3 \times 3$ anymore. This is alright. We said that matrices could have any size. However, we know that matrix multiplication can be valid if their sizes are compatible. We try to multiply a point $1 \times 3$ matrix with a $4 \times 3$ matrix and theory tells us that this is not possible. What shall we do? The solution is simple. We will add one additional column to the point to turn it into a $1 \times 4$ matrix and set the fourth coefficient of this point to $1$. Our point now looks like this $(x,y,z,1)$. In computer vision, it is called a homogeneous point (or a point with homogeneous coordinates). With such a point we can easily encode translation in our matrix. This is the theory. In order to encode translation, scale and rotation in a matrix we need to deal with points that have homogeneous coordinates. But because the fourth value is always $1$ we never really explicitly define it in the code. We only define $x$,$y$,$z$ and assume that there is a fourth value. Our matrix is now a $4 \times 3$ matrix. So you may wonder, how do we go from $4 \times 3$ matrix to our final $4 \times 4$ matrix which is the form that is the most commonly used in computer vision? The fourth columns plays a role in perspective projection and for some other type of transformations that are not very common (such as the shear transformation), but generally it is simply set to $(0,0,0,1)$. What happens though when the coefficients of this column have different values than the default (we said its uncommon but it happens sometimes)? Before we can answer this question, we first need to learn a few things more about homogeneous points.  The Trick About Homogenous Points : Presenting a point as an homogeneous point is necessary to allow point-multiplication by $4 \times 4$ matrices however, in the code, this is only done implicitly, since as we have explained, $w$ is always $1$. But as we mentioned briefly, this fourth column is not always set to $(0,0,0,1)$ particularly when you deal with projection matrices (matrices that can project points to the screen). In these special cases, the result for $w'$ can be different than $1$ (which is intentional) but for this point to be usable as a Cartesian point, we need to normalize $w'$ back to $1$ by dividing it by itself which requires to divide the other coordinates ($x'$,$y'$ and $z'$) by $w'$ as well. As you can see we don't need to declare a $w$ coordinate in the Point's type. We can just compute a value for $w'$ on the fly as we assume implicitly that the point we are transforming is a Cartesian point which you can see as a homogeneous point whose $w$ coordinate is not declared explicitly (because it's always equal to 1). However, if the matrix we are multiplying the point with is a projection matrix for instance, the result of $w'$ might be different than $1$. In this particular caase, we need to normalize all the coordinates of $P'$ to set it back to $1$. Once this is done, we get a point which we can use in our Cartesian coordinate system again. All you need to remember is that generally, you will never have to care about homogeneous coordinates, expect when points are multiplied by a perspective projection matrix. However, you will actually probably not come across this issue if you work on a ray tracer, as this special type of matrix is not used in ray tracing. Transforming Vectors : Vectors somehow are simpler to transform than points. Vectors, as we said in the preamble of this lesson, represent direction whereas points represent position in space. As such vectors do not need to be translated because their position is in fact meaningless. With vectors we are only interested in the direction in which they point and eventually their length which is sometimes an information we need to solve geometric or shading problems. Vectors can be transformed like we transformed point but we can remove the part of the code that is responsible for the translation bit. Now that the matrix has size $4 \times 4$ we need to extend the size of the point by adding an extra coordinate. We can do this by implicitly treating points as homogeneous points but to continue using them in a Cartesian coordinate system (as Cartesian points) we need to be sure that $w$, this fourth coordinate is always set to $1$. Most of the time the matrices we use to transform a point will have their fourth column set to $(0,0,0,1)$ and with these matrices, the value of $w'$ should always be $1$. However, in special cases (projection matrix, shear transform) the value of $w'$ might be different than $1$ in which case you will need to normalize it (we divide $w'$ by itself) which requires to also divide the other transformed coordinates $x'$, $y'$, and $z'$ by $w'$. Matrices are not the only method to encode or store transformations. You can also for instance represent a rotation using a method proposed initially by Euler. The idea is to define a rotation in this casae as a vector and an angle representing a rotation around the vector. While uncommon, both techniques are used to solve problems in computer vision from time to time. Rotations in computer vision are also commonly done using quaternions. Matrices themselves have certain limitations especially when it comes to rotation by an angle greater than $360$ degrees. This can lead to a problem known as the gimbal lock. Matrices are also hard to interpolate which is often needed in rendering to compute the motion blur of objects. For this particular reason, quaternions are generally preferred though they are considered to be generally harder to understand.  Row Major and Column Major Vector : Earlier in this lession, we have explained that vectors (or points) can be written down as $1 \times 3$ matrices (one row, three columns). Note however that we could have also written them down as $3 \times 1$ matrices (three rows, one column). Technically, these two ways of expressing points and vectors as matrices are perfectly valid and choosing one mode or the other is just a matter of convention. In the first example, we have expressed our vector or point in what we call the row-major order: the vector (or point) is written as a row of three numbers. In the second example, we say that points or vectors are written in column-major order: we write the three coordinates of the vector or point vertically, as a column. Remember that we express points and vectors as matrices to multiply them by $3 \times 3$ transformation matrices (for the sake of simplicity we will work with $3 \times 3$ rather than $4 \times 4$ matrices). So what do we do? We move the point or vector to the right side of the multiplication. Note that the result of this operation is a transformed poitn written in the form of a $3 \times 1$ matrix. So we get a point to start with and we finish with a transformed point which is what we want. Problem solved. To summarize, when by convention we decide to express vectors or points in row-major order, we need to put the point on the left side of the multiplication and the $3 \times 3$ on the right inside of the multiplication sign. This is called in mathematics, a left or pre-multiplication. If you decide to write the vectors in column-major order, matrix needs to be on the left side of the multiplication and the vector or point on the right side. This is called a right or post-multiplication. Multiplying a point or a vector by a matrix should give us the same result whether we use row- or column-major order. If you use a 3D application to rotate a point by a certain angle around the $z$-axis, you expect the point to be in certain position after the rotation no matter what internal convention the developer used to represent points and vectors. Multiplying a row-major and column-major point (or vector) by the same matrix clearly wouldn't give us the same result. We would actually need to transpose the $3 \times 3$ matrix used in the column-major multiplication to be sure that $x'$,$y'$, and $z'$ are the same. In conclusion, going from row-major order to column-major order not only involves to swap the point or vector and the matrix in the multiplication but also to transpose the $3 \times 3$ matrix, to guarantee that both conventions give the same result (and vice versa). From these observations, we can see that any series of transformations applied to a point or a vector when a row-major convention is used can be written in sequential order. Imagine for instance that you wnat to translate point $P$ with matrix $T$ then rotate it around the $z$-axis with $R_z$ then around the $y$-axis with $R_y$. You can write:\$\$P' = P * T * R_z * R_y\$\$If you were to use a column-major notation you would need to call the transform in reverse order (which one might find counter-intuitive):\$\$P' = R_y * R_z * T * P\$\$Order of transformation when we use column-major matrices is more similar in mathematics to the way we write function evaluation and composition. Implication in Coding : There is another potentially very important aspect to take into consideration if you need to choose between row-major and column-major, but this has nothing to do really with the conventions themselves and how practical one is over the other. It has more to do with the computer and the way it works. Typically the implementation of a matrix are laid out contiguouosly in memory. In the world of computing, accessing elements from an array in a non-sequential order, is not necessarily a good thing. It actually potentially degrades the cache performance of the CPU. Applied to our matrix problem, accessing the coefficients of the matrix in non-sequential order can therefore be a problem. Assuming the CPU loads the requested float in the cache plus 3 floats next to it, our current implementation might lead to many cache misses, since the coefficients used to compute $x'$, $y'$ and $z'$ are 5 floats apart in the array. On the other hand, if you use a column-major order notation, computing $x'$ for instance requires to access the 1st, 2nd and 3rd element of the matrix. In conclusion, we can say that form a programming point of view, implementing our point- or vector-matrix multiplication using a column-major order convention might be better, performance wise, than the version using the row-major order convention.  Matrix Operations : Transpose : The transpose of a matrix $M$ is another matrix which we write using the following convention: $M^T$. We can describe the process of transposing a matrix in different ways. It can be seen as: reflecting $M$ over its main diagonal to obtain $M^T$, writing the rows of $M$ as the columns of $M^T$ or reciprocally, writing the columns of $M$ as the rows of $M^T$. The idea is to swap the rows and columns and since the operation can't be done in place we need to assign the result to a new matrix which is returned by the function. Transposing matrices can be useful when you want to convert matrices from a 3D application using row-major matrices to another using a column-major convention (and vice versa). Inverse : If the multiplying point $A$ by the matrix $M$ gives point $B$, multiplying a point $B$ the inverse of the matrix $M$ gives point $A$. In mathematics, a matrix inversion is usually written using the following notation:\$\$M^{-1}\$\$From this observation, we can write that:\$\$MM^{-1} = I\$\$where $I$ is the identity matrix. Multiplying a matrix by its inverse gives the identity matrix. We have mentioned the case of the orthogonal matrix which inverse can easily be obtained from computing its transpose. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors. Matrix inversion is an important process in 3D. We know that we can use point- or vector-matrix multiplication to convert points and vectors but it is sometimes useful to be able to move the transformed points or vectors back into the coordinate system in which they were originally defined into. It is often necessary for instance, to transform the ray direction and origin in object space to test for a primitive-ray intersection. If there is an intersection resulting hit point is in object space and needs to be converted back into world space to be usuable. Spherical Coordinates and Trigonometric Functions : Besides points, vectors, normals and matrices the last useful technique from linear algebra we will need to render images is to express vectors in terms of spherical coordinates. We could certainly render images without using them, but you will see that using them simplifies many problems especially when it comes to shading. This chapter is also a good opportunity to review trigonometric functions. Trigonometric Functions : Rendering a computer generated images is almost entirely a geometric problem so not understanding or using trigonometry for creating such images (and the phythagorean theorem) would be hard. Let's start to review the sine and cosine function as well as the way angles can be computed from 2D coordinates. Usually these functions are defined in regards to the unit circle (a circle of radius 1). When we draw a point $P$ on this unit circle, the $x$-coordinate of the point can be computed using the cosine of the angle subtended by the $x$-axis and a line that goes from the origin of the coordinate system to $P$. This angle is usually called $\theta$. Similarly, the sine of this angle gives the $y$-coordinate of the point $P$. Note that the angle $\theta$ is defined in radians. It will be easier to define the angles in degrees, but we will need to convert them internally to radians to use them in the C++ trigonometric functions $\theta_{radians} = \frac{\pi}{180} \theta_{degrees}$. Remember that a complete turn around the unit circle represents 360 degrees of $2\pi$. It is also important to remember that the cosine, sine and tangent functions are defined from a simple relationship between the edges of a right triangle (right-angle triangle). The tangent formula is interesting because to come back to our example using the unit circle, you can see that it can be computed using the ratio of $y$ over $x$. Another very useful function in computer vision is the arctangent which is the tangent inverse function. In other words, if you feed the arctangent function with the result of the tangent function you get $\theta$. In programming you can use the `atan` function but this function doesn't take the sign of the parameters $x$ and $y$ into account. To fix the issue, you need to use the C/C++ function `atan2` instead which takes into account the sign of the point's coordinates in the computation of the angle. Similarly to `atan2`, you can compute the inverse function of sine and cosine using `asin` and `acos`. Let's summarize all the functions we have talked about so far. \$\$\begin{aligned}\theta = \acos(P_x)\theta = \asin(P_y)\theta = \atan(P_y, P_x)\end{aligned}\$\$The interesting thing to note is that the angle returned by the `atan2` function is positive for counter-clockwise angles (upper half-plane, $y&gt;0$) and negative for clockwise angles (lower half-plane, $y&lt;0$). It produces results in the range $[-\pi, \pi]$.  Representing Vectors with Spherical Coordinates : So far we have learned hyow to represent vectors (as in directions) using Cartesian coordinates (with three values, one for each axis). It is also possible though to represent the same vectors with only two values. One to represent the angle between the vector and the vertical axis and one to represent the angle between the vector projected onto the horizontal plane and the right vector from the Cartesian coordinate system. The vertical angle is always called $\theta$ and the horizontal angle is always called $\phi$. No matter what you do and what you see in textbooks, we advise you to follow these rules which is about the only convention unanimously followed by the computer vision community. These angles should be expressed in radians. Note that $\theta$ lies within the range $[0:\pi]$ while $\phi$ varies in the range $[0: 2\pi]$. As such $\theta$ and $\phi$ can also be seen as coordinates and are called spherical coordinates. $V_r$, $V_u$ and $V_f$ correspond to the Cartesian coordinates of the vector in the Cartesian coordinate systems defined by the right, up and forward axes. Note that we haven't used the names $x$, $y$, $z$ for the axis for a reason we will explain soon. Also, we have always represented a normalized vector (unit length) but any vector of arbitrary length can be represented using spherical coordinates. The formal definition of spherical coordinates includes an additional term (usually denoted $r$ for radial distance) to represent the length of the vector combined with $\theta$ and $\phi$ which can also be called the polar and aximuth angles. Spherical coordinates are just another way of encoding vectors. They make this representation compact as only two numbers are used instead of three (if you don't care about the length of the vector) with the Cartesian coordinates (it can save memory in your program) and they will become most useful when we will talk about shading. The question now is how we convert a vector represented in Cartesian coordinates to spherical coordinates.  Conventions Again: $Z$ is Up! : The convention when it comes to represent vectors in mathematics and physics is to name the up vector as the $z$-axis and the right and forward vector respectively the $x$- and $y$-axis. And to make things easier, the convention is also to use a left-hand coordinate system. Having $z$-axis representing the up vector, is something we have already briefly mentioned. As you can see, this convention is different from the one we normally use (where the up axis is the $y$-axis) but unfortunately this notation is the norm and we will have to stick to it.  Creating an Orientation Matrix or Local Coordinate System : In this chapter, we will use what we have learned so far about coordinate systems and what they represent to build a local coordinate system (or frame) from a vector which can also be a normal. This technique is often used in the rendering pipeline as a way of converting point and vectors which are defined in one coordinate system to another. The idea is to let the normal at that point to become one of the axis of that local coordinate system (often aligned with the up vector, and let the tangent and bi-tangent of that point to become )Often a coordinate system is helpful because it can be easier to manipulate the coordinates of a vector rather than manipulating its magnitude and direction directly. When we express a vector in a coordinate system, we identify a vector with a list of numbers, called coordinates or components, that specify the geometry of the vector in terms of the coordinate system. We assume that you are familiar with the standard $(x,y)$ Cartesian coordinate system in the plane. Each point $p$ in the plane is identified with its $x$ and $y$ components: $p=(p_1,p_2)$. To determine the coordinates of a vector $a$ in the plane, the first step is to translate the vector so that its tail is at the origin of the coordinate system. Then, the head of the vector will be at some point $(a_1, a_2)$ in the plane. We call $(a_1, a_2)$ the coordinates or the components of the vector $a$. We often write $a \in \mahthbb{R}^2$ to denote that it can be described by two real coordinates.  Vectors in Three-Dimensional Space : If you switched the locations of the positive $x$-axis and positive $y$-axis, then you would end up having a left-handed coordinate system. With these axes any point $p$ in space can be assigned three coordinates $p=(p_1,p_2,p_3)$. Just as in two-dimensions, we assign of a vector $a$ by translating its tail to the origin and finding the coordinates of the point at its head. In this way, we can write the vector as $a=(a_1,a_2,a_3)$. We often write $a \in \mathbb{R}^3$ to denote that it can be described by three real coordinates. A representation of a vector $a=(a_1,a_2,a_3)$ in the three-dimensional Cartesian coordinate system. The vector $a$ is drawn as a green arrow with tail fixed at the origin. You can drag the head of the green arrow with tail fixed at the origin. Just as in two dimensions, we can also denote three-dimensional vectors in terms of the standard unit vectors, $i$, $j$, and $k$. These vectors are the unit vectors in the positive $x$, $y$, and $z$ direction, respectively. We can express any three-dimensional vector as a sum of scalar multiples of these unit vectors $a=(a_1,a_2,a_3) = a_1 i + a_2 j + a_3 k$. We can easily visualize two or three dimensions by drawing pictures of a plane or space. Going to higher dimension is easy with lists of numbers, though of course high-dimensional vectors are not easy to visualize. For many of us, this metaphor may hamper our efforts to delve into higher dimensions, as we are restrained by our experience of just three spatial dimensions in the world around us. It may be easier to think of a high dimensional vector as simply describing quantities of distinct objects. At first, it may seem that going beyond three dimensions is an exercise in pointless mathematical abstraction. to describe even the simplest objects, we will typically need more than three dimensions. It is challenging to develop mathematical models that cna realistically describe a physical system and yet keep the number of dimensions from becoming incredibly large. However, even if the center of a rigid object is specified, the object could also rotate. In fact, it can rotate in three different directions, such as the roll, pitch and yaw of an airplane. Consequently, we need six dimensions to specify the position of a rigid object: three to specify the location of the center of the object, and three to specify the direction in which the object is pointing.  The Dot Product : The dot product between two vectors is based on the projection of one vector onto another. Let's imagine we have two vectors $a$ and $b$, and we want to calculate how much of $a$ is pointing in the same direction as the vector $b$. We want a quantity that would be positive if the two vectors are pointing in similar directions, zero if they are perpendicular, and negative if the two vectors are pointing in nearly opposite directions. We will define the dot product between the vectors to capture these quantities. The answer to this question should not depend on the magnitude of $b$, only its direction. To sidestep any confusion caused by the magnitude of $b$, let's scale the vector so that it has length one. In other words, let's replace $b$ with the unit vector that points in the same direction as $b$. We'll call this vector $u$, which is defined by:\$\$y = \frac{b}{lVert b \rVert}\$\$The dot product of $a$ with unit vector $u$, denoted $a \cdot u$ is defined to be the projection of $a$ in the direction of $u$, or the amount that $a$ is pointing in the same direction as unit vector $u$. Let's assume for a moment that $a$ and $u$ are pointing in similar directions. Then, you can imagine $a \cdot y$ as the length of the shadow of $a$ onto $u$ if their tails were together and the sun was shining from a direction perpendicular to $u$. \$\$a \cdot y = \lVert a \rVert \cos \theta\$\$If $a$ and $u$ were perpendicular, there would be no shadow. That corresponds to the case when $\cos\theta = \cos \frac{\pi}{2} = 0$ and $a \cdot u = 0$. If the angle $\theta$ between $a$ and $u$ were larger than $\frac{\pi}{2}$, then the shadow wouldn't hit $u$. Since in this case $\cos\theta &lt; 0$, the dot product $a \cdot u$ is also negative. But we need to get back to the dot product $a \cdot b$, where $b$ may have a magnitude different than one. This dot product $a \cdot b$ should depend on the magnitude of both vectors $\lVert a \rVert$ and $\lVert b \rVert$, and be symmetric in those vectors. Hence, we don't want to define $a \cdot b$ to be exactly the projection of $a$ on $b$; we want it to reduce to this projection for the case when $b$ is a unit vector. We can accomplish this very easily: just plug the definition $u = \frac{b}{\lVert b \rVert}$ into our dot product definition of the equation above. This leads to the definition that the dot product $a \cdot b$ divided by the magnitude $\lVert b \rVert$ of $b$ is the projection of $a$ onto $b$. Then, we get a nice symmetric definition for the dot product $a \cdot b$. \$\$a \cdot b = \lVert a \rVert \lVert b \rVert \cos \theta\$\$The dot product of the vectors $a$ and $b$ when divided by the magnitude of $b$, is the projection of $a$ onto $b$. Notice how the dot product is positive for acute angles and negative for obtuse angles. The formula demonstrates that the dot product grows linearly with the length of both vectors and is commutative, $a \cdot b = b \cdot a$.  The Formula for the Dot Product in terms of Vector Components : The geometric definition of the dot product says that the dot product between two vectors $a$ and $b$ is \$\$a \cdot b = \lVert a \rVert \lVert b \rVert \cos \theta\$\$Although this formula is nice for understanding the properties of the dot product, a formula for the dot product in terms of vector components would make it easier to calculate the dot product between two given vectors. Since the standard unit vectors are orthogonal, we immediately conclude that the dot product between a pair fo distinct standard unit vectors is zero. The dot product between a unit vector and itself is also simple to compute. In this case, the angle is zero and $\cos\theta = 1$. Given that the vectors are all of length one, the dot products are \$\$i \cdot i = j \cdot j = k \cdot k = 1\$\$The second step is to calculate the dot product between two three-dimensional vectors \$\$a = (a_1, a_2, a_3) = a_1 i + a_2 j + a_3 k b = (b_1, b_2, b_3) = b_1 i + b_2 j + b_3 k\$\$To do this, we simply assert that for any three vectors $a$, $b$ and $c$, and any scalar $\lambda$, \$\$(\lambda a ) \cdot b = \lambda (a \cdot b) = a \cdot (\lambda b)(a+b) \cdot c = a \cdot c + b \cdot c\$\$These properties mean that the dot product is linear. Given this properties and the fact that the dot product is commutative, we can expand the dot product $a \cdot b$ in terms of components,\$\$a \cdot b = (a_1 i + a_2 j + a_3 k) \cdot (b_1 i + b_2 j + b_3 k)\$\$Since we know the dot product of unit vectors, we can simplify the dot product formula to\$\$ a \cdot b = a_1 b_1 + a_2 b_2 + a_3 b_3\$\$Given the geometric definition of the dot product along with the dot product formula in terms of components, we are ready to calculate the dot product of any pair of two- or three-dimensional vectors. The Cross Product : There are two ways to take the product of a pair of vectors. One of these methods of multiplication is the cross product, which is the subject of this page. The other multiplication is the dot product, which we discuss on another page.  The cross product is defined only for three-dimensional vectors. If $a$ and $b$ are two three-dimensional vectors, then their cross product, written as $a \times b$ and pronounced  a cross b  is another three-dimensional vector. We define the cross product vector $a \times b$ by the following three requirements: $a \times b$ is a vector that is perpendicular to both $a$ and $b$.  The magnitude (or length) of the vector $a \times b$, written as $\lVert a \times b \rVert$ is the area of the parallelogram spanned by $a$ and $b$.  The direction of $a \times b$ is determined by the right-hand rule. (This means that if we curl the fingers of the right hand from $a$ to $b$, then the thumb points in the direction of $a \times b$. ) The below figure illustrates how, using trigonometry, we can calculate that area of the parallelogram spanned by $a$ and $b$ is \$\$\lVert a \rVert \lVert b \rVert \sin \theta\$\$where $\theta$ is the angle between $a$ and $b$. This formulat shows that the magnitude of the cross product is largest when $a$ and $b$ are perpendicular. On the other hand, if $a$ and $b$ are parallel or if either vector is the zero vector, then the cross product is the zero vector (It is a good thing that we get the zero vector in these cases so that the above definition still makes sense. If the vectors are parallel or one vector is the zero vector, then there is not a unique line perpendicular to both $a$ and $b$. But since there is only one vector of zero length, the definition still uniquely determines the cross product. )You can also verify that the applet demonstrates $b \times a = - a \times b$ and $a \times a = 0$, which are important properties of the cross product. The geometric definition of the cross product is good for understanding the properties of the cross product. However, the geometric definition isn't so useful for computing the cross product of vectors. For computations, we will want a formula in terms of the components of vectors. We start by using the geometric definition to compute the cross product of the standard unit vectors. The parallelogram spanned by any two of these standard unit vectors is a unit square, which has area one. Hence, by the geometric definition, the cross product must be a unit vector. Since the cross product must be perpendicular to the two unit vectors, it must be equal to the other unit vector or the opposite of that unit vector. \$\$i \times j = kj \times k = ik \times i = j\$\$By remembering that $b \times a = - a \times b$, you can infer that \$\$j \times i = -k k \times j = -ii \times k = -j\$\$Finally, the cross product of any vector with itself is the zero vector ($a \times a = 0$). In particular, the cross product of any standard unit vector with itself is the zero vector. With the exception of the two special properties mentioned above ($b \times a = - a \times b$, and $a \times a = 0$), we'll just assert that the cross product behaves like regular multiplication. It obeys the following properties:\$\$(ya) \times b = y (a \times b) = a \times (yb)a \time (b+c) = a \times b + a \times c(b+c) \times a = b \times a + c \times a\$\$where $a$, $b$, and $c$ are vectors in $\mathbb{R}^3$ and $y$ is a scalar. (These properties mean that the cross product is linear). We can use these properties, along with the cross product of the standard unit vectors, to write the formula for the cross product in terms of components. We write the components of $a$ and $b$ as:\$\$a = (a_1, a_2, a_3) = a_1 i + a_2 j + a_3 kb = (b_1, b_2, b_3) = b_1 i + b_2 j + b_3 k\$\$First, we'll assume that $a_3 = b_3 = 0$. (Then, the manipulations are much easier. )\$\$a \times b = (a_1b_2 - a_2 b_1)k \$\$Writing the result as a determinant, as we did in the last step, is a handy way to remember the result.  Matrices : The structure of a matrix allows us to define a fundamental operation on matrices: multiplication. This multiplication forms the basis of linear algebra. In particular, this matrix multiplication allows matrices to represent linear transformations (or linear functions) that transform vectors into other vectors. (A simple example of a linear transformation is the rotation of a vector. ) Other uses of matrices involve calculating their determinant.  Vectors as Matrices : When we view vectors as matrices, we actually view them as a rotated version of the standard form, writing an $n$-dimensional vector as a $n \times 1$ column matrix.  Matrix-Vector Product : To define multiplication between a matrix $A$ and a vector $x$ (i. e. , the matrix-vector product), we need to view the vector as a column matrix. One takes the dot product of $x$ with each rows of $A$. The first component of the matrix-vector product is the dot product of $x$ with the first row of $A$. In fact, $A$ has only one row, the matrix-vector product is really a dot product in disguise. Matrix-Matrix Product : Since we view vectors as column matrices, the matrix-vector product is simply a special case of the matrix-matrix product (i. e. , a product between two matrices). Just like for the matrix-vector product, the product $AB$ between matrices $A$ and $B$ is defined only if the number of columns in $A$ equals the number of rows in $B$. Each column of $C$ is the matrix-vector product of $A$ with the respective column of $B$.  The Transpose of a Matrix : The transpose of a matrix is simply a flipped version of the original matrix. We can transpose a matrix by switching its rows with its columns. We denote the transpose of matrix $A$ by $A^T$. We can take a transpose of a vector as a special case. Since an $n$-dimensional vector $x$ is represented by an $n \times 1$ column matrix, the transpose of $x^T$ is a $1 \times n$ row matrix. Although we won't typically write dot product as $x^T y$, we end up with a matrix multiplication equivalent to the familiar dot product $x \cdot y$. Moreover, you can view this dot product as forming the building block for the general matrix multiplication.  Linear Transformations : A linear transformation (or a linear map) is a function $T: \mathbb{R}^n \rightarrow \mathbb{R}^m$ that satisfies the following properties:\$\$T(x+y) = T(x) + T(y)T(ax) = aT(x)\$\$for any vectors $x,y \in \mathbb{R}^n$ and any scalar $a \in \mathbb{R}$. It is simple enought to identify whether or not a given function $f(x)$ is a linear transformation. Just look at each component of $f(x)$. If each of these terms is a number times one of the components of $x$, then $f$ is a linear transformation. The condition for a linear transformation is stronger than the condition one learns in grade school for a funciton whose graph is a line. A single variable function $f(x) = ax+b$ is not a linear transformation unless its $y$-intercept $b$ is zero. A useful feature of a linear transformation is that there is a one-to-one correspondence between matrices and linear transformations, based on matrix-vector multiplication.  Matrices and Linear Transformations : Given any $m \times n$ matrix $B$, we can define a function $g: \mathbb{R}^n \rightarrow \mathbb{R}^m (note the order of $m$ nad $n$ switched) by $g(x) = Bx$, where $x$ is an $n$-dimensional vector. In this way, we can associate with every matrix a function. What about going the other way around? Given some function, say $g: \mathbb{R}^n \rightarrow \mathbb{R}^m$, can we associate with $g(x)$ some matrix? We can only if $g(x)$ a a special kind of function called a linear transformation. The function $g(x)$ is a linear transformation if each term of the component of $g(x)$ is a number of times on of the variables. The important conclusion is that every linear transformation is associated with a matrix and vice versa.  Determinants : Many of the main uses for matrices in multivariate calculus involve calculating something called the determinant. It's useful, for example, to calculate the cross product as well as a change of variables. The determinant of a matrix is defined only for square matrices, i. e. , $n \times n$ matrices with the same number of rows and columns. The determinant can be viewed as a funciton whose input is a square matrix and whose output is a number. The determinant of a $1 \times 1$ matrix is that number itself. We calculate the determinant of a $3 \times 3$ matrix in the exact same way. We proceed along the first row and multiply each component by the determinant of the submatrix formed by ignoring that component's row andcolumn. Through this procedure we calculate three terms, one for $a$, one for $b$, and one for $c$. Each of these terms is added together, only with alternating signs (the first term - the second term + the third term). The above procedure generalizes to large determinants, but $3 \times 3$ determinants will be enough for multivariate calculus. However, note that in this case, the vertical lines do not mean absolute value. The determinant can be negative. In mathematics, we like to use the same symbols to mean different things, which is okay as long as it's clear from context. Since the absolute value of an array of numbers is meaningless, the notation is unambiguous.  The Relationships between $ and Area or Volume : From the properties of the geometric definition of the cross product, we can discover a link between $2 \times 2$ determinants and area and a link between $3 \times 3$ determinants and volume. Determinants and Linear Transformations : A linear transformation $T: \mathbb{R}^n \rightarrow \mathbb{R}^m$ is a mapping from $n$-dimensional space to $m$-dimensional space. Such a linear transformation can be associated with an $m \times n$ matrix. If we restrict ourselves to mappings within the same space, such as $T: \mathbb{R}^n \rightarrow \mathbb{R}^n$, then $T$ is associated with a square $n \times n$ matrix. One can calculate the determinant of such a square matrix, and such determinants are related to area or volume. It turns out that the determinant of a matrix tells us important geometrical properties of its associated linear transformation.  One-Dimensional Linear Transformations : A one-dimensional linear transformation is a function $T(x) = ax$ for some scalar $a$. To view the one-dimensional case in the same way we view higher dimensional linear transformations, we can view $a$ as a $1 \times 1$ matrix. The determinant of the $1 \times 1$ matrix is just the numbwer $a$ itself. Although this case is very simple, we can gather some intuition about linear maps by first looking at this case. An example one-dimensional linear transformation is the function $T(x) = 3x$. We could visualize this function by its graph, which is a line through the origin with slope 3. However, instead, let's view it as a mapping from the real line $R$ back on to the real line $R$. In this case, we can think of the function as $x' = T(x)$, which maps the number $x$ on the $x$-axis to the new number $T(x)$ on the $x'$-axis. $T$ takes the number 1 and maps it to $3$. We also use the language that $3$ is the image of $1$ under the mapping $T$. We can summarize this mapping by looking how $T$ maps an interval of numbers. For example, $T$ maps the interval $[0,1]$ to the interval $[0,3]$, as illustrated by the following figure. The fact that the determinant of the matrix associated with $T$ is 3 means that $T$ stretches objects so that their length is increased by a factor of 3. $T$ preserves the orientation of objects: in both the interval $[0,1]$ and its image $[0,3]$, red points are to the right of green points. In general, the linear transformation $T(x) = ax$ stretches objects to change their length by a factor of $\lvert a \rvert$. If $a$ is positive, $T$ preserves the orientation; if $a$ is a negative, $T$ reverse orientaiton. We will obtain similar conclusions for higher-dimensional lilnear transformation in terms of the determinant of the associated matrix.  Two-Dimensional Linear Transformations : A two-dimensional linear transformation is a function $T: \mathbb{R}^2 \rightarrow \mathbb{R}^2$ of the form \$\$T(x,y) = (ax+by, cx+dy)\$\$where $a,b,c$, and $d$ are numbers defining linear transformation. We can write this more succinctly as $T(x) = Ax$, where $x = (x,y)$ and $A$ is the $2 \times 2$ matrix containing the constants that define the linear transformation. We will view $T$ as mapping objects from the $xy$-plane onto an $x'y'$-plane: (x',y') = T(x,y)$. as in the one-dimensional case, the geometric properties of this mapping will be reflected in the determinant of the matrix $A$ associated with $T$. To begin, we look at the linear transformation $T(x,y)$. As with all linear transformations, it maps the origin $x=(0,0)$ back to the origin $(0,0)$. We can get a feel for the behavior of $T$. We can get a feel for the behavior of $T$ by looking at its actions on the standard unit vectors, $i=(1,0)$ and $j=(0,1)$.  References : scratchpixel "
    }, {
    "id": 11,
    "url": "https://sally20921.github.io/_posts/2021-10-21-rigid2.html",
    "title": "3D Rigid Body Motion (Part 2)",
    "body": " Rotation Vectors : References:  Introduction to Visual SLAM"
    }, {
    "id": 12,
    "url": "https://sally20921.github.io/404.html",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 13,
    "url": "https://sally20921.github.io/about.html",
    "title": "About",
    "body": "Made by Seri @porfolio. "
    }, {
    "id": 14,
    "url": "https://sally20921.github.io/author-seri.html",
    "title": "Sal",
    "body": "                        Sal /span&gt;&lt;/h2&gt;        https://sites. google. com/snu. ac. kr/sally20921porfolio         Hi, I am Seri, the author of this blog.       &lt;/div&gt;                        &lt;/div&gt;    Posts by Sal:                   		3D Rigid Body Motion (Part 2)	: 		  The goal of this article is to introduce the rigid body geometry in 3-dimensional spaace: rotation matrix, transformation matrix, quaternion and Euler angle. 	 			In 				computer vision, 								Oct 21, 2021						            		Geometry	: 		  	 			In 				computer vision, 								Sep 16, 2021						            		All About Training GAN	: 		  I wrote a short article about what I learned training GANs. GAN is well known for its instability in training and there are pitfalls worth knowing. 	 			In 				computer vision, 								Sep 14, 2021						            		Dissecting the Camera Matrix (Part 2)	: 		  	 			In 				computer vision, 								Sep 14, 2021						            		Advanced PyTorch: Things You Didn't Know	: 		  	 			In 				PyTorch, 								Sep 12, 2021						            		Guide to Linear Algebra (Part 1)	: 		  	 			In 				linear algebra, 								Sep 09, 2021						            		Batch Normalization and Group Normalization	: 		  	 			In 				deep learning, 								Sep 08, 2021						            		Depth from Disparity	: 		  	 			In 				computer vision, 								Sep 05, 2021						            		Dissecting the Camera Matrix (Part 1)	: 		  	 			In 				computer vision, 								Sep 05, 2021						            		Depth Estimation: Basics and Intuition	: 		  This article focuses on giving readers a background into depth estimation and problem associated with it. We cover both methodolgies used to extract the depth information, namely 'dep. . . 	 			In 				computer vision, 								Sep 02, 2021						            		3D Rigid Body Motion (Part 1)	: 		  	 			In 				computer vision, 								Aug 31, 2021						            		Homogeneous Coordinates and Projective Geometry	: 		  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and . . . 	 			In 				computer vision, 								Aug 31, 2021						        &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;: "
    }, {
    "id": 15,
    "url": "https://sally20921.github.io/authors-list.html",
    "title": "Authors",
    "body": "Authors:                                             Seri :       (View Posts)      Hi, I am Seri, the author of this blog.                           &nbsp;       &nbsp;                                      "
    }, {
    "id": 16,
    "url": "https://sally20921.github.io/categories.html",
    "title": "Categories",
    "body": "          Categories               computer vision:                                  		3D Rigid Body Motion (Part 2)	: 		  The goal of this article is to introduce the rigid body geometry in 3-dimensional spaace: rotation matrix, transformation matrix, quaternion and Euler angle. 	 			In 				computer vision, 								Oct 21, 2021						                                 		Geometry	: 		  	 			In 				computer vision, 								Sep 16, 2021						                                 		All About Training GAN	: 		  I wrote a short article about what I learned training GANs. GAN is well known for its instability in training and there are pitfalls worth knowing. 	 			In 				computer vision, 								Sep 14, 2021						                                 		Dissecting the Camera Matrix (Part 2)	: 		  	 			In 				computer vision, 								Sep 14, 2021						                                 		Depth from Disparity	: 		  	 			In 				computer vision, 								Sep 05, 2021						                                 		Dissecting the Camera Matrix (Part 1)	: 		  	 			In 				computer vision, 								Sep 05, 2021						                                 		Depth Estimation: Basics and Intuition	: 		  This article focuses on giving readers a background into depth estimation and problem associated with it. We cover both methodolgies used to extract the depth information, namely 'dep. . . 	 			In 				computer vision, 								Sep 02, 2021						                                 		3D Rigid Body Motion (Part 1)	: 		  	 			In 				computer vision, 								Aug 31, 2021						                                 		Homogeneous Coordinates and Projective Geometry	: 		  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and . . . 	 			In 				computer vision, 								Aug 31, 2021						                              deep learning:                                  		Batch Normalization and Group Normalization	: 		  	 			In 				deep learning, 								Sep 08, 2021						                              linear algebra:                                  		Guide to Linear Algebra (Part 1)	: 		  	 			In 				linear algebra, 								Sep 09, 2021						                              PyTorch:                                  		Advanced PyTorch: Things You Didn't Know	: 		  	 			In 				PyTorch, 								Sep 12, 2021						                                             Featured:    				                                          3D Rigid Body Motion (Part 2)                          In                     computer vision,                                                                                           Geometry                          In                     computer vision,                                                                                           All About Training GAN                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 2)                          In                     computer vision,                                                                                           Advanced PyTorch: Things You Didn't Know                          In                     PyTorch,                                                                                           Guide to Linear Algebra (Part 1)                          In                     linear algebra,                                                                                           Batch Normalization and Group Normalization                          In                     deep learning,                                                                                           Depth from Disparity                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 1)                          In                     computer vision,                                                                                           Depth Estimation: Basics and Intuition                          In                     computer vision,                                                                                           3D Rigid Body Motion (Part 1)                          In                     computer vision,                                                                                           Homogeneous Coordinates and Projective Geometry                          In                     computer vision,                                                                   "
    }, {
    "id": 17,
    "url": "https://sally20921.github.io/contact.html",
    "title": "Contact",
    "body": "  Please send your message to Seri Lee Blog. We will reply as soon as possible!   "
    }, {
    "id": 18,
    "url": "https://sally20921.github.io/",
    "title": "Mundana Free Jekyll Theme",
    "body": "                                  3D Rigid Body Motion (Part 2)  :       The goal of this article is to introduce the rigid body geometry in 3-dimensional spaace: rotation matrix, transformation matrix, qua. . .               In                 computer vision,                                        Oct 21, 2021                                                                                                                             Geometry          :                       In                         computer vision,                                                                  Sep 16, 2021                                                                                                                                     All About Training GAN          :                       In                         computer vision,                                                                  Sep 14, 2021                                                                                                                                    Dissecting the Camera Matrix (Part 2)          :                       In                         computer vision,                                                                  Sep 14, 2021                                                            Homogeneous Coordinates and Projective Geometry                  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coo. . .                 Read More            	                        All Stories:                   		3D Rigid Body Motion (Part 2)	: 		  The goal of this article is to introduce the rigid body geometry in 3-dimensional spaace: rotation matrix, transformation matrix, quaternion and Euler angle. 	 			In 				computer vision, 								Oct 21, 2021						                  		Geometry	: 		  	 			In 				computer vision, 								Sep 16, 2021						                  		All About Training GAN	: 		  I wrote a short article about what I learned training GANs. GAN is well known for its instability in training and there are pitfalls worth knowing. 	 			In 				computer vision, 								Sep 14, 2021						                  		Dissecting the Camera Matrix (Part 2)	: 		  	 			In 				computer vision, 								Sep 14, 2021						                  		Advanced PyTorch: Things You Didn't Know	: 		  	 			In 				PyTorch, 								Sep 12, 2021						                  		Guide to Linear Algebra (Part 1)	: 		  	 			In 				linear algebra, 								Sep 09, 2021						                  		Batch Normalization and Group Normalization	: 		  	 			In 				deep learning, 								Sep 08, 2021						                  		Depth from Disparity	: 		  	 			In 				computer vision, 								Sep 05, 2021						                  		Dissecting the Camera Matrix (Part 1)	: 		  	 			In 				computer vision, 								Sep 05, 2021						                  		Depth Estimation: Basics and Intuition	: 		  This article focuses on giving readers a background into depth estimation and problem associated with it. We cover both methodolgies used to extract the depth information, namely 'dep. . . 	 			In 				computer vision, 								Sep 02, 2021						                                                &laquo;                              1                               2                              Next &raquo;                                          Featured:    				                                          3D Rigid Body Motion (Part 2)                          In                     computer vision,                                                                                           Geometry                          In                     computer vision,                                                                                           All About Training GAN                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 2)                          In                     computer vision,                                                                                           Advanced PyTorch: Things You Didn't Know                          In                     PyTorch,                                                                                           Guide to Linear Algebra (Part 1)                          In                     linear algebra,                                                                                           Batch Normalization and Group Normalization                          In                     deep learning,                                                                                           Depth from Disparity                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 1)                          In                     computer vision,                                                                                           Depth Estimation: Basics and Intuition                          In                     computer vision,                                                                                           3D Rigid Body Motion (Part 1)                          In                     computer vision,                                                                                           Homogeneous Coordinates and Projective Geometry                          In                     computer vision,                                                               &lt;/div&gt; "
    }, {
    "id": 19,
    "url": "https://sally20921.github.io/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "‚ÄúSeri Lee Blog‚Äù takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor‚Äôs preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google‚Äôs cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 20,
    "url": "https://sally20921.github.io/tags.html",
    "title": "Tags",
    "body": "          Tags               sticky:                                  		Homogeneous Coordinates and Projective Geometry	: 		  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and . . . 	 			In 				computer vision, 								Aug 31, 2021						                              featured:                                  		3D Rigid Body Motion (Part 2)	: 		  The goal of this article is to introduce the rigid body geometry in 3-dimensional spaace: rotation matrix, transformation matrix, quaternion and Euler angle. 	 			In 				computer vision, 								Oct 21, 2021						                                 		Geometry	: 		  	 			In 				computer vision, 								Sep 16, 2021						                                 		All About Training GAN	: 		  I wrote a short article about what I learned training GANs. GAN is well known for its instability in training and there are pitfalls worth knowing. 	 			In 				computer vision, 								Sep 14, 2021						                                 		Dissecting the Camera Matrix (Part 2)	: 		  	 			In 				computer vision, 								Sep 14, 2021						                                 		Advanced PyTorch: Things You Didn't Know	: 		  	 			In 				PyTorch, 								Sep 12, 2021						                                 		Guide to Linear Algebra (Part 1)	: 		  	 			In 				linear algebra, 								Sep 09, 2021						                                 		Batch Normalization and Group Normalization	: 		  	 			In 				deep learning, 								Sep 08, 2021						                                 		Depth from Disparity	: 		  	 			In 				computer vision, 								Sep 05, 2021						                                 		Dissecting the Camera Matrix (Part 1)	: 		  	 			In 				computer vision, 								Sep 05, 2021						                                 		Depth Estimation: Basics and Intuition	: 		  This article focuses on giving readers a background into depth estimation and problem associated with it. We cover both methodolgies used to extract the depth information, namely 'dep. . . 	 			In 				computer vision, 								Sep 02, 2021						                                 		3D Rigid Body Motion (Part 1)	: 		  	 			In 				computer vision, 								Aug 31, 2021						                                 		Homogeneous Coordinates and Projective Geometry	: 		  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and . . . 	 			In 				computer vision, 								Aug 31, 2021						                                             Featured:    				                                          3D Rigid Body Motion (Part 2)                          In                     computer vision,                                                                                           Geometry                          In                     computer vision,                                                                                           All About Training GAN                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 2)                          In                     computer vision,                                                                                           Advanced PyTorch: Things You Didn't Know                          In                     PyTorch,                                                                                           Guide to Linear Algebra (Part 1)                          In                     linear algebra,                                                                                           Batch Normalization and Group Normalization                          In                     deep learning,                                                                                           Depth from Disparity                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 1)                          In                     computer vision,                                                                                           Depth Estimation: Basics and Intuition                          In                     computer vision,                                                                                           3D Rigid Body Motion (Part 1)                          In                     computer vision,                                                                                           Homogeneous Coordinates and Projective Geometry                          In                     computer vision,                                                                   "
    }, {
    "id": 21,
    "url": "https://sally20921.github.io/robots.txt",
    "title": "",
    "body": "Sitemap: https://sally20921. github. io/sitemap. xml "
    }, {
    "id": 22,
    "url": "https://sally20921.github.io/page2/",
    "title": "Mundana Free Jekyll Theme",
    "body": "                  All Stories:                   		3D Rigid Body Motion (Part 1)	: 		  	 			In 				computer vision, 								Aug 31, 2021						                  		Homogeneous Coordinates and Projective Geometry	: 		  Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and . . . 	 			In 				computer vision, 								Aug 31, 2021						                                                &laquo; Prev                              1                               2                              &raquo;                                          Featured:    				                                          3D Rigid Body Motion (Part 2)                          In                     computer vision,                                                                                           Geometry                          In                     computer vision,                                                                                           All About Training GAN                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 2)                          In                     computer vision,                                                                                           Advanced PyTorch: Things You Didn't Know                          In                     PyTorch,                                                                                           Guide to Linear Algebra (Part 1)                          In                     linear algebra,                                                                                           Batch Normalization and Group Normalization                          In                     deep learning,                                                                                           Depth from Disparity                          In                     computer vision,                                                                                           Dissecting the Camera Matrix (Part 1)                          In                     computer vision,                                                                                           Depth Estimation: Basics and Intuition                          In                     computer vision,                                                                                           3D Rigid Body Motion (Part 1)                          In                     computer vision,                                                                                           Homogeneous Coordinates and Projective Geometry                          In                     computer vision,                                                               "
    }, {
    "id": 23,
    "url": "https://sally20921.github.io/rigid2.html",
    "title": "3D Rigid Body Motion (Part 2)",
    "body": "2021/10/21 -  Rotation Vectors : References:  Introduction to Visual SLAM"
    }, {
    "id": 24,
    "url": "https://sally20921.github.io/geometry.html",
    "title": "Geometry",
    "body": "2021/09/16 -  Coordinate Systems : Introducing Coordinate Systems : Coordinate systems play an essential role in the graphics pipeline. They are not complicated; However, learning a few things about them will make it easier to understand matrices. I mentioned that points and vectors (as used in computer vision/graphics) are represented with 3 real numbers. But what do these numbers mean? Each number represents a signed distance from the origin of a line to the position of the point on that line. Consider drawing a line and putting a mark in the middle. We will call this mark origin. This mark becomes our point of reference: the position from which we will measure the distance to any other points. If a point lies to the right side of the origin, we take the signed distance to be greater than zero. On the other hand, if it is on the left side of the origin, the values will be negative. Now that we have a line and an origin, we add some additional marks at a regular interval (unit length) on each side of the origin, effectively turning our line into a ruler. With the ruler established, we can simply use it to measure the coordinate of a point from the origin (coordinate is another way of saying the signed distance from the origin to the point). In mathematics, the ruler defines what we call axis . We have just learned to define the coordinate of a point along an axis.  Dimensions and Cartesian Coordinate Systems : By placing two axes called $x$-axis and $y$-axis, we have defined a two dimensional space called a plane . These two axes are said to define a coordinate system.  If these two rulers are perpendicular to each other, they define what we call a Cartesian coordinate system.  We now know how to make a two-dimensional Cartesian coordinate system and define the coordinates of a 2D point in that coordinate system. Note that the coordinates of points defined in a coordinate system are unique &lt;/span&gt;. The same point cannot be represented by two different sets of coordinates in one system. We are free to choose any coordinate system that we please. In fact, we can choose to define infinitely many coordinate systems in a plane. Let‚Äôs assume we drew two Cartesian coordinate system like the figure above. On this paper, we place one point.  The coordinates of that point will be different depending on which of the two coordinate system we consider.  If you know the coordinates of $P$ in coordinate system $A$, what do you need to do to find the coordinate of the same point in another coordinate system $B$? This represents an extremely important operation in computer vision, and we will soon learn why and how to find the map which translates the coordinates of a point from one coordinate system to another. Another common operation is to move the point in the coordinate system $A$ to another location in the same coordinate system. This is called a translation and is certainly one of the basic operations you can do on points. Note that all sorts of other linear operators can be applied to point coordinates. A multiplication of a real number to the coordinate of point produces scale . A scale moves $P$ along the line that is going through the point and the origin. That is because when we are transforming a point we are actually transforming the vector going from origin to the point.  The Third Dimension : The 3D coordinate system is a simple extension of the 2D case. We will be adding a third axis orthogonal to both the $x$- and $y$-axis called the $z$-axis (representative of depth). In geometry, 3D coordinate system defines what is more formally known as Euclidean Space . In linear algebra, the three axes from what we call the basis of that coordinate system. A basis is a set of linearly independent vectors that, in a linear combination, can represent every vector (or point) in a given vector space (the coordinate system).  Vectors from a set are said to be linearly independent if and only if none of the vectors in the set can be written as a linear combination of other vectors in that set. Change of basis, or change of coordinate system, is a common operation in mathematics and computer vision pipeline.  Left-Handed vs Right-Handed Coordinate Systems : Unfortunately, due to various conventions concerning handedness, coordinate systems are not that simple. The problem can be illustrated in the following figure: when the up and forward vectors are oriented in the same way, an appropriate right vector can either point to the left or to the right. To differentiate the two conventions, we call the first coordinate system the left-handed coordinate system, and the other, the right-handed coordinate system.  Remember that the middle finger always represent the right vector when checking the coordinate handedness.  The handedness of the coordinate system also plays a role in the orientation of normals computed from the edges of polygonal faces. If the orientation is right-handed, then polygons whose vertices were specified in counterclockwise order will be front-facing. This will be explained in the part on rendering polygon objects.  The Right, Up and Forward Vectors : The Cartesian coordinate system is only defined by three perpendicular vectors of unit length. As far as the mathematical notation is concerned, this coordinate system does not convey anything about what these three axes actually mean. The developer is the one that decides how these axes should be interpreted. It is thus very important to make a clear distinction between the handedness of the coordinate system and the conventions used to label the corresponding axes. The choice of coordinate system handedness also plays a critical role when it comes to rotation and the cross product of two vectors. It‚Äôs actually easy enough (but painful) to go from one coordinate system to another. All that is needed is to scale the point coordinates and the camera-to-world matrix by $(1,1,-1)$.  The World Coordinate System : In most 3D applications, each different type of coordinate system is defined with respect to a master coordinate system called the world coordinate system. It defines the origin and the main $x$,$y$,$z$-axes from which all other coordinate systems are defined.  Math Operations on Points and Vectors : I have explained the concept of (Cartesian) coordinate system. Now we can look at some of the most common operations which can be performed on points and vectors.  Vector Length : The vector itself indicates not only the direction of point $B$ from $A$ but also can be used to find out the distance between $A$ and $B$. This is given by the length of a vector which can easily be computed with the following formula: $$\lVert V \rVert = \sqrt{x^2 + y^2 + z^2}$$ The vector's length is sometimes also called norm or magnitude.  Note that the axes of the three-dimensional Cartesian coordinate systems are unit vectors.  Normalizing a Vector : A normalized vector is a vector whose length is 1. Such a vector is also called a unit vector (it is a vector which has unit length). Normalizing a vector is very simple. We first compute the length of the vector and divide each one of the vector coordinates with this length. $$\hat{V} = \frac{V}{\lVert V \rVert}$$ In mathematics, you will also find the term norm to define a function that assigns a length or size (or distance) to a vector. The function we have just described is called the Euclidean norm.  Dot Product : The dot product or scalar product requires two vectors $A$ and $B$ and can be seen as the projection of one vector onto the other. The result of the dot product is a real number. A dot product between two vectors is denoted with the dot sign: $A \cdot B$ (it can also sometimes be written as $&lt;A,B&gt;$). The dot product consists of multiplying each element of the $A$ vector with its counterpart from vector $B$ and taking the sum of each product. In the case of 3D vectors (they have three coefficients of elements which are $x$, $y$ and $z$), it consists of the following operation: $$A \cdot B = A. x * B. x + A. y * B. y + A. z * B. z$$ Note that this is quite similar to the way we compute the length of a vector. If we take the square root of the dot product between two vectors ($\sqrt{A \cdot B}$) that are equal ($A=B$), then what we get is the length of the vector. We can write: $${\lVert V \rVert}^2 = V \cdot V$$ The dot product between two vectors is an extremely important and common operation in any 3D application because the result of this operation relates to the cosine of the angle between the two vectors. In this example vector $A$ is projected in the direction of vector $B$.  If $B$ is a unit vector then the product $A \cdot B$ gives $\lVert A \rVert \cos (\theta)$, the magnitude of the projection of $A$ in the direction of $B$, with a minus sign if the direction is opposite. This is called the scalar projection of $A$ onto $B$.  When neither $A$ nor $B$ is a unit vector, we can write that $A \cdot B / \lVert B \rVert$, since $B$ as a unit vector is $B/\lVert B rVert$.  In mathematics, $ {\cos}^{-1}$ is the inverse of the cosine function. When the two vectors are normalized ($A \cdot B / \lVert A \rVert \lVert B \rVert$), taking the arc cosine of the dot product gives you the angle $\theta$ between two vectors: $\theta = {\cos}^{-1}(A \cdot B / \lVert A \rVert \lVert B \rVert)$ or $\theta = {\cos}^{-1}(\hat{A} \cdot \hat{B})$.  The dot product is a very important operation in 3D. It can be used for many things. As a test of orthogonality. When two vectors $A$,$B$ are perpendicular to each other, the result of the dot product between these two vectors is $0$. It is also used intensively to find out the angle between two vectors or compute the angle between a vector and the axis of a coordinate system.  Cross Product : The cross product is also an operation on two vectors. The difference between cross product and dot product is that the dot product returns a number, whereas the cross product returns a vector. The particularity of this operation is that the vector resulting from the cross product is perpendicular to the other two.  The cross product operation is written using the following syntax:\$\$C = A \times B\$\$To compute the cross product we will need to implement the following formula:\$\$C_x = A_Y * B_Z - A_Z * B_YC_Y = A_Z * B_X - A_X * B_ZC_Z = A_X * B_Y - A_Y * B_X\$\$The result of this cross product is another vector which is  orthogonal to the other two. The two vectors $A$ and $B$ define a plane and the resulting vector $C$ is perpendicular to that plane. $A$ and $B$ don't have to be perpendicular to each other, but when they are, the resulting $A$, $B$ and $C$ vectors form a Cartesian coordinate system (assuming the vectors have unit length). If you need a mnemonic way of remembering this formula, we like to use the technique that consists of asking ourselves the question  why z? . $y$ and $z$ being the coordinates of vector $A$ and $B$ used to compute the $x$ coordinates of the resulting vector $C$. It is important to note that the order of the vectors involved in the cross product has an effect on the resulting vector $C$. You can see that $A \times B$ doesn't give you the same result as $B \times A$.  How Does Matrix Work : Point-Matrix Multiplication : Two matrices need to have compatible sizes in order to be multiplied with each other. For instance, the matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. Point can be written in a matrix form $P = [xyz]$. There is two things we need to remember. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point. The second thing we need to remember is that a $m \times p$ matrix multiplied by $p \times n$ matrix, gives a $m \times n$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point. The Identity Matrix : The identity matrix or unit matrix is a square matrix whose coefficients are all 0 except the coefficients along the diagonal which are set to $1$. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}\$\$The result of $P$ multiplied by the identity matrix is $P$.  The Scaling Matrix : When these coefficients of the identity matrix are different than 1 (whether smaller or bigger than 1), then they act as a multiplier on the point's coordinates. In other words, the points coordinates are scaled up or down by some amount. \$\$\begin{bmatrix}S_X &amp; 0 &amp; 0 \\0 &amp; S_Y &amp; 0 \\0 &amp; 0 &amp; S_Z\end{bmatrix}\$\$Note that if either one of the scaling coefficiuent in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped (it will be mirrored to the other side of the matrix). The Rotation Matrix : We are now talking about building a matrix that will rotate a point or a vector around one axis of the cartesian coordinate system. And for doing so, we will need to use trigonometric functions.  Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of a rotation (we could do this with a translation but using a rotation will be easier). $P_T$ coordinates are $(0,1,0)$. As you can see, this can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ into $P_T$. \$\$\begin{aligned}P_T. x = P. x * R_{00} + P. y * R_{10} + P. z * R_{20} \\P_T. y = P. x * R_{01} + P. y * R_{11} + P. z * R_{21} \\P_T. z = P. x &amp; R_{02} + P. y * R_{12} + P. z * R_{22}\end{aligned}\$\$As we said, we don't care so much about $P_T. z$ for now which represents the $z$-coordinate of $P_T$. Let's concentrate instead on $P_T. x$ and $P_T. y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. It means that $R_{00}$ has to be equal to $0$. Considering that $P. y$ and $P. z$ are 0 anyway we don't care much about the values that $R_{10}$ and $R_{20}$ may be for now. What do we know about $P$? We know that $P. x$ is 1 and that all the other coordinates of $P$ are $0$. Which necessarily means that $R_{01}$ has to be 1. Let's recap. We know that $R_{00}$ is 0 and $R_{01}$ is 1. Let's write it down and see what $R$ looks like: (compare this matrix with the identity matrix)\$\$R_z = \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\$\$If you use this matrix to transform $P=(1,0,0)$ you will get $P_T = (0,1,0)$. How Does Matrix Work? : Point-Matrix Multiplication : We will start to put all the things we have learned on points, vectors, matrices and coordinate systems together. We mentioned that two matrices needed to have compatible sizes in order to be multiplied with each other. The matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. A point or a vector is a sequence of three numbers and for this reason they too can be written as a $1 \times 3$ matrix, a matrix that has one row and three columns. Point written in a matrix form $P=[xyz]$. The trick here is that, if we can write points and vectors as $1 \times 3$ matrices, we can multiply them by other matrices. Remember that the matrix $m \times p$ can be multiplied by the matrix $p \times n$ to give the matrix $m \times n$. So this implies that we can multiply something of the form $3 \times n$ where n can be any number greater than 1. There is two things we need to remember now to make sense of what we are going to explain. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point. If it wasn't the case, we wouldn't be using matrices as a convenient way of transforming points. The second thing we need to remember is that a $m \times p$ matrix multiplied by a $p \times n$ matrix, gives a $m \times n$ matrix. If we look at our point as a $1 \times 3$ matrix, we need the result of the multiplication to be another point, that is a $1 \times 3$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point.  The Identity Matrix : The identity matrix or unit matrix is a square matrix whose coefficients are all $0$ except the coefficients along the diagonal which are set to $1$. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}\$\$The result of $P$ multiplied by the identity matrix is $P$. The Scaling Matrix : If you look at the code of the point-matrix multiplication, you can see that the coordinates of the point $P$ are respectively multiplied by the coefficients $R_{00}$ for $x$, $R_{11}$ for $y$, and $R_{22}$ for $z$. When these coefficients are set to $1$ (and all the other coefficients are set to $0$), we get the identity matrix. However, when these coefficients (along the diagonal) are different than $1$ (whether smaller or bigger than $1$), then they act as a multiplier on the point's coordinates (in other words, the points coordinates are scaled up or down by some amount). If you remember what we have said about coordinate systems, multiplying the coordinates ofa point by some real numbers result in scaling the point's coordinates. The scaling matrix can therefore be written as:\$\$\begin{bmatrix}S_X &amp; 0 &amp; 0 \\0 &amp; S_Y &amp; 0 \\0 &amp; 0 &amp; S_Z\end{bmatrix}\$\$Note that if either one of the scaling coefficients in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped (it will be mirrored to the other side of the axis).  The Rotation Matrix : What we will be talking about now is about building a matrix that will rotate a point or a vector around one axis of the Cartesian coordinate system. And for doing so, we will need to use trigonometric functions. Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Let's ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of rotation (we could do this with a translation but using a rotation will make our demonstration easier). $P_T$ coordinates are $(0,1,0)$. This can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ to $P_T$. Considering what we know about matrix multiplication let's see how we can re-write a point-matrix multiplication and isolate the computation of each of the transformed coordinates. \$\$\begin{aligned}P_T. x = P. x * R_{00} + P. y * R_{10} + P. z * R_{20} \\P_T. y = P. x * R_{01} + P. y * R_{11} + P. z * R_{21} \\P_T. z = P. x * R_{02} + P. y * R_{12} + P. z * R_{22}\end{aligned} \$\$As we said, we don't care so much about $P_T. z$ for now which represents the $z$-coordinate of $P_T$. Let's concentratte instead on $P_T. x$ and $P_T. y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. If we look at the first line of the code we wrote to compute $P_T$, it means that $R_{00}$ has to be equal to 0. Considering that $P. y$ and $P. z$ are $0$ anyway we don't care so much about the values that $R_{10}$ and $R_{20}$ may have for now. From P to $P_T$, the $y$-coordinate goes from $0$ to $1$. Let's have a look at the second line of code. What do we know about $P$? We know that $P. x$ is $1$ and that all the other coordinates of $P$ are $0$, which necessarily means that $R_{01}$ has to be $1$. Let's recap. We know that $R_{00}$ is $0$ and $R_{01}$ is $1$. Let's write it down and see what $R$ looks like (compare this matrix with the identity matrix):\$\$R_z = \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \end{bmatrix}\$\$Don't worry for now if you don't understand why the coefficients have the value they have. That will be explained soon. All you want to see, is that if you use this matrix to transform $P=(1,0,0)$ you will get $P_T=(0,1,0)$. \$\$\begin{aligned}P_T. x = P. x * 0 + P. y * 1 + P. z * 0 = 0 \\P_T. y = P. x * 1 + P. y * 0 + P. z * 0 = 1 \\P_T. z = P. x * 0 + P. y * 0 + P. z * 1 = 0\end{aligned}\$\$This is where our knowledge of trigonometric functions will become handy. If we look at a point on the unit circle we know that its $x$ and $y$ coordinates can be computed using the sine and cosine of the angle $\theta$. \$\$\begin{aligned}x = cos(\theta) = 0 \\y = sin(\theta) = 1 \\\theta = \frac{\pi}{2}\end{aligned}\$\$When $\theta=0$, $x=1$ and $y=0$. When $\theta = 90$ degrees (or $\frac{\pi}{2}$), $x=0$ and $y=1$. That is interesting because you will notice that $x=0$ and $y=1$ are values of $R_{00}/R_{11}$ and $R_{01}/R_{10}$ respectively. So we could re-write the matrix $R$ as:\$\$R_z(\theta) = \begin{bmatrix}cos(\theta) &amp; sin(\theta) &amp; 0 \\sin(\theta) &amp; cos(\theta) &amp; 0 \\0 &amp; 0 &amp; 1\end{bmatrix}= \begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \end{bmatrix}\$\$ Combining Rotation Matrices : We have learned that multiplying matrices together combines their transformations. Now that we know how to rotate points around individual axis, it is possible to multiply $R_x$, $R_y$, $R_z$ together to create more complex rotations. If for instance you want to rotate a point around the $x$-axis, and then the $y$-axis, you can create two matrices using the matrices $R_x$ and $R_y$ and combine them using matrix multiplication $R_x * R_y$ to create a $R_{xy}$ matrix encoding the two individual rotations. Note that the order of the rotation is important and makes a difference. If you rotate a point around the $x$-axis first and then the $y$-axis second, you will end up with a result which is different from a rotation around the $y$-axis and then around the $x$-axis.  Relation Between Matrices and Cartesian Coordinate System : If you imagine that you have a point $P_x$ with coordinates $(1,0,0)$ and want to rotate this point around the $z$-axis by 10 degrees clockwise, we know that these new coordinates can be found using simple trigonometry.  Orthogonal Matrices : In fact, the type of matrices we ahve described (the rotation matrices) are called in linear algebra, orthogonal matrices. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors. We have mentioned previously that each row from the matrix represents an axis of a Cartesian coordinate system. If the matrix is a rotation matrix or the result of several rotation matrices multiplied with each other, then each row necessarily represents an axis of unit length (because the elements of the rows are constructed from the sine and cosine trigonometric functions which are used to compute the coordinates of points lying on the unit circle). You can see them as a Cartesian coordinate system which is originally aligned with the world coordinate system (the identity matrix's rows represent the axes of the world coordinate system) and rotated around one particular axis or a random axis. Orthogonal matrices have a few interesting properties but maybe the most useful one in computer vision, is that the transpose of an orthogonal matrix is equal to its inverse. Assuming $Q$ is an orthogonal matrix, we can write:\$\$Q^T = Q^{-1}\$\$ which entials that $QQ^T = I$, where $I$ is the identity matrix. Affine Transformations : You will sometimes find the terms affine transformations used in place of matrix transformation. This technical term is actually more accurate to designate the transformations that you get from using the type of matrices we have described so far. In short, an affine transformation, is a transformation that preserves straight lines. The translation, rotation, shearing matrix are all affine transformations as are their combinations. The other type of transformation we will be studying in computer vision are called projective transformations (perspective projection is a projective transformation). As you may have guessed, such transformations do not necessarily preserve parallelism between lines. Not only you have learned how to create rotation matrices but we have also given you a way of visualizing what a matrix is: each row of the matrix represents one axis of a Cartesian coordinate system. The orientation (rotation), size (scale), and position (translation) of this coordinate system represents the transformation that will be applied to the points when they are multiplied by this matrix. The key idea is that points are originally defined in a certain coordinate system. If a point is attached to a local coordinate system $B$ (the matrix) and that we move, rotate, and translate that local coordinate system (i. e. the matrix), the point coordinates will not change in regard to the local coordinate system $B$. The point is somehow constrained to the transformation applied to the local coordinate system $B$. However, the coordinates of that point will change in the coordinate system $A$. Multiplying the point whose coordinates are expressed in regards to $A$ by the matrix $B$ will provide us with the point's new coordinates in the coordinate system $A$. What you need to remember is how to find the formula for the basic rotation matrices. That the order by which you multiply this basic matrices is important. And finally (and that's almost the most important) that a matrix can be seen as a local Cartesian system where each row of the matrix represents one axis of that local coordinate system. Such matrix is called an orientation matrix.  Transforming Points and Vectors : Even though translation seems to be the easiest linear operator that can be applied to point, we haven't mentioned it often in the previous chapter. Because to get the translation working with the theory of matrix multiplication, we need to make a change to the point structure that might confuse you slightly. As we mentioned in the last two chapters, a matrix-matrix multiplication can only work if the two matrices involved have a compatible size. That is if they have the size $m \times p$ and $p \times n$. Let's keep that in mind. Let's start from a $3 \times 3$ identity matrix. We know that a point multiplied by this matrix have its coordinates unchanged. Let's see what changes we need to bring to that matrix to handle translation. Translation on a point is nothing more than adding a number to each of its coordinates (these numbers can be positive or negative). For instance if we want to move the point $(1,1,1)$ to the coordinate $(2,3,4)$ we need to add values $1$,$2$ and $3$ respectively to each of the points' $x$, $y$ and $z$ coordinates. It is very simple. Note that from now on, we will keep looking at points and vectors as matrix of size $1 \times 3$. Let's get back to the code that transforms a point using a matrix. What do we need to get the rotation matrix extended so that it handles translation as well? We would need to be able to have a fourth term to the right that would encode translation. Now remember that we want to come up with a matrix that encodes scale, rotation, and translation. So, somehow we need to get $T_x$, $T_y$, $T_z$ to fit within the code of point-matrix multiplication (and store these three values somewhere in the matrix). Look at the first line for now. Note that to compute $x', we only use the coefficients ofthe matrix first column. If the column had four coefficients instead of three, then $T_x$ would be $M_{30}$. The same reasoning can be done with $T_y$ and $T_z$. However, this is assuming that our matrix now has the size $4 \times 3$ not $3 \times 3$ anymore. This is alright. We said that matrices could have any size. However, we know that matrix multiplication can be valid if their sizes are compatible. We try to multiply a point $1 \times 3$ matrix with a $4 \times 3$ matrix and theory tells us that this is not possible. What shall we do? The solution is simple. We will add one additional column to the point to turn it into a $1 \times 4$ matrix and set the fourth coefficient of this point to $1$. Our point now looks like this $(x,y,z,1)$. In computer vision, it is called a homogeneous point (or a point with homogeneous coordinates). With such a point we can easily encode translation in our matrix. This is the theory. In order to encode translation, scale and rotation in a matrix we need to deal with points that have homogeneous coordinates. But because the fourth value is always $1$ we never really explicitly define it in the code. We only define $x$,$y$,$z$ and assume that there is a fourth value. Our matrix is now a $4 \times 3$ matrix. So you may wonder, how do we go from $4 \times 3$ matrix to our final $4 \times 4$ matrix which is the form that is the most commonly used in computer vision? The fourth columns plays a role in perspective projection and for some other type of transformations that are not very common (such as the shear transformation), but generally it is simply set to $(0,0,0,1)$. What happens though when the coefficients of this column have different values than the default (we said its uncommon but it happens sometimes)? Before we can answer this question, we first need to learn a few things more about homogeneous points.  The Trick About Homogenous Points : Presenting a point as an homogeneous point is necessary to allow point-multiplication by $4 \times 4$ matrices however, in the code, this is only done implicitly, since as we have explained, $w$ is always $1$. But as we mentioned briefly, this fourth column is not always set to $(0,0,0,1)$ particularly when you deal with projection matrices (matrices that can project points to the screen). In these special cases, the result for $w'$ can be different than $1$ (which is intentional) but for this point to be usable as a Cartesian point, we need to normalize $w'$ back to $1$ by dividing it by itself which requires to divide the other coordinates ($x'$,$y'$ and $z'$) by $w'$ as well. As you can see we don't need to declare a $w$ coordinate in the Point's type. We can just compute a value for $w'$ on the fly as we assume implicitly that the point we are transforming is a Cartesian point which you can see as a homogeneous point whose $w$ coordinate is not declared explicitly (because it's always equal to 1). However, if the matrix we are multiplying the point with is a projection matrix for instance, the result of $w'$ might be different than $1$. In this particular caase, we need to normalize all the coordinates of $P'$ to set it back to $1$. Once this is done, we get a point which we can use in our Cartesian coordinate system again. All you need to remember is that generally, you will never have to care about homogeneous coordinates, expect when points are multiplied by a perspective projection matrix. However, you will actually probably not come across this issue if you work on a ray tracer, as this special type of matrix is not used in ray tracing. Transforming Vectors : Vectors somehow are simpler to transform than points. Vectors, as we said in the preamble of this lesson, represent direction whereas points represent position in space. As such vectors do not need to be translated because their position is in fact meaningless. With vectors we are only interested in the direction in which they point and eventually their length which is sometimes an information we need to solve geometric or shading problems. Vectors can be transformed like we transformed point but we can remove the part of the code that is responsible for the translation bit. Now that the matrix has size $4 \times 4$ we need to extend the size of the point by adding an extra coordinate. We can do this by implicitly treating points as homogeneous points but to continue using them in a Cartesian coordinate system (as Cartesian points) we need to be sure that $w$, this fourth coordinate is always set to $1$. Most of the time the matrices we use to transform a point will have their fourth column set to $(0,0,0,1)$ and with these matrices, the value of $w'$ should always be $1$. However, in special cases (projection matrix, shear transform) the value of $w'$ might be different than $1$ in which case you will need to normalize it (we divide $w'$ by itself) which requires to also divide the other transformed coordinates $x'$, $y'$, and $z'$ by $w'$. Matrices are not the only method to encode or store transformations. You can also for instance represent a rotation using a method proposed initially by Euler. The idea is to define a rotation in this casae as a vector and an angle representing a rotation around the vector. While uncommon, both techniques are used to solve problems in computer vision from time to time. Rotations in computer vision are also commonly done using quaternions. Matrices themselves have certain limitations especially when it comes to rotation by an angle greater than $360$ degrees. This can lead to a problem known as the gimbal lock. Matrices are also hard to interpolate which is often needed in rendering to compute the motion blur of objects. For this particular reason, quaternions are generally preferred though they are considered to be generally harder to understand.  Row Major and Column Major Vector : Earlier in this lession, we have explained that vectors (or points) can be written down as $1 \times 3$ matrices (one row, three columns). Note however that we could have also written them down as $3 \times 1$ matrices (three rows, one column). Technically, these two ways of expressing points and vectors as matrices are perfectly valid and choosing one mode or the other is just a matter of convention. In the first example, we have expressed our vector or point in what we call the row-major order: the vector (or point) is written as a row of three numbers. In the second example, we say that points or vectors are written in column-major order: we write the three coordinates of the vector or point vertically, as a column. Remember that we express points and vectors as matrices to multiply them by $3 \times 3$ transformation matrices (for the sake of simplicity we will work with $3 \times 3$ rather than $4 \times 4$ matrices). So what do we do? We move the point or vector to the right side of the multiplication. Note that the result of this operation is a transformed poitn written in the form of a $3 \times 1$ matrix. So we get a point to start with and we finish with a transformed point which is what we want. Problem solved. To summarize, when by convention we decide to express vectors or points in row-major order, we need to put the point on the left side of the multiplication and the $3 \times 3$ on the right inside of the multiplication sign. This is called in mathematics, a left or pre-multiplication. If you decide to write the vectors in column-major order, matrix needs to be on the left side of the multiplication and the vector or point on the right side. This is called a right or post-multiplication. Multiplying a point or a vector by a matrix should give us the same result whether we use row- or column-major order. If you use a 3D application to rotate a point by a certain angle around the $z$-axis, you expect the point to be in certain position after the rotation no matter what internal convention the developer used to represent points and vectors. Multiplying a row-major and column-major point (or vector) by the same matrix clearly wouldn't give us the same result. We would actually need to transpose the $3 \times 3$ matrix used in the column-major multiplication to be sure that $x'$,$y'$, and $z'$ are the same. In conclusion, going from row-major order to column-major order not only involves to swap the point or vector and the matrix in the multiplication but also to transpose the $3 \times 3$ matrix, to guarantee that both conventions give the same result (and vice versa). From these observations, we can see that any series of transformations applied to a point or a vector when a row-major convention is used can be written in sequential order. Imagine for instance that you wnat to translate point $P$ with matrix $T$ then rotate it around the $z$-axis with $R_z$ then around the $y$-axis with $R_y$. You can write:\$\$P' = P * T * R_z * R_y\$\$If you were to use a column-major notation you would need to call the transform in reverse order (which one might find counter-intuitive):\$\$P' = R_y * R_z * T * P\$\$Order of transformation when we use column-major matrices is more similar in mathematics to the way we write function evaluation and composition. Implication in Coding : There is another potentially very important aspect to take into consideration if you need to choose between row-major and column-major, but this has nothing to do really with the conventions themselves and how practical one is over the other. It has more to do with the computer and the way it works. Typically the implementation of a matrix are laid out contiguouosly in memory. In the world of computing, accessing elements from an array in a non-sequential order, is not necessarily a good thing. It actually potentially degrades the cache performance of the CPU. Applied to our matrix problem, accessing the coefficients of the matrix in non-sequential order can therefore be a problem. Assuming the CPU loads the requested float in the cache plus 3 floats next to it, our current implementation might lead to many cache misses, since the coefficients used to compute $x'$, $y'$ and $z'$ are 5 floats apart in the array. On the other hand, if you use a column-major order notation, computing $x'$ for instance requires to access the 1st, 2nd and 3rd element of the matrix. In conclusion, we can say that form a programming point of view, implementing our point- or vector-matrix multiplication using a column-major order convention might be better, performance wise, than the version using the row-major order convention.  Matrix Operations : Transpose : The transpose of a matrix $M$ is another matrix which we write using the following convention: $M^T$. We can describe the process of transposing a matrix in different ways. It can be seen as: reflecting $M$ over its main diagonal to obtain $M^T$, writing the rows of $M$ as the columns of $M^T$ or reciprocally, writing the columns of $M$ as the rows of $M^T$. The idea is to swap the rows and columns and since the operation can't be done in place we need to assign the result to a new matrix which is returned by the function. Transposing matrices can be useful when you want to convert matrices from a 3D application using row-major matrices to another using a column-major convention (and vice versa). Inverse : If the multiplying point $A$ by the matrix $M$ gives point $B$, multiplying a point $B$ the inverse of the matrix $M$ gives point $A$. In mathematics, a matrix inversion is usually written using the following notation:\$\$M^{-1}\$\$From this observation, we can write that:\$\$MM^{-1} = I\$\$where $I$ is the identity matrix. Multiplying a matrix by its inverse gives the identity matrix. We have mentioned the case of the orthogonal matrix which inverse can easily be obtained from computing its transpose. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors. Matrix inversion is an important process in 3D. We know that we can use point- or vector-matrix multiplication to convert points and vectors but it is sometimes useful to be able to move the transformed points or vectors back into the coordinate system in which they were originally defined into. It is often necessary for instance, to transform the ray direction and origin in object space to test for a primitive-ray intersection. If there is an intersection resulting hit point is in object space and needs to be converted back into world space to be usuable. Spherical Coordinates and Trigonometric Functions : Besides points, vectors, normals and matrices the last useful technique from linear algebra we will need to render images is to express vectors in terms of spherical coordinates. We could certainly render images without using them, but you will see that using them simplifies many problems especially when it comes to shading. This chapter is also a good opportunity to review trigonometric functions. Trigonometric Functions : Rendering a computer generated images is almost entirely a geometric problem so not understanding or using trigonometry for creating such images (and the phythagorean theorem) would be hard. Let's start to review the sine and cosine function as well as the way angles can be computed from 2D coordinates. Usually these functions are defined in regards to the unit circle (a circle of radius 1). When we draw a point $P$ on this unit circle, the $x$-coordinate of the point can be computed using the cosine of the angle subtended by the $x$-axis and a line that goes from the origin of the coordinate system to $P$. This angle is usually called $\theta$. Similarly, the sine of this angle gives the $y$-coordinate of the point $P$. Note that the angle $\theta$ is defined in radians. It will be easier to define the angles in degrees, but we will need to convert them internally to radians to use them in the C++ trigonometric functions $\theta_{radians} = \frac{\pi}{180} \theta_{degrees}$. Remember that a complete turn around the unit circle represents 360 degrees of $2\pi$. It is also important to remember that the cosine, sine and tangent functions are defined from a simple relationship between the edges of a right triangle (right-angle triangle). The tangent formula is interesting because to come back to our example using the unit circle, you can see that it can be computed using the ratio of $y$ over $x$. Another very useful function in computer vision is the arctangent which is the tangent inverse function. In other words, if you feed the arctangent function with the result of the tangent function you get $\theta$. In programming you can use the `atan` function but this function doesn't take the sign of the parameters $x$ and $y$ into account. To fix the issue, you need to use the C/C++ function `atan2` instead which takes into account the sign of the point's coordinates in the computation of the angle. Similarly to `atan2`, you can compute the inverse function of sine and cosine using `asin` and `acos`. Let's summarize all the functions we have talked about so far. \$\$\begin{aligned}\theta = \acos(P_x)\theta = \asin(P_y)\theta = \atan(P_y, P_x)\end{aligned}\$\$The interesting thing to note is that the angle returned by the `atan2` function is positive for counter-clockwise angles (upper half-plane, $y&gt;0$) and negative for clockwise angles (lower half-plane, $y&lt;0$). It produces results in the range $[-\pi, \pi]$.  Representing Vectors with Spherical Coordinates : So far we have learned hyow to represent vectors (as in directions) using Cartesian coordinates (with three values, one for each axis). It is also possible though to represent the same vectors with only two values. One to represent the angle between the vector and the vertical axis and one to represent the angle between the vector projected onto the horizontal plane and the right vector from the Cartesian coordinate system. The vertical angle is always called $\theta$ and the horizontal angle is always called $\phi$. No matter what you do and what you see in textbooks, we advise you to follow these rules which is about the only convention unanimously followed by the computer vision community. These angles should be expressed in radians. Note that $\theta$ lies within the range $[0:\pi]$ while $\phi$ varies in the range $[0: 2\pi]$. As such $\theta$ and $\phi$ can also be seen as coordinates and are called spherical coordinates. $V_r$, $V_u$ and $V_f$ correspond to the Cartesian coordinates of the vector in the Cartesian coordinate systems defined by the right, up and forward axes. Note that we haven't used the names $x$, $y$, $z$ for the axis for a reason we will explain soon. Also, we have always represented a normalized vector (unit length) but any vector of arbitrary length can be represented using spherical coordinates. The formal definition of spherical coordinates includes an additional term (usually denoted $r$ for radial distance) to represent the length of the vector combined with $\theta$ and $\phi$ which can also be called the polar and aximuth angles. Spherical coordinates are just another way of encoding vectors. They make this representation compact as only two numbers are used instead of three (if you don't care about the length of the vector) with the Cartesian coordinates (it can save memory in your program) and they will become most useful when we will talk about shading. The question now is how we convert a vector represented in Cartesian coordinates to spherical coordinates.  Conventions Again: $Z$ is Up! : The convention when it comes to represent vectors in mathematics and physics is to name the up vector as the $z$-axis and the right and forward vector respectively the $x$- and $y$-axis. And to make things easier, the convention is also to use a left-hand coordinate system. Having $z$-axis representing the up vector, is something we have already briefly mentioned. As you can see, this convention is different from the one we normally use (where the up axis is the $y$-axis) but unfortunately this notation is the norm and we will have to stick to it.  Creating an Orientation Matrix or Local Coordinate System : In this chapter, we will use what we have learned so far about coordinate systems and what they represent to build a local coordinate system (or frame) from a vector which can also be a normal. This technique is often used in the rendering pipeline as a way of converting point and vectors which are defined in one coordinate system to another. The idea is to let the normal at that point to become one of the axis of that local coordinate system (often aligned with the up vector, and let the tangent and bi-tangent of that point to become )Often a coordinate system is helpful because it can be easier to manipulate the coordinates of a vector rather than manipulating its magnitude and direction directly. When we express a vector in a coordinate system, we identify a vector with a list of numbers, called coordinates or components, that specify the geometry of the vector in terms of the coordinate system. We assume that you are familiar with the standard $(x,y)$ Cartesian coordinate system in the plane. Each point $p$ in the plane is identified with its $x$ and $y$ components: $p=(p_1,p_2)$. To determine the coordinates of a vector $a$ in the plane, the first step is to translate the vector so that its tail is at the origin of the coordinate system. Then, the head of the vector will be at some point $(a_1, a_2)$ in the plane. We call $(a_1, a_2)$ the coordinates or the components of the vector $a$. We often write $a \in \mahthbb{R}^2$ to denote that it can be described by two real coordinates.  Vectors in Three-Dimensional Space : If you switched the locations of the positive $x$-axis and positive $y$-axis, then you would end up having a left-handed coordinate system. With these axes any point $p$ in space can be assigned three coordinates $p=(p_1,p_2,p_3)$. Just as in two-dimensions, we assign of a vector $a$ by translating its tail to the origin and finding the coordinates of the point at its head. In this way, we can write the vector as $a=(a_1,a_2,a_3)$. We often write $a \in \mathbb{R}^3$ to denote that it can be described by three real coordinates. A representation of a vector $a=(a_1,a_2,a_3)$ in the three-dimensional Cartesian coordinate system. The vector $a$ is drawn as a green arrow with tail fixed at the origin. You can drag the head of the green arrow with tail fixed at the origin. Just as in two dimensions, we can also denote three-dimensional vectors in terms of the standard unit vectors, $i$, $j$, and $k$. These vectors are the unit vectors in the positive $x$, $y$, and $z$ direction, respectively. We can express any three-dimensional vector as a sum of scalar multiples of these unit vectors $a=(a_1,a_2,a_3) = a_1 i + a_2 j + a_3 k$. We can easily visualize two or three dimensions by drawing pictures of a plane or space. Going to higher dimension is easy with lists of numbers, though of course high-dimensional vectors are not easy to visualize. For many of us, this metaphor may hamper our efforts to delve into higher dimensions, as we are restrained by our experience of just three spatial dimensions in the world around us. It may be easier to think of a high dimensional vector as simply describing quantities of distinct objects. At first, it may seem that going beyond three dimensions is an exercise in pointless mathematical abstraction. to describe even the simplest objects, we will typically need more than three dimensions. It is challenging to develop mathematical models that cna realistically describe a physical system and yet keep the number of dimensions from becoming incredibly large. However, even if the center of a rigid object is specified, the object could also rotate. In fact, it can rotate in three different directions, such as the roll, pitch and yaw of an airplane. Consequently, we need six dimensions to specify the position of a rigid object: three to specify the location of the center of the object, and three to specify the direction in which the object is pointing.  The Dot Product : The dot product between two vectors is based on the projection of one vector onto another. Let's imagine we have two vectors $a$ and $b$, and we want to calculate how much of $a$ is pointing in the same direction as the vector $b$. We want a quantity that would be positive if the two vectors are pointing in similar directions, zero if they are perpendicular, and negative if the two vectors are pointing in nearly opposite directions. We will define the dot product between the vectors to capture these quantities. The answer to this question should not depend on the magnitude of $b$, only its direction. To sidestep any confusion caused by the magnitude of $b$, let's scale the vector so that it has length one. In other words, let's replace $b$ with the unit vector that points in the same direction as $b$. We'll call this vector $u$, which is defined by:\$\$y = \frac{b}{lVert b \rVert}\$\$The dot product of $a$ with unit vector $u$, denoted $a \cdot u$ is defined to be the projection of $a$ in the direction of $u$, or the amount that $a$ is pointing in the same direction as unit vector $u$. Let's assume for a moment that $a$ and $u$ are pointing in similar directions. Then, you can imagine $a \cdot y$ as the length of the shadow of $a$ onto $u$ if their tails were together and the sun was shining from a direction perpendicular to $u$. \$\$a \cdot y = \lVert a \rVert \cos \theta\$\$If $a$ and $u$ were perpendicular, there would be no shadow. That corresponds to the case when $\cos\theta = \cos \frac{\pi}{2} = 0$ and $a \cdot u = 0$. If the angle $\theta$ between $a$ and $u$ were larger than $\frac{\pi}{2}$, then the shadow wouldn't hit $u$. Since in this case $\cos\theta &lt; 0$, the dot product $a \cdot u$ is also negative. But we need to get back to the dot product $a \cdot b$, where $b$ may have a magnitude different than one. This dot product $a \cdot b$ should depend on the magnitude of both vectors $\lVert a \rVert$ and $\lVert b \rVert$, and be symmetric in those vectors. Hence, we don't want to define $a \cdot b$ to be exactly the projection of $a$ on $b$; we want it to reduce to this projection for the case when $b$ is a unit vector. We can accomplish this very easily: just plug the definition $u = \frac{b}{\lVert b \rVert}$ into our dot product definition of the equation above. This leads to the definition that the dot product $a \cdot b$ divided by the magnitude $\lVert b \rVert$ of $b$ is the projection of $a$ onto $b$. Then, we get a nice symmetric definition for the dot product $a \cdot b$. \$\$a \cdot b = \lVert a \rVert \lVert b \rVert \cos \theta\$\$The dot product of the vectors $a$ and $b$ when divided by the magnitude of $b$, is the projection of $a$ onto $b$. Notice how the dot product is positive for acute angles and negative for obtuse angles. The formula demonstrates that the dot product grows linearly with the length of both vectors and is commutative, $a \cdot b = b \cdot a$.  The Formula for the Dot Product in terms of Vector Components : The geometric definition of the dot product says that the dot product between two vectors $a$ and $b$ is \$\$a \cdot b = \lVert a \rVert \lVert b \rVert \cos \theta\$\$Although this formula is nice for understanding the properties of the dot product, a formula for the dot product in terms of vector components would make it easier to calculate the dot product between two given vectors. Since the standard unit vectors are orthogonal, we immediately conclude that the dot product between a pair fo distinct standard unit vectors is zero. The dot product between a unit vector and itself is also simple to compute. In this case, the angle is zero and $\cos\theta = 1$. Given that the vectors are all of length one, the dot products are \$\$i \cdot i = j \cdot j = k \cdot k = 1\$\$The second step is to calculate the dot product between two three-dimensional vectors \$\$a = (a_1, a_2, a_3) = a_1 i + a_2 j + a_3 k b = (b_1, b_2, b_3) = b_1 i + b_2 j + b_3 k\$\$To do this, we simply assert that for any three vectors $a$, $b$ and $c$, and any scalar $\lambda$, \$\$(\lambda a ) \cdot b = \lambda (a \cdot b) = a \cdot (\lambda b)(a+b) \cdot c = a \cdot c + b \cdot c\$\$These properties mean that the dot product is linear. Given this properties and the fact that the dot product is commutative, we can expand the dot product $a \cdot b$ in terms of components,\$\$a \cdot b = (a_1 i + a_2 j + a_3 k) \cdot (b_1 i + b_2 j + b_3 k)\$\$Since we know the dot product of unit vectors, we can simplify the dot product formula to\$\$ a \cdot b = a_1 b_1 + a_2 b_2 + a_3 b_3\$\$Given the geometric definition of the dot product along with the dot product formula in terms of components, we are ready to calculate the dot product of any pair of two- or three-dimensional vectors. The Cross Product : There are two ways to take the product of a pair of vectors. One of these methods of multiplication is the cross product, which is the subject of this page. The other multiplication is the dot product, which we discuss on another page.  The cross product is defined only for three-dimensional vectors. If $a$ and $b$ are two three-dimensional vectors, then their cross product, written as $a \times b$ and pronounced  a cross b  is another three-dimensional vector. We define the cross product vector $a \times b$ by the following three requirements: $a \times b$ is a vector that is perpendicular to both $a$ and $b$.  The magnitude (or length) of the vector $a \times b$, written as $\lVert a \times b \rVert$ is the area of the parallelogram spanned by $a$ and $b$.  The direction of $a \times b$ is determined by the right-hand rule. (This means that if we curl the fingers of the right hand from $a$ to $b$, then the thumb points in the direction of $a \times b$. ) The below figure illustrates how, using trigonometry, we can calculate that area of the parallelogram spanned by $a$ and $b$ is \$\$\lVert a \rVert \lVert b \rVert \sin \theta\$\$where $\theta$ is the angle between $a$ and $b$. This formulat shows that the magnitude of the cross product is largest when $a$ and $b$ are perpendicular. On the other hand, if $a$ and $b$ are parallel or if either vector is the zero vector, then the cross product is the zero vector (It is a good thing that we get the zero vector in these cases so that the above definition still makes sense. If the vectors are parallel or one vector is the zero vector, then there is not a unique line perpendicular to both $a$ and $b$. But since there is only one vector of zero length, the definition still uniquely determines the cross product. )You can also verify that the applet demonstrates $b \times a = - a \times b$ and $a \times a = 0$, which are important properties of the cross product. The geometric definition of the cross product is good for understanding the properties of the cross product. However, the geometric definition isn't so useful for computing the cross product of vectors. For computations, we will want a formula in terms of the components of vectors. We start by using the geometric definition to compute the cross product of the standard unit vectors. The parallelogram spanned by any two of these standard unit vectors is a unit square, which has area one. Hence, by the geometric definition, the cross product must be a unit vector. Since the cross product must be perpendicular to the two unit vectors, it must be equal to the other unit vector or the opposite of that unit vector. \$\$i \times j = kj \times k = ik \times i = j\$\$By remembering that $b \times a = - a \times b$, you can infer that \$\$j \times i = -k k \times j = -ii \times k = -j\$\$Finally, the cross product of any vector with itself is the zero vector ($a \times a = 0$). In particular, the cross product of any standard unit vector with itself is the zero vector. With the exception of the two special properties mentioned above ($b \times a = - a \times b$, and $a \times a = 0$), we'll just assert that the cross product behaves like regular multiplication. It obeys the following properties:\$\$(ya) \times b = y (a \times b) = a \times (yb)a \time (b+c) = a \times b + a \times c(b+c) \times a = b \times a + c \times a\$\$where $a$, $b$, and $c$ are vectors in $\mathbb{R}^3$ and $y$ is a scalar. (These properties mean that the cross product is linear). We can use these properties, along with the cross product of the standard unit vectors, to write the formula for the cross product in terms of components. We write the components of $a$ and $b$ as:\$\$a = (a_1, a_2, a_3) = a_1 i + a_2 j + a_3 kb = (b_1, b_2, b_3) = b_1 i + b_2 j + b_3 k\$\$First, we'll assume that $a_3 = b_3 = 0$. (Then, the manipulations are much easier. )\$\$a \times b = (a_1b_2 - a_2 b_1)k \$\$Writing the result as a determinant, as we did in the last step, is a handy way to remember the result.  Matrices : The structure of a matrix allows us to define a fundamental operation on matrices: multiplication. This multiplication forms the basis of linear algebra. In particular, this matrix multiplication allows matrices to represent linear transformations (or linear functions) that transform vectors into other vectors. (A simple example of a linear transformation is the rotation of a vector. ) Other uses of matrices involve calculating their determinant.  Vectors as Matrices : When we view vectors as matrices, we actually view them as a rotated version of the standard form, writing an $n$-dimensional vector as a $n \times 1$ column matrix.  Matrix-Vector Product : To define multiplication between a matrix $A$ and a vector $x$ (i. e. , the matrix-vector product), we need to view the vector as a column matrix. One takes the dot product of $x$ with each rows of $A$. The first component of the matrix-vector product is the dot product of $x$ with the first row of $A$. In fact, $A$ has only one row, the matrix-vector product is really a dot product in disguise. Matrix-Matrix Product : Since we view vectors as column matrices, the matrix-vector product is simply a special case of the matrix-matrix product (i. e. , a product between two matrices). Just like for the matrix-vector product, the product $AB$ between matrices $A$ and $B$ is defined only if the number of columns in $A$ equals the number of rows in $B$. Each column of $C$ is the matrix-vector product of $A$ with the respective column of $B$.  The Transpose of a Matrix : The transpose of a matrix is simply a flipped version of the original matrix. We can transpose a matrix by switching its rows with its columns. We denote the transpose of matrix $A$ by $A^T$. We can take a transpose of a vector as a special case. Since an $n$-dimensional vector $x$ is represented by an $n \times 1$ column matrix, the transpose of $x^T$ is a $1 \times n$ row matrix. Although we won't typically write dot product as $x^T y$, we end up with a matrix multiplication equivalent to the familiar dot product $x \cdot y$. Moreover, you can view this dot product as forming the building block for the general matrix multiplication.  Linear Transformations : A linear transformation (or a linear map) is a function $T: \mathbb{R}^n \rightarrow \mathbb{R}^m$ that satisfies the following properties:\$\$T(x+y) = T(x) + T(y)T(ax) = aT(x)\$\$for any vectors $x,y \in \mathbb{R}^n$ and any scalar $a \in \mathbb{R}$. It is simple enought to identify whether or not a given function $f(x)$ is a linear transformation. Just look at each component of $f(x)$. If each of these terms is a number times one of the components of $x$, then $f$ is a linear transformation. The condition for a linear transformation is stronger than the condition one learns in grade school for a funciton whose graph is a line. A single variable function $f(x) = ax+b$ is not a linear transformation unless its $y$-intercept $b$ is zero. A useful feature of a linear transformation is that there is a one-to-one correspondence between matrices and linear transformations, based on matrix-vector multiplication.  Matrices and Linear Transformations : Given any $m \times n$ matrix $B$, we can define a function $g: \mathbb{R}^n \rightarrow \mathbb{R}^m (note the order of $m$ nad $n$ switched) by $g(x) = Bx$, where $x$ is an $n$-dimensional vector. In this way, we can associate with every matrix a function. What about going the other way around? Given some function, say $g: \mathbb{R}^n \rightarrow \mathbb{R}^m$, can we associate with $g(x)$ some matrix? We can only if $g(x)$ a a special kind of function called a linear transformation. The function $g(x)$ is a linear transformation if each term of the component of $g(x)$ is a number of times on of the variables. The important conclusion is that every linear transformation is associated with a matrix and vice versa.  Determinants : Many of the main uses for matrices in multivariate calculus involve calculating something called the determinant. It's useful, for example, to calculate the cross product as well as a change of variables. The determinant of a matrix is defined only for square matrices, i. e. , $n \times n$ matrices with the same number of rows and columns. The determinant can be viewed as a funciton whose input is a square matrix and whose output is a number. The determinant of a $1 \times 1$ matrix is that number itself. We calculate the determinant of a $3 \times 3$ matrix in the exact same way. We proceed along the first row and multiply each component by the determinant of the submatrix formed by ignoring that component's row andcolumn. Through this procedure we calculate three terms, one for $a$, one for $b$, and one for $c$. Each of these terms is added together, only with alternating signs (the first term - the second term + the third term). The above procedure generalizes to large determinants, but $3 \times 3$ determinants will be enough for multivariate calculus. However, note that in this case, the vertical lines do not mean absolute value. The determinant can be negative. In mathematics, we like to use the same symbols to mean different things, which is okay as long as it's clear from context. Since the absolute value of an array of numbers is meaningless, the notation is unambiguous.  The Relationships between $ and Area or Volume : From the properties of the geometric definition of the cross product, we can discover a link between $2 \times 2$ determinants and area and a link between $3 \times 3$ determinants and volume. Determinants and Linear Transformations : A linear transformation $T: \mathbb{R}^n \rightarrow \mathbb{R}^m$ is a mapping from $n$-dimensional space to $m$-dimensional space. Such a linear transformation can be associated with an $m \times n$ matrix. If we restrict ourselves to mappings within the same space, such as $T: \mathbb{R}^n \rightarrow \mathbb{R}^n$, then $T$ is associated with a square $n \times n$ matrix. One can calculate the determinant of such a square matrix, and such determinants are related to area or volume. It turns out that the determinant of a matrix tells us important geometrical properties of its associated linear transformation.  One-Dimensional Linear Transformations : A one-dimensional linear transformation is a function $T(x) = ax$ for some scalar $a$. To view the one-dimensional case in the same way we view higher dimensional linear transformations, we can view $a$ as a $1 \times 1$ matrix. The determinant of the $1 \times 1$ matrix is just the numbwer $a$ itself. Although this case is very simple, we can gather some intuition about linear maps by first looking at this case. An example one-dimensional linear transformation is the function $T(x) = 3x$. We could visualize this function by its graph, which is a line through the origin with slope 3. However, instead, let's view it as a mapping from the real line $R$ back on to the real line $R$. In this case, we can think of the function as $x' = T(x)$, which maps the number $x$ on the $x$-axis to the new number $T(x)$ on the $x'$-axis. $T$ takes the number 1 and maps it to $3$. We also use the language that $3$ is the image of $1$ under the mapping $T$. We can summarize this mapping by looking how $T$ maps an interval of numbers. For example, $T$ maps the interval $[0,1]$ to the interval $[0,3]$, as illustrated by the following figure. The fact that the determinant of the matrix associated with $T$ is 3 means that $T$ stretches objects so that their length is increased by a factor of 3. $T$ preserves the orientation of objects: in both the interval $[0,1]$ and its image $[0,3]$, red points are to the right of green points. In general, the linear transformation $T(x) = ax$ stretches objects to change their length by a factor of $\lvert a \rvert$. If $a$ is positive, $T$ preserves the orientation; if $a$ is a negative, $T$ reverse orientaiton. We will obtain similar conclusions for higher-dimensional lilnear transformation in terms of the determinant of the associated matrix.  Two-Dimensional Linear Transformations : A two-dimensional linear transformation is a function $T: \mathbb{R}^2 \rightarrow \mathbb{R}^2$ of the form \$\$T(x,y) = (ax+by, cx+dy)\$\$where $a,b,c$, and $d$ are numbers defining linear transformation. We can write this more succinctly as $T(x) = Ax$, where $x = (x,y)$ and $A$ is the $2 \times 2$ matrix containing the constants that define the linear transformation. We will view $T$ as mapping objects from the $xy$-plane onto an $x'y'$-plane: (x',y') = T(x,y)$. as in the one-dimensional case, the geometric properties of this mapping will be reflected in the determinant of the matrix $A$ associated with $T$. To begin, we look at the linear transformation $T(x,y)$. As with all linear transformations, it maps the origin $x=(0,0)$ back to the origin $(0,0)$. We can get a feel for the behavior of $T$. We can get a feel for the behavior of $T$ by looking at its actions on the standard unit vectors, $i=(1,0)$ and $j=(0,1)$.  References : scratchpixel "
    }, {
    "id": 25,
    "url": "https://sally20921.github.io/gan.html",
    "title": "All About Training GAN",
    "body": "2021/09/14 -  1.  Generative Adversarial Networks : Ultimately, if everything goes well, the generator learns the true distribution of the training data and becomes really good at generating fake images. The discriminator should not be able to distinguish between real and fake images. Another way to look at the GAN setup is that the discriminator is trying to guide the generator by telling what real images look like. The two networks try to achieve what is called the Nash Equilibrium with respect to each other.  2.  Training GANs : GAN networks are a dynamic system where the optimization process is seeking not a minimum, but a equilibrium between two forces. There are no good objective metrics for evaluating whether a GAN is performing well during training, e. g. reviewing the loss is not sufficient. Instead the best approach is to visually inspect the generated examples and use subjective evaluation. Other quantitative measures, such as Inception Score (IS) or Frechet Inception Distance (FID) rely on pretrained models with a specific set of object classes. They lack an upper bound (which means hypothetically the highest possible score is infinity).  2. 1 Look at the Loss : In a discriminative model,the loss measures the accuracy of the prediction and we use it to monitor the progress of training. However, the loss in GAN measures how well we are doing compared with our opponent. Often, the generator cost increases but the image quality is actually improving. If you see the discriminator loss rapidly approaching, there is probably no chance of recovery and it is time to change something.  2. 1 Look at the Gradients : Monitor the gradients along with the losses in the networks. These can give you a good idea about the progress of training and can even help in debugging if things are not really working well. Ideally, the generator should receive large gradients early in the training because it needs to learn how to generate real-looking data. The discriminator on the other hand does not always get large gradients early on, because it can easily distinguish real and fake images. If the gradients at the layer of generator are too small, learning might be slow or not happening at all. The generator should get large gradients early on and the discriminator getting consistently high gradients at the top layer once the generator has been trained enough.  3. Detecting GAN Failure Modes : The reason why GANs are difficult to train is that both generator and the discriminator are trained simultaneously in a zero-sum game. This means that improvements to one model come at the expense of the other model. The goal of training two models involves finding a point of equilibrium between the two competing concerns. It also means that everytime the parameters of one model are updated the nature of the optimization problem that is being solved is updated as well. The technical challenge of training two competing neural networks at the same time is that they can fail to converge.  Convergence Failure The fact that GANs are composed by two networks, and each of them has its loss function leads to GANs unstability. In GAN architecture, the discriminator tries to minimize a cross-entropy while the generator tries to maximize it. When discriminator confidence is high and the discriminator starts to reject the samples that are produced by the generator, generator's gradient vanishes. This scenario happens when the generator score reaches near zero and the discriminator score reaches near one. The discriminator is overpowering the generator. If the score does not recover from these values for many iterations, it is better to stop training.  Mode Collapse  Mode collapse is when the GAN produces a small variety of images with many duplicates. This happens when the generator is unable to learn a rich feature representation because it learns to associate similar outputs to multiple different inputs. The most promising way to check for mode collapse is to inspect the generated images. If there is little diversity in the output and some of them are almost identical, there is likely mode collapse. If you observe this happening, you should try to increase the ability of the generator to create more diverse outputs or impair the discriminator by randomly giving false labels to real images. Another type of behavior you should look out for is when the generator oscillates between generating specific examples in the domain. They progress from generating one kind of sample to generating another kind of sample without eventually reaching equilibrium.  Diminisheed Gradient  This situation happens when the discriminator gets too successful that the generator gradient vanishes and learns nothing. Lessons I Learned : Use a batch size smaller than or equal to 64. In my experience, using bigger batch sizes often hurt the performance. I suspect it fuels the problem of discriminator getting too good at discriminating the real and fake images, since large batch size means providing a lot of examples to train on.  Add noise to both real and synthetic data.  It is well known that making the training of discriminator more difficult is beneficial for the overall stability. Adding noise increases the complexity of the discriminator training and stabilizes the data distribution of the two competing networks.  Use Label Smoothing If the label for real images is set to 1, change it to a lower value like 0. 9. This solution discourages the discriminator from being overconfident.  Different learning rates for the generator and discriminator a. k. a. Two Time-Scale Update Rule In my experience, choosing a higher learning rate for the discriminator(i. e. 0. 0004) and a lower one(i. e. 0. 0001) for the generator works well in practice. I guess the reason is that the generator has to make small steps to fool the discriminator so it does not choose fast but not precise solutions to win the adversarial game.  Use some kind of normalization method For me, applying Spectral Normalization, a particular kind of normalization applied on the convolutional kernels, greatly helped the stability of training. I learned that hyperparameter tuning takes a lot of time and patience especially for training GANs. "
    }, {
    "id": 26,
    "url": "https://sally20921.github.io/extrinsic.html",
    "title": "Dissecting the Camera Matrix (Part 2)",
    "body": "2021/09/14 -  Overview of the Camera Calibration Parameters The Extrinsic Camera Matrix : The extrinsic matrix takes the form of a rigid transformation matrix: a $3 \times 3$ rotation matrix in the left-block, and $3 \times 1$ translation column-vector in the right. $$ \begin{bmatrix}\begin{array}{ccc|c} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_1  r_{21} &amp; r_{22} &amp; r_{23} &amp; t_2  r_{31} &amp; r_{32} &amp; r_{33} &amp; t_3\end{array}\end{bmatrix} $$ It is common to see a version of this matrix with extra row of $(0,0,0,1)$ added to the bottom. This makes the matrix square, which allows us to further decompose this matrix into a rotation followed by translation: $$ \begin{bmatrix}\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; t_1 0 &amp; 1 &amp; 0 &amp; t_2 0 &amp; 0 &amp; 0 &amp; t_3 \hline0 &amp; 0 &amp; 0 &amp; 1\end{array}\end{bmatrix} \times \begin{bmatrix}\begin{array}{ccc|c}r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \hline0 &amp; 0 &amp; 0 &amp; 1\end{array}\end{bmatrix} $$ The matrix describes how to transform points in world coordinates to camera coordinates. The important thing to remember about the extrinsic matrix is that it describes how the world is transformed relative to the camera . This if often counter-intuitive, because we usually want to specify how the camera is transformed relative to the world .  Building the Extrinsic Matrix from Camera Pose : Like I said before, it is often more natural to specify the camera‚Äôs pose directly rather than specifying how world points should transform to camera coordinates . Luckily, building an extrinsic camera matrix this way is easy: just build a rigid transformation matrix that describes the camera‚Äôs pose and then take its inverse . $$ \begin{bmatrix}\begin{array}{c|c}R &amp; t 0 &amp; 1 \end{array}\end{bmatrix} = \begin{bmatrix}\begin{array}{c|c}R_c &amp; C 0 &amp; 1 \end{array}\end{bmatrix}^{-1} $$ Let $C$ be a column vector describing the location of the camera-center in world coordinates, and let $R_c$ be the rotation matrix describing the camera‚Äôs orientation with respect to the world coordinate axes. Then extrinsic matrix is obtained by inverting the camera‚Äôs pose matrix.  Algebraically a rotation matrix in $n$-dimensions is a $n \times n$ special orthogonal matrix, i. e. an orthogonal matrix whose determinant is 1.  We can define matrix $R$ that rotates in the $xy$-Cartesian plane counterclock-wise through an angle $\theta$ about the origin of the Cartesian system as follows:\$\$R = \begin{bmatrix}\cos\theta &amp; -\sin\theta \\\sin\theta &amp; \cos\theta\end{bmatrix}\$\$ The set of all rotation matrices form a group, known as the special orthogonal group. The inverse of a rotation matrix is its transpose, which is also a rotation matrix. \$\$\displaylines{R^T = R^{-1} \\det(R) = 1}\$\$ the extrinsic matrix is obtained by inverting the camera's pose matrix We here use the fact that the inverse of a rotation matrix is its transpose, and inverting a translation matrix simply negates the translation vector. Relationship between the extrinsic matrix parameters and the camera‚Äôs pose is straightforward: $$\displaylines{R = R^T_c t = -RC}$$ References :  ksimek blog prateekvjoshi blog "
    }, {
    "id": 27,
    "url": "https://sally20921.github.io/pytorch.html",
    "title": "Advanced PyTorch: Things You Didn't Know",
    "body": "2021/09/12 -  Flatten Operation for a Batch of Image Inputs to a CNN : Flattening specific tensor axis is often required with CNNs because we work with batches of inputs opposed to single inputs. A tensor flatten operation is a common operation inside convolutional neural networks. This is because convolutional layer outputs that are passed to fully connected layers must be flattened out so that the fully connected layer can accept them as the input. A flatten operation is a specific type of reshaping operation where by all of the axes are smooshed or squashed together. To flatten a tensor, we need to have at least two axes. This makes it so that we are starting with something that is not already flat. For example, in the MNIST dataset, we will look at an handwritten image of eight. This image has 2 distinct dimensions, height and width. The height and width are $18 \times 18$ respectively. These dimensions tell use that this is a cropped image becaue the MNIST dataset contains $28 \times 28$ images. Let‚Äôs see how these two axes of height and width are flattened out into a single axis of length 324 (c. f. 324 what we get when multiplying 18 with 18).  Flattening Specific Axes of a Tensor : Tensor inputs to a convolutional neural network typically have 4 axes, one for batch size, one for color channels, and one each for height and width. $$[B,C,H,W]$$ Suppose we have the following three tensors: t1 = torch. tensor([  [1,1,1,1],  [1,1,1,1],  [1,1,1,1],  [1,1,1,1]])t2 = torch. tensor([  [2,2,2,2],  [2,2,2,2],  [2,2,2,2],  [2,2,2,2]])t3 = torch. tensor([  [3,3,3,3],  [3,3,3,3],  [3,3,3,3],  [3,3,3,3]])Each of these has a shape of $4 \times 4$, so we have three rank-2 tensors. For our purpose, we‚Äôll consider these to be three $4 \times 4$ images that we will use to create a batch that can be passed to a CNN. Batches are represented using a single tensor, so we‚Äôll need to combine these three tensors into a single larger tensor that has 3 axes instead of 2. t = torch. stack((t1, t2, t3))t. shape &gt; torch. Size([3,4,4])Here, we used the stack() method to concatenate our sequence of tensors along a new axis. Since we have three tensors along a new axis, we know that the length of this axis should be 3. At this point, we have a rank-3 tensor that contains a batch of three $4 \times 4$ images. All we need to do now to get this tensor into a form that a CNN expects is add an axis for the color channels. We basically have an implicit single color channel for each of these image tensors, so in practice, these would be grayscale images. torch. reshape(3,1,4,4)Notice how the additional axis of length 1 doesn‚Äôt change the number of elements in the tensor. This is because the product of the components values doesn‚Äôt change when we multiply by one. The first axis has 3 elements. Each element of the first axis represents an image. For each image, we have a single color channel on the channel axis. Each of these channels contain 4 arrays that contain 4 numbers or scalar components.  Flattening the Tensor Batch : Let‚Äôs see how to flatten images in this batch. Remember the whole batch is a single tensor that will be passed to the CNN, we don‚Äôt want to flatten the whole thing We only want to flatten the image tensors within the batch tensor. For example, if we do the following operations on t: t. flatten() &gt;&gt; tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,  2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])# this is the same operation as t. flatten()t. reshape(-1)What I want you to notice about this output is that we have flattened the entire batch, and this smashes all the batches together into a single axis. The flattened batch won‚Äôt work well inside our CNN because we need individual predictions for each image within our batch tensor, and now we have a flattened mess. The solution here, is to flatten each image while still maintaining the batch axis . This means we want to flatten only part of the tensor . We want to flatten the color channel axis with the height and width axes.  The Axes that Need to be Flattened: $[C,H,W]$ This can be done with PyTorch‚Äôs built in flatten() function. t. flatten(start_dim=1). shape&gt;&gt; torch. Size([3,16])t. flatten(start_dim=1)&gt;&gt; [  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]])Notice how we specified the start_dim parameter. This tells the flatten() method which axis it should start the flatten operation. Now we have a rank-2 tensor with three single color channel images that have been flattened out into 16 pixels.  Flattening an RGB Image : If we flatten an RGB image, what happens to the color? Each color channel will be flattened first, then the flattened channels will be lined up side by side on a single axis of the tensor. For example, we build an RGB image tensor like the following code: r = torch. ones(1,2,2)g = torch. ones(1,2,2)+1b = torch. ones(1,2,2)+2img = torch. cat((r,g,b),dim=0)img. shape&gt;&gt; torch. Size([3,2,2])By flattening the image tensor, this is how it is going to look like. img. flatten(start_dim=0)&gt;&gt; tensor([1. , 1. , 1. , 1. , 2. , 2. , 2. , 2. , 3. , 3. , 3. , 3. ]) Broadcasting and Element-Wise Operations with PyTorch : Remember, all these rules apply to PyTorch Tensors! Python built-in types such as list will not behave this way. Element-Wise Operations : An element-wise operation is an operation between two tensors that operates on corresponding elements within the respective tensors. Two elements are said to be corresponding if the two elements occupy the same position within the tensor. The position is determined by the indexes used to locate each element. Therefore, we can deduce that tensors must have the same shape in order to perform an element-wise operation.  Broadcasting Tensors : Broadcasting describes how tensors with different shapes are treated during element-wise operations. For example, suppose we have the following two tensors: t1 = torch. tensor([[1,1],[1,1]],dtype=torch. float32)t1. shape&gt;&gt; torch. Size([2,2])t2 = torch. tensor([2,4], dtype=torch. float32)t2. shape&gt;&gt; torch. Size([2])What will be the result of this two tensors‚Äô element-wise addition operation? Even though these two tensors have differing shapes, the element-wise operation is possible, and broadcasting is what makes the operation possible. The lower rank tensor t2 will be transformed via broadcasting to match the shape of the higher rank tensor t1, and the element-wise operation will be performed as usual. The concept of broadcasting is the key to understanding how this operation will be carried out. We can check the broadcast transformation using the broadcast_to() numpy function. np. broadcast_to(t2. numpy(), t1. shape)&gt;&gt; array([[2. , 4. ],    [2. , 4. ]], dtype=float32)t1 + t2&gt;&gt; tensor([[3. , 5. ],    [3. , 5. ]])When do we actually use broadcasting? We often need to use broadcasting when we are preprocessing and especially during normalization routines.  Element-Wise Operation Applies to Comparision and Functions : Comparison operations are also element-wise operations. For a given comparison operation between two tensors, a new tensor of the same shape is returned with each element containing torch. bool value of True or False. It is also fine to assume that the function is applied to each element of the tensor.  there are other ways to refer to element-wise operations, such as component-wise or point-wise Argmax and Reduction Operations for Tensors : Now, we will focus in on the frequently used argmax() function, and we‚Äôll see how to access the data inside our tensors.  Tensor Reduction Operation : A reduction operation on a tensor is an operation that reduces the number of elements contained within the tensor. Reduction operations allow us to perform operations on element within a single tensor. Let‚Äôs look at an example. Suppose we have the following rank-2 tensor: t = torch. tensor([[0,1,0],[2,0,2],[0,3,0]],dtype=torch. float32)t. sum()&gt;&gt; tensor(8. )t. numel()&gt;&gt; 9t. sum(). numel()&gt;&gt; 1The sum of our tensor‚Äôs scalar components is calculated using the sum() tensor method. The result of this call is a scalar-valued tensor . Since the number of elements have been reduced by the operation, we can conclude that the sum() method is a reduction operation. Other common reduction functions include t. sum(), t. prod(), t. mean() or t. std(). All of these tensor methods reduce the tensor to a single element scalar valued tensor by operating on all the tensor‚Äôs elements. Reduction operations in general allow us to compute aggregate values across data structures. But do reduction operations always reduce to a tensor with a single element? The answer is no. In fact, we often reduce specific axes at a time. This process is important.  References : deeplizard "
    }, {
    "id": 28,
    "url": "https://sally20921.github.io/no-bullshit.html",
    "title": "Guide to Linear Algebra (Part 1)",
    "body": "2021/09/09 -  Computational Linear Algebra : This chapter covers the computational aspects of performing matrix calculations. Understanding matrix computations is important because all later chapters depend on them. Suppose we‚Äôre given a huge matrix $ A \in R^{n \times n} $ with $ n=1000 $. Hidden behind the innocent-looking mathematical notation of the matrix inverse $A^{-1}$, the matrix product $AA$, and the matrix determinant $ | A |$, lie monster coputations involving all the $1000 \times 1000 = 1$ million entries of the matrix $A$. Millions of arithmetic operations must be performed, so I hope you have at least a thousand pencil ready! Okay, calm down. I won‚Äôt actually make you calculate millions of arithmetic operations. In fact, to learn linear algebra, it is sufficient to know how to carry out calculations with $3 \times 3$ and $4 \times 4$ matrices. Even for such moderately sized matrices, computing products, inverses, and determinants by hand are serious computational tasks. If you‚Äôre ever required to take a linear algebra final exam, you need to make sure you can do these calculations quickly. Even if no exam looms in your imminent future, it‚Äôs important to practice matrix operations by hand to get a feel for them. This chapter will introduce you to the following computational tasks involving matrices: Gauss-Jordan elimination Suppose we're trying to solve two equations in two unknowns $x$ and $y$:\$\$ \displaylines{ax+by = c \\\dx+ ey= f}\$\$If we add $\alpha$\times the first equation to the second equation, we obtain an equivalent system of equations:\$\$\displaylines{ax + by = c \\\(d + \alpha a)x + (e + \alpha b)y = f + \alpha c}\$\$This is called a row operation : we added $\alpha$-times the first row to the second row. Row operations change the coefficient of the system of equations, but leave the solution unchanged. Gauss-Jordan elimination is a systematic procedure for solving systems of linear equations using row operations.  Matrix product The product $AB$ between matrices $A \in \mathbb{R}^{m \times l}$ and $B \in \mathbb{R}^{l \times n}$ is the matrix $C \in \mathbb{R}^{m \times n}$ whose coefficients $c_{ij}$ are defined by the formula $c_{ij} = \sum_{k=1}^{l}a_{ik}b_{kj}$ for all $i \in \lbrack 1, \dots, m \rbrack $ and $j \in \lbrack 1, \dots, n \rbrack $. We'll soon unpack this formula and learn about its intuitive interpretation: that computing $C = AB$ is computing all the dot products between the rows of $A$ and the columns of $B$.  Determinant The determinant of a matrix $A$, denoted $|A|$ is an operation that gives us useful information about the linear independence of the rows of the matrix. The determinant is connected to many notions of linear algebra: linear independence, geometry of vectors, solving systems of equations, and matrix invertibility. We'll soon discuss these aspects.  Matrix inverse We'll build upon our knowledge of Gauss-Jordan elimination, matrix products, and determinants to derive three different procedures for computing the matrix inverse $A^{-1}$. Reduced Row Echelon Form : In this section, we‚Äôll learn to solve systems of linear equations using the Gauss-Jordan elimination procedure. A system of equations can be represented as a matrix of coefficients. The Gauss-Jordan elimination procedure converts any matrix into its  reduced row echelon form (RREF) . We can easily find the solution (or solutions of the system of equations from the RREF. Listen up: the material covered in this section requires your full on, caffeinated attention, as the procedures you‚Äôll learn are somewhat tedious. Gauss-Jordan elimination involves many repetitive mathematical manipulations of arrays of numbers. It‚Äôs important you hang in there and follow through the step-by-step manipulations, as well as verify each step I present on your own with pen and paper.  Solving Equations : Suppose you‚Äôre asked to solve the following system of equations: $$\displaylines{1x_1 + 2x_2 = 5 \3x_1 + 9x_2 = 21}$$ The standard approach is to use one of the equation-solving tricks we learned to combine the equations and find the values of the two unknowns $x_1$ and $x_2$. Observe that the names of the two unknowns are irrelevant to the solution of the system of equations. Indeed, the solution $(x_1, x_2)$ to the above system of equations is the same as the solution $(s,t)$ to the system of equations $$\displaylines{1s+ 2t = 5 \3s+ 9t = 21}$$ The important parts of a system of linear equations are the coefficients in front of the variables and the constants on the right-hand side of each equation.  Augmented Matrix : The system of linear equations can be written as an augmented matrix : $$\begin{pmatrix} 1 &amp; 2 &amp;\bigm | &amp; 5 \        3 &amp; 9 &amp;\bigm | &amp; 21\end{pmatrix}$$ The first column corresponds to the coefficients of the first variable, the second column is for the second variable, and the last column corresponds to the constants of the right-hand side. It is customary to draw a vertical line where the equal signs in the equations would normally appear. This line helps distinguish the coefficients of the equations from the column of constants on the right-hand side. Once we have the augmented matrix, we can simplify it by using row operations (which we‚Äôll discuss shortly) on its entries. After simplification by row operations, the augmented matrix will be transformed to $$\begin{pmatrix}1 &amp; 0 &amp;\bigm | &amp; 5 \0 &amp; 1 &amp;\bigm | &amp; 2\end{pmatrix} $$ which corresponds to the system of equations $$\displaylines{x_1 = 1 \x_2 = 2}$$ This is a trivial system of equations; there is nothing left to solve and we can see that the solutions are $x_1 = 1$ and $x_2 = 2$. This example illustrates the general idea of the Gauss-Jordan elimination procedure for solving the system of equations by manipulating an augmented matrix.  Row Operations : We can manipulate the rows of an augmented matrix without changing its solutions. We‚Äôre allowed to perform the following three types of row operations: Add a multiple of one row to another row Swap the position of the two rows Multiply a row by a constant Let‚Äôs trace the sequence of row operations needed to solve the system of equations $$\displaylines{x_1 + 2x_2 = 5 \3x_1 + 9x_2 = 21}$$ starting from its augmented matrix: $$\begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \3 &amp; 2 &amp;\bigm | &amp; 21\end{pmatrix}$$  As a first step, we eliminate the first variable in the second row by subtracting three times the first row from the second row. $$ \begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \0 &amp; 3 &amp;\bigm | &amp; 6\end{pmatrix}$$ We denote this row operation as $R_2 \leftarrow R_2 - 3R_1$.  To simplify the second row, we divide it by 3 to obtain$$ \begin{pmatrix}1 &amp; 2 &amp;\bigm | &amp; 5 \0 &amp; 1 &amp;\bigm | &amp; 2 \end{pmatrix}$$ This row operation is denoted $R_2 \leftarrow \frac{1}{3}R_2$.  The final step is to eliminate the second variable from the first row. We do this by subtracting two times the second row from the first row $R_1 \leftarrow R_1 - 2 R_2$:$$\begin{pmatrix}1 &amp; 0 &amp;\bigm | &amp; 1 \0 &amp; 1 &amp;\bigm | &amp; 2\end{pmatrix}$$ We can now read off the solution: $x_1 =1$ and $x_2 = 2$. Note how we simplified the augmented matrix through a specific procedure: we followed the Gauss-Jordan elimination algorithm to bring the matrix into its reduced row echelon form. The reduced row echelon form (RREF) is the simplest form for an augmented matrix. Each row contains a leading one (a numeral 1) also known as a pivot . Each column‚Äôs pivot is used to eliminate the numbers that lie below and above it in the same column. The end result of this procedure is the reduced row echelon form: $$\begin{pmatrix}1 &amp; 0 &amp; \ast &amp; 0 &amp;\bigm | \ast \0 &amp; 1 &amp; \ast &amp; 0 &amp;\bigm | \ast \0 &amp; 0 &amp; 0 &amp; 1 &amp;\bigm | \ast\end{pmatrix}$$ Note the matrix contains only zero entries below and above the pivots. The asterisks $\ast$ denote arbitrary numbers that could not be eliminated because no leading one is present in these columns. The solution to a system of linear equations in the variables $x_1, x_2, \dots, x_n$ is the set of values $\{(x_1, x_2, \dots, x_n)\}$ that satisfy all the equations. Gaussian elimination is the process of bringing a matrix into row echelon form.  A matrix is said to be in row echelon form (REF) if all entries below the leading ones are zero. This form can be obtained by adding or subtracting the row with the leading one from the rows below it.  Gaussian-Jordan elimination is the process of bringing a matrix into reduced row echelon form.  A matrix is said to be in reduced row echelon form (RREF) if all the entries below and above the pivots are zero. Starting from the REF, we obtain the RREF by subtracting the row containing the pivots from the rows above them. the rank of the matrix $A$ is the number of pivots in the RREF of $A$.  Number of Solutions : A system of linear equations in three variables could have: one solution If the RREF of a matrix has a pivot in each row, we can read off the values of the solution by inspection. \$\$\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; c_1 \\\0 &amp; 1 &amp; 0 &amp; c_2 \\\0 &amp; 0 &amp; 1 &amp; c_3\end{bmatrix}\$\$The unique solution is $x_1 = c_1$, $x_2 = c_2$, and $x_3 = c_3$.  Infinitely many solutions 1 If one of the equations is redundant, a row of zeros will appear when the matrix is brought to the RREF. This happens when one of the original equations is a linear combination of the other two. In such cases, we're really solving two equations in three variables, so can't pin down one of the unknown variables. We say the solution contains a free variable . For example, consider the following RREF:\$\$\begin{bmatrix} 1 &amp; 0 &amp; a_1 &amp; c_1 \\\0 &amp; 1 &amp; a_2 &amp; c_2 \end{bmatrix}\$\$The column that doesn't contain a leading one corresponds to the free variable. To indicate that $x_3$ is a free variable, we give it a special label $x_3 \equiv t$. The variable $t$ could be any number $t \in \mathbb{R}$. In other words, when we say $t$ is free, it means $t$ can take on any value from $-\infty$ to $+\infty$. The information in the augmented matrix can now be used to express $x_1$ and $x_2$ in terms of the right-hand constants and the free variable $t$:\$\$\begin{Bmatrix} x_1 = c_1 - a_1 t \\\ x_2 = c_2 - a_2 t \\\ x_3 = t, \forall t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} c_1 \\\ c_2 \\\ 0 \end{bmatrix} + t \begin{bmatrix} -a_1 \\\ -a_2 \\\ 1 \end{bmatrix}, \forall t \in \mathbb{R}\end{Bmatrix}\$\$. The solution corresponds to the equation of a line passing through the point $(c_1, c_2, 0)$ with direction vector $(-a_1, -a_2, 1)$. We'll discuss the geometry of lines in the next section. For now, it's important that you understand that a system of equations can have more than one solution; any point on the line $l \equiv \{(c_1, c_2, 0) + t(-a_1, -a_2, 1), \forall t \in \mathbb{R}\}$ is a solution to the above system of equations.  Infinitely many solutions 2 It's also possible to obtain a two-dimensional solution space. This happens when two of the three equations are redundant. In this case, there will be a single leading one, and thus two free variables. For example, in the RREF\$\$\begin{bmatrix} 0 &amp; 1 &amp; a_1 &amp; c_1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}\$\$the variables $x_1$ and $x_3$ are free. As in the previous infinitely-many-solutions case, we define new labels for the free variables $x_1 \equiv s$ and $x_3 \equiv t$, where $ s \in \mathbb{R}$ and $t \in \mathbb{R}$ are two arbitrary numbers. The solution to this system of equations is \$\$ \begin{Bmatrix} x_1 = s \\\ x_2 = c_2 - a_2 t \\\ x_3 = t , \\\ \forall s,t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} 0 \\\ c_2 \\\ 0 \end{bmatrix} + s \begin{bmatrix} 1 \\\ 0 \\\ 0 \end{bmatrix} + t \begin{bmatrix} 0 \\\ -a_2 \\\ 1 \end{bmatrix}, \forall s,t \in \mathbb{R} \end{Bmatrix} \$\$This solution set corresponds to the parametric equation of a plane that contains the point $(0,c_2, 0)$ and the vectors $(1,0,0)$ and $(0, -a_2, 1)$. The general equation for the solution plane is $0x+1y+a_2z = c_2$, as can be observed from the first row of the augmented matrix. In the next section, we'll learn more about the geometry of planes and how to convert between their general and parametric forms.  no solutions If there are no numbers $(x_1, x_2, x_3)$ that simultaneously satisfy all three equations, the system of equations has no solution. An example of a system of equations with no solution is the pair $ s+t = 4$ and $s+t = 44$. There are no numbers $(s,t)$ that satisfy both these equations. A system of equations has no solution if its reduced row echelon form contains a row of zero coefficients with a nonzero constant in the right-hand side:\$\$\begin{Bmatrix}\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; c_1 \\\\ 0 &amp; 1 &amp; 0 &amp; c_2 \\\\ 0 &amp; 0 &amp; 0 &amp; c_3 \end{array}\end{Bmatrix}\$\$If $c_3 \neq 0$ this system of equations is impossible to satisfy. There is no solution because there are no numbers $(x_1, x_2, x_3)$ such that $0x_1 + 0x_2 + 0x_3 = c_3$. Dear reader, we've reached the first moment in this book where you'll need to update your math vocabulary. The solution to an individual equation is a finite set of points. The solution to a system of equations can be an entire space containing infinitely many points, such as a line or a plane. The solution set of a system of three linear equations in three unknowns could be either the empty set $\{0\}$ (no solution), a set with one element $\{(x_1, x_2, x_3)\}$, or a set with infinitely many elements like a line $\{p_o + t \overrightarrow{v}, t \in \mathbb{R}\}$ or a plane $\{p_o + s \overrightarrow{v} + t \overrightarrow{w}, s,t \in \mathbb{R}\}$. Another possible solution set is all of $\mathbb{R}^3$; every vector $ \overrightarrow{x} \in \mathbb{R}^3 $ is a solution to the equation \$\$\begin{bmatrix} 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0 \end{bmatrix} \begin{bmatrix} x_1 \\\ x_2 \\\ x_3 \end{bmatrix} = \begin{bmatrix} 0 \\\ 0 \\\ 0 \end{bmatrix}\$\$Note the distinction between the three types of infinite solution sets. A line is one-dimensional, a plane is two-dimensional, and $\mathbb{R}^3$ is three-dimensional. Describing all points on a line requires one parameter, describing all points on a plane takes two parameters, and-of course-describing a point in $\mathbb{R}^3$ takes three parameters.  Geometric Interpretation : We can gain some intuition about solution sets by studying the geometry of the intersections of lines in $\mathbb{R}^2$ and planes in $\mathbb{R}^3$.  Lines in two dimensions : Equations of the form $ax+by = c$ corresponds to lines in $\mathbb{R}^2$. Solving systems of linear equations of the form\$\$\displaylines{a_1 x + b_1 y = c_1 \\\a_2 x + b_2 y = c_2}\$\$requires finding the point $(x,y) \in \mathbb{R}^2$ where these lines intersect. There are three possibilities for the solution set:- one solution if the two lines intersect at a point. - infinitely many solutions if the lines are superimposed. - no solution if the two lines are parallel and never intersect. Planes in three dimensions : Equations of the form $ax+by+cz = d$ correspond to planes in $\mathbb{R}^3$. When solving three such equations, \$\$ \displaylines{a_1 x + b_1 y + c_1 z = d_1 \\\a_2 x + b_2 y + c_2 z = d_2 \\\a_3 x + b_3 y + c_3 z = d_3}\$\$we want to find a set of points $(x,y,z)$ that satisfy all three equations simultaneously. There are four possibilities for the solution set:1.  one solution three non-parallel planes intersect at a point. 2.  infinitely many solutions 1 if only one of the plane equations is redundant, the solution corresponds to the intersection of two planes which is a line. 3.  infinitely many solutions 2 if two of the equations are redundant, then the solution space is a two-dimensional space. 4.  if two (or more) of the planes are parallel, they will never intersect.  Determinants : Overview : What is the volume of a rectangular box of length $1m$, width $2$ and height $3m$? It's easy to compute the volume of this box because its shape is right rectangular prism. The volume of this prism is $V = l \times w \times h = 6m^3$. What if the shape of the box was a parallelpiped instead? A parallelpiped is a box whose opposite faces are parallel but whose sides are slanted. How do we compute the volume of a parallelpiped? The determinant operation, specifically the $3 \times 3$ determinant, is the perfect tool for this purpose. The determinant of a matrix, denoted $det(A)$ or $|A|$, is a particular way to multiply the entries of the matrix to produce a single number. We use determinants for all kinds of tasks: to compute areas and volumes, to solve systems of linear equations, to check whether a matrix is invertible or not, etc. We can interpret the determinant of a matrix intuitively as a geometrical calculation. The determinant is the volume of the geometric shape whose edges are the rows of the matrix. For $2 \times 2$ matrices, the determinant corresponds to the area of a parallelogram. For $3 \times 3$ matices, the determinant corresponds to the volume of a parallelpiped. For dimensions $d &gt; 3$, we say the determinant measures a $d$-dimensional hyper-volume . Consider the linear transformation $T: \mathbb{R}^2 \rightarrow \mathbb{R}^2$ defined through the matrix-vector product with a matrix $A_T: T(\overrightarrow{x}) \equiv A_T \overrightarrow{x}$. The determinant of the matrix $A_T$ is the scale factor associated with the linear transformation $T$. The scale factor of the linear transformation $T$ describes how the area of a unit square in the input space (a square with dimensions $1 \times 1$) is transformed by $T$ . After passing through $T$, the unit square is transformed to a parallelogram with with area $det(A_T)$. Linear transformations that shrink areas have $det(A_T) &lt; 1$, while linear transformations that enlarge areas have $det(A_T) &gt; 1$. A linear transformation that is area preserving has $det(A+T) = 1$. The determinant is also used to check linear independence for a given set of vectors. We construct a matrix using the vectors as the matrix rows , and compute its determinant. The determinant of a matrix tells us whether or not that matrix is invertible . If $det(A) \neq 0$, then $A$ is invertible; if $det(A) = 0$, $A$ is not invertible. The determinant shares a connection with the vector cross product , and is used in the definition of the eigenvalue equation . Formulas : The determinant of a $2 \times 2$ matrix is \$\$det(\begin{bmatrix} a_{11} &amp; a_{12} \\\ a_{21} &amp; a_{22} \end{bmatrix}) = \begin{vmatrix} a_{11} &amp; a_{12} \\\ a_{21} &amp; a_{22} \end{vmatrix} = a_{11}a_{22} - a_{12}a{21}\$\$The formulas for the determinants of larger matrices are defined recursively. For example, the determinant of $3 \times 3$ matirx is defined in terms of $2 \times 2$ determinants:\$\$ \begin{vmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\ a_{21} &amp; a_{22} &amp; a_{23} \\\ a_{31} &amp; a_{32} &amp; a_{33} \end{vmatrix} = a_{11} = a_{11} \begin{vmatrix}a_{22} &amp; a_{23} \\\ a_{32} &amp; a_{33} \end{vmatrix} -a_{12} \begin{vmatrix} a_{21} &amp; a_{23} \\\ a_{31} &amp; a_{33} \end{vmatrix}+ a_{13} \begin{vmatrix} a_{21} &amp; a_{22} \\\ a_{31} &amp; a_{32} \end{vmatrix}\$\$ There's a neat computational trick for computing $3 \times 3$ determinants by hand. The trick consists of extending the matrix $A$ into a $3 \times 5$ array that contains copies the columns of $A$: the $1^{st}$ column of $A$ is copied to the $4^{th}$ column of the extended array, and the $2^{nd}$ column of $A$ is copied to the $5^{th}$ column. The determinant is then computed by summing the products of the entries on the three positive diagonals and subtracting the products of the entries on the three negative diagonals. The general formula for the determinant of an $n \times n$ matrix is\$\$det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}\$\$where $M_{ij}$ is called the minor associated with the entry $a_{ij}$. The minor $M_{ij}$ is the determinant of the submatrix obtained by removing the $i^{th}$ row and the $j^{th}$ column of the matrix $A$. Note the alternating factor $(-1)^{i+j}$ that changes value between $+1$ and $-1$ for different terms in the formula. The determinant of a $4 \times 4$ matrix $B$ is \$\$ det(B) = b_{11}M_{11} - b_{12}M_{12} + b_{13}M_{13} - b_{14}M_{14}\$\$The general formula for determinants $det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}$ assumes we're expanding the determinant along the first row of the matrix. In fact, a determinant formula can be obtained by expanding the determinant along anyrow or column of the matrix. The expand-along-any-row-or-column nature of determinants can be very handy: if you need to calculate the determinant of a matrix with one row (or column) containing many zero entries, it makes sense to expand along that row since many of the terms in the formula will be zero. If a matrix contains a row (or column) consisting entirely of zeros, we can immediately tell its determinant is zero.  Geometric interpretation : Area of a parallelogram Suppose we're given vectors $overrightarrow{v} = (v_1, v_2)$ and $\overrightarrow{w} = (w_1, w_2)$ in $\mathbb{R}^2$ and we construct a parallelogram with corner points $(0,0), \overrightarrow{v}, \overrightarrow{w}$ and $\overrightarrow{v} + \overrightarrow{w}$. The area of this parallelogram is equal to the determinant of the matrix that contains $(v_1, v_2)$ and $(w_1, w_2)$ as rows:\$\$area = \begin{vmatrix} v_1 &amp; v_2 \\\ w_1 &amp; w_2 \end{vmatrix} = v_1 w_2 - v_2 w_1 \$\$ Theoretical Linear Algebra : The things we are going to learn now are less concerned with calculations and more about mind expansion. This section extends what we know about the vector space $\mathbb{R}^n$ to the realm of abstract vector spaces of vector-like mathematical objects.  Eigenvalues and Eigenvectors : The set of eignevectors of a matrix is a special set of input vectors for which the action of the matrix is described as simple scaling . Decomposing a matrix in terms of its eigenvalues and its eigenvectors gives valuable insights into the properties of the matrix. Certain matrix calculations, like computing the power of the matrix, become much easier when use the eigendecomposition of the matrix For example, suppose we're given a square matrix $A$ and want to compute $A^7$. To make this example more concrete, we'll analyze the matrix \$\$A = \begin{bmatrix} 9 &amp; -2 \\\ -2 &amp; 6 \end{bmatrix}\$\$We want to compute $A^7$. That would be an awful lot of matrix multiplications. Every matrix corresponds to some linear operation. This means it's legit to ask,  what does the matrix A do?  Once we figure out this part, we can compute $A^{77}$ by simply doing what $A$ does $77$ times. The best way to see what a matrix does is to look inside it and see what it's made of. To understand the matrix $A$, you must find it its eigenvectors and its eigenvalues. The eigenvectors of a matrix are a natural basis for describing the action ofthe matrix. The eigendecomposition is a change-of-basis operation that expresses the matrix $A$ with respect to its eigenbasis (own-basis). The eigendecompositions of the matrix $A$ is a product of three matrices:"
    }, {
    "id": 29,
    "url": "https://sally20921.github.io/group-norm.html",
    "title": "Batch Normalization and Group Normalization",
    "body": "2021/09/08 -  Batch Normalization: the Principles : Batch Normalization is an algorithmic method which makes the training of Deep Neural Networks faster and more stable . Batch normalization is computed differently during the training and the testing phase. At training , the BN layer determines the mean and standard deviation of the activation values across the batch. It then normalizes the activation vector with $\mu$ and $\sigma$. That way, each neuron‚Äôs output follows a standard normal distribution across the batch . It finally applies a linear transformation with $\gamma$ and $\beta$ which are the two trainable parameters. Such step allows the model to choose the optimum distribution for each hidden layer. $\gamma$ allows to adjust the standard deviation while $\beta$ allows to adjust the bias, shifting the curve on the right or on the left side. At each iteration, the network computes the mean $\mu$ and the standard deviation $\sigma$ corresponding to the current batch. Then it trains $\gamma$ and $\beta$ through gradient descent using an Exponential Moving Average (EMA) to give more importance to the latest iterations.  We mostly use Exponential Moving Average algorithm to reduce the noise or to smooth the data. The weight of each element decreases progressively over time, meaning the EMA gives greater weight to recent data points . EMA reacts faster to changes compared to Simple Moving Average. At the evaluation phase , we may not have a full batch to feed into the model. To tackle this issue, we compute $\mu_{pop}$ and $\sigma_{pop}$ as the estimated mean and standard deviation of the studied population . Those values are computed using all the $\mu_{batch}$ and $\sigma_{batch}$ during training, and directly fed during the evaluation phase.  Why Normalization? : What we can conclude from the original Batch Normalization paper is that:  Adding BN layers leads to better convergence and higher accuracy  Adding BN layers allows us to use higher learning rate without compromising convergence. To quote Ian Goodfellow about the use of batch normalization: Before BN, we thought it was almost impossible to efficiently train deep models using sigmoid in the hidden layers. Batch Normalization makes those unstable networks trainable. In practice, it is widely admitted that: For CNNs, Batch Normalization is better  For Recurrent Networks, Layer Normalization is better While BN uses the current batch to normalize every single value, LN uses all the current layer to do so.  The normalization is performed using other features from a single example instead of using the same feature across all current batch examples. The best way to understand why BN works is to understand the optimization landscape smoothness . BN reparameterizes the underlying optimization problem , making the training faster and easier. In additional recent studies, researchers observed that this effect is not unique to BN, but applies to other normalization methods (i. e. L1 normalization or L2 normalization).  The Drawbacks of BN : For BN to work, the batch size is required to be sufficiently large , usually at least 32 . However, there are situations when we have to settle for a small batch size. For example, when each data sample is highly memory consuming or when we train a very large neural network which leaves little GPU memory for processing data. For computer vision applications other than image classification, the restriction on batch sizes are more demanding and it is difficult to have higher batch sizes.  Comparisions of Normalization Methods : Group Normalization is one of the latest normalization methods that avoids exploiting the batch dimension, thus is independent of batch size. But there are other normalization methods as well.  Layer Normalization : Layer Normalization computes $\mu_i$ and $\sigma_i$ along the (C,H,W) axes. The computation for an input feature is entirely independent of other input features in a batch.  Instance Normalization : Instance Normalization computes $\mu_i$ and $\sigma_i$ along the (H,W) axes. Since the computation of IN is the same as that of BN with batch_size=1, IN actually makes the situation worse in most cases. However, for style transfer tasks , IN is better at discarding contrast information of an image, thus having superior performance than BN.  Group Normalization : Also notice that IN can be viewed as applying Layer Normalization to each channel individually as if the num_channels = 1. Group Normalization is the middle ground between IN and LN. It organizes the channels into different groups and computes $\mu_i$ and $\sigma_i$ along the (H,W) axes and along a group of channels. First, the batch with dimension (N,C,H,W) is reshaped to (N,G,C//G,H,W). The number of group $G$ is a pre-defined hyperparameter . Then we normalize along the (C//G,H,W) dimension and return the result after reshaping the batch back to (N,C,H,w). Group Normalization is better than Layer Normalization as GN allows different distribution to be learned for each group of channels. GN is also thought to be better than IN because GN can exploit the dependence across channels. If `C = G`, that is, if the number of groups are set to be equal to the number of channels, GN becomes IN . Likewise, if `G = 1` GN becomes LN .  References :  blog post medium article medium article2 "
    }, {
    "id": 30,
    "url": "https://sally20921.github.io/disparity.html",
    "title": "Depth from Disparity",
    "body": "2021/09/05 -  üåü 3D Reconstruction from 2D Signals : We are going to look at depth estimation as a multi-view problem. Multi-view problems can span into different domains including stereo vision, Structure from Motion and optical flow. Although each carries great importance in the problem of Virtual Reality (VR) and robotics, we will focus on stereo vision in this multi-part series. Specifically, the progress of deep learning in stereo vision technology. How can we automatically compute 3D geometry from images ? What cues in the image provide 3D information? Before looking at binocular, let‚Äôs consider single view characteristics. Well, we humans do so naturally. Here are several cues we use to infer depth information: shading texture  focus motion  perspective occlusion  symmetry Nonetheless, structure and depth are inherently ambiguous from a single view. As seen from the optical center (i. e. , camera location), $P1$ and $P2$ are projected onto the image plane as equivalent.  The Stereo Problem : Stereo vision systems reference the knowledge of two images captured simultaneously from a pair of cameras (left and right) with camera parameters (extrinsic and intrinsic). Stereo is heavily motivated by biology. Classic stereo problem include disparity, depth, occlusion, Structure from Motion, motion parallax etc. Provided left and right images, the ambiguity problem of the aforementioned is satisfied via triangulation from the two image planes by matching correspondences of a point in the world coordinate to the ones that can be seen in both images. The basic principle of triangulation is shown above: the reconstruction via the intersection of two rays. Requirements? Calibration and correspondences. Furthermore,  the Epipolar Constraint reduces the correspondence problem to $1D$ search along conjugate epipolar lines shown in the above figure. Thus, Epipolar Constraint assumes that stereo pairs are rectified images, meaning the same epipolar line aligns across rows such that it is orthogonal to both and aligned with one another. Rectification is achieved by learning a transformation based on intrinsic and extrinsic parameters: a process that dates back several decades. From the rectified image pair, the depth $Z$ can be determined by its inversely proportionate relationhip with disparity $d$, where the disparity is defined as the pixel difference along the horizontal when comparing correspondences of left and right. This can be written as: $$I(x,y) = D(x+d, y)$$ This relationship is easiest to grasp visually. Provided a point in the left image plane $P_L(x,y)$ along with the correspondence in the right image plane and the world coordinates $(X,Y,Z)$ projected as a point in a 3D scene, our goal is to reconstruct the missing $Z$ (depth) provided the stereo pair. We set the relative coordinates (red axis) along with having known baseline $b$ between the two camera centers. Then $/frac{x_L}{f}$ can be expressed as $\frac{X+b/2}{Z}$ and $\frac{x_R}{f} = \frac{X-b/2}{Z}$. Therefore, $$\frac{y_L}{f} = \frac{y_R}{f} = \frac{Y}{Z}$$ and the world coordinate can be expressed as $$X = \frac{b(x_L+x_R)}{2(x_L - x_R)} Y = \frac{b(y_L + y_R}{2(x_L-x_R} Z = \frac{bf}{(x_L - x_R)}$$ $d = x_L - x_R$ is the disparity between corresponding left and right image points References :  article from medium "
    }, {
    "id": 31,
    "url": "https://sally20921.github.io/camera.html",
    "title": "Dissecting the Camera Matrix (Part 1)",
    "body": "2021/09/05 -  Camera Calibration and Decomposition : Primarily, camera calibration is about finding the quantities internal to the camera that affect the imaging process. Here are some of the factors that will be taken care of:  image center : we need to find the position of the image center in the image. Wait, isn't the image center located at $(width/2, height/2)$? Well, no. Unless we calibrate the camera, the image will almost always appear to be off-center.  focal length : this is a very important parameter. Remember how people using DSLR cameras tend to focus on things before capturing the image? this parameter is directly related to the focus of the camera and it is very critical.  scaling factors : the scaling factors for row pixels and column pixels might be different. If we don't take care of this thing, the image will look stretched (either horizontally or vertically).  skew factor : this refers to shearing. the image will look like a parallelogram otherwise.  lens distortion : this refers to the pseudo zoom effect that we see near the center of any image.  shearing refers to a transformation in which all points along a given line $L$ remain fixed while other points are shifted parallel to $L$ by a distance proportional to their perpendicular distance from $L$.  Pinhole Camera Model : Before we jump into anything, let's see where this all began. When we capture an image, we are basically mapping the 3D scene to a 2D scene. It means that every point in the 3D world gets mapped to the 2D plane of our image. This is called the pinhole camera model . It basically describes the relationship between the coordinates of the 3D point and its projection on the 2D image. This, of course, is the ideal case where there is absolutely no distortion of any kind. Every camera is modeled based on this, and every camera aspires to simulate this as close as possible. But in the real world, we have to deal with things like geometric distortions, blurring, finite sized apertures, etc. The figure shown here depicts a pinhole camera model. The camera is placed at the origin $O$. The point $P$ represents a point in the real world. We are trying to capture that onto a 2D plane. The image plane represents the 2D plane that you get after capturing the image. The image plane actually contains the image that you see after capturing a picture. So basically, we are trying to map every 3D point to a point on the image plane. In this case, the point $P$ gets mapped to $P_c$. The distance between the origin $O$ and this image plane is called the focal length of the camera. This is the parameter you modify when you adjst the focus of the camera.  Intrinsic and Extrinsic Parameters : In the above figure, we want to estimate $(u,v)$ from $(X,Y,Z)$. Let's say the focal length is denoted by $f$. If you look at the triangle formed using the origin-$P_c$-and the $Z$-axis with the origin-$P$ and $Z$-axis, you will notice that they are similar triangles. This means that $u$ depends on the $f$, $X$ and $Z$. Similarly, $v$ depends on $f$, $Y$ and $Z$. \$\$\displaylines{u = fX/Z \\\v = fY/Z}\$\$Next, if the origin of the 2D image coordinate system does not coincide with where the $Z$-axis intersects the image plane, we need to translate $P_c$ into the desired origin. Let this translation be defined by $(t_u, t_v)$. So now, $u$ and $v$ are given by:\$\$\displaylines{u = fX/Z + t_u \\\v = fY/Z + t_v}\$\$So up until now, we have something that can translate $(X,Y,Z)$ to $(u,v)$. Let's denote this matrix $M$. So we can write:\$\$ P_c = MP\$\$Since this is a camera image, we need to express it in inches. For this, we will need to know the resolution of the camera in pixels/inch. If the pixels are square the resolution will be identical in both $u$ and $v$ directions of the camera image coordinates. However, for a more general case, we assume rectangular pixels with resolution $m_u$ and $m_v$ pixels/inch in $u$ and $v$ directions respectively. Therefore, to measure $P_c$ in pixels, its $u$ and $v$ coordinates should be multiplied by $m_u$ and $m_v$ respectively. So now, this new transformation matrix depends on $f, X, Y, Z, t_u, t_v, m_u, m_v$. Let's denote this by:\$\$P_c = KP\$\$Here, $K$ is called the intrinsic parameter matrix for the camera. Now, if the camera does not have its center of projection at $(0,0,0)$ and is oriented in an arbitrary fashion (not necessarily $z$-perpendicular to the image plane), then we need roation and translation to make the camera coordinate system coincide with the configuration in that pinhole camera figure. Let the rotation applied to coincide the principal axis with $Z$-axis given by a $3 \times 3$ rotation matrix $R$. Then the matrix is formed by first applying the translation followed by the rotation is given by the $3 \times 4$ matrix. \$\$E = \\( R|RT \\)\$\$This is called the extrinsic parameter matrix for the camera . So, the complete camera transformation can now be represented as: \$\$ K \\( R|RT \\) = KR \\( I|T \\)\$\$Hence, $P_c$ the projection of $P$ is given by:\$\$P\_c = KR \\( I|T \\) P = CP\$\$$C$ is a $3 \times 4$ matrix usually called the complete camera calibration matrix. So basically, camera calibration matrix is used to transform a 3D point in the real world to a 2D point on the image plane considering all the things like focal length of the camera, distortion, resolution, shifting of origin, etc.  References :  ksimek blog prateekvjoshi blog "
    }, {
    "id": 32,
    "url": "https://sally20921.github.io/depth.html",
    "title": "Depth Estimation: Basics and Intuition",
    "body": "2021/09/02 -  Depth Estimation in Computer Vision : Depth estimation is also known as the inverse problem , where we seek to recover unknowns given insufficient information. So how do machines actually perceive depth? The earliest algorithm with impressive results began with depth estimation using stereo vision back in the 90s. A lot of progress was made on dense stereo correspondence algorithm Researchers were able to utilize geometry to constrain and replicate the idea of stereopsis mathematically. As for monocular depth estimation, it recently started to gain popularity by using neural networks. We will talk about this shortly after discussing stereo vision.  Depth Estimation from Stereo Vision : The main idea of solving depth using a stereo camera involves the concept of triangulation and streo matching . The former depends on good calibration and rectification to constrain the problem so that it can be modelled on a 2D plane known as epipolar plane . Epipolar plane greatly reduces the stereo matching problem to a line search along the epipolar line. Once we are able to match pixel correspondences between 2 views, the next task is to obtain a representation that encodes the difference .  This representation is known as disparity . The formula to obtain depth from disparity can be worked out from similar triangles.  Why is Measuring Depth So Difficult? : Before we move on, let‚Äôs try to understand some fundamental problems of depth estimation. The main culprit lies in the projection of 3D views to 2D images where depth information is lost . Another problem is deeply seeded when there are motion and moving objects .  Depth Estimation is Ill-Posed : Estimating depth from a single RGB image is an ill-posed inverse problem. What this means is that many 3D scenes observed in the 3D world can indeed correspond to the same 2D image plane.  Scale Ambiguity for Monocular Depth Estimation : The uncertain scale factor require current methods to have an additional sensor like LiDAR to provide depth ground-truth or stereo camera as additional training input, which makes them difficult to implement. Note that this issue exists only for monocular-based techniques , as the scale can be recovered for a stereo rig with a known baseline.  References : medium article medium article 2 medium article 3 paper about absolute depth "
    }, {
    "id": 33,
    "url": "https://sally20921.github.io/rigid.html",
    "title": "3D Rigid Body Motion (Part 1)",
    "body": "2021/08/31 - Introduction: In this article, I will introduce one of the fundamental problems of visual SLAM: How to describe a rigid body‚Äôs motion in 3-dimensional space ? Intuitively, we certainly know that this consists of one rotation plus one translation . The translation part does not really have any problems, but the rotation part is questionable. I will introduce the meaning of rotation matrices, quaternions, Euler angles and how they are computed and transformed. Rotation Matrix: Points, Vectors, and Coordinate Systems: The space of our daily life is 3-dimensional, so we are born to be used to 3D movements. The 3D space consists of three axes, so the position of one spatial point can be specified by three coordinates. However, we should now consider a rigid body , which has its position and orientation . The camera can also be viewed as a rigid body in three dimensions, so what we care about in Visual SLAM are the problem of the camera‚Äôs position and orientation. Combined, we can say, ‚Äúthe camera is at the $(0,0,0)$ point, facing the front‚Äù. Let‚Äôs describe this in a mathematical term. We start from the basic content: points and vectors. Points are the basic element in space, no length, no volume. Connecting the two points forms a vector. A vector can be thought of as an arrow pointing from one point to another. Here we need to warn you not to confuse the vector with its coordinates. A vector is one thing in space, such as $a$. Here, $a$ does not need to be associated with several real numbers. We can naturally talk about the plus or minus operation of two vectors, without relating to any real numbers. Only when we specify a coordinate system in this 3D space can we talk about the vector‚Äôs coordinates in this system, finding several real numbers corresponding to this vector. With the knowledge of linear algebra, the coordinates of a point in 3D space can be described as $\mathbb{R}^3$. How to do we describe this? Suppose that in this linear space, we fined a set of base $(e_1, e_2, e_3)$ , then, an arbitrary vector $a$ has a coordinate under this base: $$ a = \begin{bmatrix} e_1 &amp; e_2 &amp; e_3 \end{bmatrix} \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = a_1 e_1 + a_2 e_2 + a_3 e_3 $$. Here, $(a_1, a_2, a_3)^T$ is called $a$‚Äôs coordinates. The coordinates‚Äô specific values are related to the vector itself and the selection of the bases. In $\mathbb{R}^3$, the coordinate system usually consists of $3$ orthogonal coordinate axes (it can also be non-orthogonal, but it is rare in practice). For example, given $x$ and $y$ axis, the $z$ axis can be determined using the right-hand (or left-hand) rule. According to different definitions, the coordinate system is divided into left-handed and right-handed. The third axis of the left-hand rule is opposite to the right-hand rule. Most 3D libraries use right-handed coordinates. Based on basic linear algebra knowledge, we can talk about the operations between vectors/vectors, vectors/numbers, such as scalar multiplication, vector addition, subtraction, inner product, outer product and so on. For $a,b \in \mathbb{R}^3$, the inner product of $a,b$ can be written as: \$\$ a \cdot b = a^Tb = \sum_{i=1}^3 a_i b_i = |a\||b| \cos(&lt;a,b&gt;)\$\$where $ &lt;a. b&gt; $ refers to the angle between the vector $a, b$. The inner product can also describe the projection relationship between vectors. $$ a \times b = \begin{Vmatrix} e_1 &amp; e_2 &amp; e_3 \\ a_1 &amp; a_2 &amp; a_3 \\ b_1 &amp; b_2 &amp; b_3 \end{Vmatrix} = \begin{bmatrix} a_2b_3 - a_3 b_2 \\ a_3 b_1 - a_1 b_3 \\ a_1 b_2 - a_2 b_1 \end{bmatrix} = \begin{bmatrix} 0 &amp; -a_3 &amp; a_2 \\ a_3 &amp; 0 &amp; -a_1 \\ -a_2 &amp; a_1 &amp; 0 \end{bmatrix} b = a \wedge b$$. The result of the outer product is a vector whose direction is perpendicular to the two vectors, and the length is $|a||b|\sin(&lt;a,b&gt;)$, which is also the area of the quadrilateral of the two vectors. From the outer product operation, we introduce the $\wedge$ operator here, which means writing $a$ as a skew-symmetric matrix . You can take $\wedge$ as a skew-symmetric symbol. It turns the outer product $a \times b$ into the multiplication of the matrix and the vector $a \wedge b$ is a linear operation. This symbol will be used frequently in the following sections. It is a one-to-one mapping, meaning that for any vector, it corresponds to a unique anti-symmetric matrix, and vice versa: $$ a \wedge = \begin{bmatrix} 0 &amp; -a_3 &amp; a_2 \\ a_3 &amp; 0 &amp; -a_1 \\ -a_2 &amp; a_1 &amp; 0 \end{bmatrix}$$ At the same time, note that the vector operations such as addition, subtraction, inner and outer products can be calculated even when we do not have their coordinates. For example, although the inner product can be expressed by the sum of the two vectors‚Äô product when we know the coordinates, the length and angle can also be calculated even if their coordinates are unknown. Therefore, the inner product result of the two vectors is independent of the selection of the coordinate system. Euclidean Transforms between Coordinate Systems: We often define a variety of coordinate systems in the real scene. In robotics, you define one coordinate system for each link and joint; in 3D mapping, we also define a coordinate system for each cuboid and cylinder. If we consider a moving robot, it is common practice to set a stationary inertial coordinate system (or world coordinate system), such as the $x_W, y_W, z_W$ defined in the picture above. Meanwhile, the camera or robot is a moving coordinate system, such as coordinate system defined by $x_C, y_C, z_C$. We might ask: a vector $p$ in the camera system may have coordinates $p_c$; and in the world coordinate system, its coordinates maybe $p_w$ .  Then what is the conversion between two coordinates? It is necessary to first obtain the coordinate values of the point in the camera system and then use the transform rule to do the coordinate transform. We need a mathematical way to describe this transformation. As we will see later, we can describe it with a transform matrix $T$. Intuitively, the motion between two coordinate systems consists of a rotation plus a translation , which is called rigid body motion . Obviously, the camera movement is rigid. During the rigid body motion, the length and angle of the vector will not change. Imagine that you throw your phone into the air and there may be differences in spatial position and orientation. But the length and the angle of each face will not change. At this point, we say that the phone‚Äôs motion is Euclidean. The Euclidean transform consists of rotation and translation . Let‚Äôs first consider the rotation. We have a unit-length orthogonal base $(e_1, e_2, e_3)$. After a rotation it becomes $(e_1‚Äô, e_2‚Äô, e_3‚Äô)$. Then, for the same vector $a$ (the vector does not move with the rotation of the coordinate system). its coordinates in these two coordinate systems are $[a_1, a_2, a_3]^T$ and $[a_1‚Äô, a_2‚Äô, a_3]^T$. Because the vector itself has not changed, according to the definition of coordinates, there are: $$ [e_1, e_2, e_3] \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = [e_1‚Äô, e_2‚Äô, e_3‚Äô] \begin{bmatrix} a_1‚Äô \\ a_2‚Äô \\ a_3‚Äô \end{bmatrix}$$ To describe the relationship between the two coordinates, we multiply the left and right side of the above equation by $\begin{bmatrix} e_1^T \\ e_2^T \\ e_3^T \end{bmatrix}$, then the matrix on the left becomes an identity matrix, so: $$\begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} \triangleq Ra‚Äô$$. We take the intermediate matrix out and define it as a matrix $R$. This matrix consists of the inner product between the two sets of bases, describing the same vector‚Äôs coordinate transformation relationship before and after the rotation. It can be said that the matrix $R$ describes the rotation itself . So we call it the rotation matrix. Meanwhile, the components of the matrix are the inner product of the two coordinate system bases. Since the base vector‚Äôs length is $1$, it is actually the cosine of the angle between the base vectors. So this matrix is also called direction cosine matrix. The rotation matrix has some special properties.  In fact, it is an orthogonal matrix with a determinant of $1$. Conversely, an orthogonal matrix with a determinant of 1 is also a rotation matrix. So you can define a set of $n$ dimensional rotation matrices as follows:       $$SO(n) = \{ R \in \mathbb{R}^{n \times n}   RR^T = I, det(R) =1 \} $$   $SO(n)$ refers to the special orthogonal group. This set consists of a rotation matrix of $n$ dimensional space, in particular, $SO(3)$ refers to the rotation of the three-dimensional space. In this way, we can talk directly about the rotation transformation between the two coordinate systems without having to start from the bases. Since the rotation matrix is orthogonal, its inverse (i. e. , transpose) describes an opposite rotation. According to the above definition, there are: $$a‚Äô = R^{-1}a = R^Ta$$ Obviously, the $R^T$ represents an opposite rotation. In the Euclidean transformation, there is a translation in addition to rotation. Consider the vector $a$ in the world coordinate system. After a rotation (depicted by $R$) and a translation of $t$, we get $a‚Äô$. Then we can put the rotation and translation together, and have:$$a‚Äô= Ra+t$$,where $t$ is called a translation vector. Compared to the rotation, the translation part simply adds the translation vector to the coordinates after the rotation , which si very simple. By the above formula, we completely describe the coordinate transformation relationship using a rotation matrix $R$ and a translation vector $t$. In practice, we may define the coordinate system 1 and 2, then the vector $a$ under the two coordinates is $a_1, a_2$. The relationship between the two systems should be: $$a_1 = R_{12} a_2 + t_{12}$$. Here, $R_{12}$ means the ‚Äúrotation of the vector from system 2 to system 1‚Äù. About $t_{12}$, readers may just take it as a translation vector without wondering about its physical meaning. In fact, it corresponds to a vector from the system 1‚Äôs origin pointing to system 2‚Äôs origin, and the coordinates are taken under tsystem 1. So I suggest you to understand it as ‚Äúa vector from 1 to 2‚Äù. But the reverse $t_{21}$, which is a vector from $2$‚Äôs origin to $1$‚Äôs origin, whose coordinates are taken in system $2$, is not equal to $-t_{12}$. It is also related to the rotation of the two systems. Therefore, when beginners ask the question ‚ÄúWhat are my coordinates?‚Äù, we need to clearly explain this sentence‚Äôs meaning. Here, ‚Äúmy coordinates‚Äù normally refers to the vector from the world system $W$ pointing to the origin of the camera system $C$, and then take the coordinates in the world‚Äôs base. Corresponding to the mathematical symbol, it should be the value of $t_{WC}$. For the same reason, it is not $-t_{CW}$ but actually $-R^T_{CW} t_{CW}$. Transform Matrix and Homogeneous Coordinates: The formula $a‚Äô = Ra+t$ fully expresses the rotation and the translation of Euclidean space, but there is still a small problem: the transformation relationship here is not a linear relationship. Suppose we made two transformations: $R_1,t_1$ and $R_2,t_2$:$$b = R_1 a + t_1, c = R_2 b + t_2$$. So the transformation from $a$ to $c$ is: $$c = R_2 (R_1 a + t_1) + t_2$$. This form is not elegant after multiple transformations. Therefore, we introduce homogeneous coordinates and transformation matrices, rewriting the formula:$$ \begin{bmatrix} a‚Äô \\ 1 \end{bmatrix} = \begin{bmatrix} R &amp; t \\ 0^T &amp; 1 \end{bmatrix} \begin{bmatrix} a \\ 1 \end{bmatrix} \triangleq T \begin{bmatrix} a \\ 1 \end{bmatrix}$$. This is a mathematical trick: we add $1$ at the end of the 3D vector and turn it into a 4D vector called homogeneous coordinates. For this four-dimensional vector, we can write the rotation and translation matrix, making the whole relationship a linear relationship. In this formula, the matrix $T$ is called transform matrix. We temporarily use $\tilde{a}$ to represent the homogeneous coordinates of $a$. Then, relying on homogeneous coordinates and transformation matrices, the superposition of the two transformations can have a good form: $$\tilde{b} = T_1 \tilde{a}, \tilde{c} = T_2 \tilde{b} \Rightarrow T_2 T_1 \tilde{a}$$. But the symbols that distinguish between homogeneous and non-homogeneous coordinates are annoying, because here we only need to add 1 at the end of the vector or remove 1 to turn it into a normal vector. So, without ambiguity, we will write it directly as $b = Ta$ and by default we just assume a homogeneous coordinate conversion is made if needed. The transformation matrix $T$ has a special structure: the upper left corner is the rotation matrix, the right side is the translation vector, the lower-left corner is $0$ vector, and the lower right corner is $1$. This set of transform matrix is also known as the special Euclidean group: $$SE(3) = \{ T = \begin{bmatrix} R &amp; t \\ 0^T &amp; 1 \end{bmatrix} \in \mathbb{R}^{4 \times 4}| R \in SO(3), t \in \mathbb{R}^3 \}$$. Like $SO(3)$, the inverse of the transformation matrix represents an inverse transformation: $$T^{-1} = \begin{bmatrix} R^T &amp; -R^T t \\ 0^T &amp; 1 \end{bmatrix}$$. Again, we use the notation of $T_{12}$ to represent a transformation from 2 to 1. Because the conversion between homogeneous and non-homogeneous coordinates is actually very easy, it is assumed that the conversion from homogeneous coordinates to normal coordinates is already done. Summary: First, we introduced the vector and its coordinate representation and introduced the operation between the vectors; then, the motion between the coordinate systems is described by the Euclidean transformation, which consists of translation and rotation. The rotation can be described by the rotation matrix $SO(3)$, while the translation is directly described by an $\mathbb{R}^3$ vector. Finally, if the translation and rotation are placed in a matrix, the transformation matrix $SE(3)$ is formed. References:  Introduction to Visual SLAM"
    }, {
    "id": 34,
    "url": "https://sally20921.github.io/homogeneous.html",
    "title": "Homogeneous Coordinates and Projective Geometry",
    "body": "2021/08/31 - Introduction to Projective Geometry: Most of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and $Z$). However, there are certain situations where it is useful to think in terms of projective geometry instead. Projective geometry has an extra dimension, called $W$, in addition to the $X$, $Y$, and $Z$ dimensions. This four-dimensional space is called projective space and coordinates in projective space are called homogenous coordinates. For the purposes of 3D software, the terms projective and homogeous are basically interchangeable with 4D. Not Quaternions: Quaternions look a lot like homogeneous coordinates. Both are 4D vectors, commonly depicted as $(X,Y,Z,W)$. However, quaternions and homogeneous coordinates are different concepts, with different uses. An Analogy in 2D: First, let‚Äôs look at how projective geometry works in 2D, before we move on to 3D.  Imagine a projector that is projecting a 2D image onto a screen. It‚Äôs easy to identify the $X$ and $Y$ dimensions of the projected image.  Now, if you step back from the 2D image and look at the projector and the screen, you can see the $W$ dimension, too. The $W$ dimension is the distance from the projector to the screen .  So what does the $W$ dimension do, exactly? Imagine what would happen to the 2D image if you increased or decreased $W$-that is, if you increased or decreased the distance between the projector and the screen. If you move the projector closer to the screen, the whole 2D image becomes smaller. If you move the projector away from the screen, the 2D image becomes larger. As you can see, the value of $W$ affects the size (a. k. a scale) of the image . Applying it to 3D: There is no such thing as a 3D projector (yet), so its‚Äô harder to imagine projective geometry in 3D, but the $W$ value works exactly the same as it does in 2D. When $W$ increases, the coordinates expands (scales up). When $W$ decreases, the coordinates shrinks (scales down). The $W$ is basically a scaling transformation for the 3D coordinates . When $W = 1$: The usual advice for 3D programming beginners is to always set $W=1$ whenever converting a 3D coordinate to 4D coordinate. The reason for that is that when you scale a coordinate by a 1 it doesn‚Äôt shrink or grow, it just stays the same size. So, when $W=1$, it has no effect on the $X$, $Y$, or $Z$ values . For this reason, when it comes to 3D computer graphics, coordinates are said to be correct only when $W=1$. If you tried to render with $W=0$ your program would crash when it attempted to divide by zero. With $W&lt;0$ everything would flip unside-down and back-to-front. Mathematically speaking, there is no such thing as an incorrect homogeneous coordinate.  Using coordinates with $W=1$ is just a useful convention for the 3D computer grahics . The Math: Now, let‚Äôs look at some actual numbers, to see how the math works.  Let‚Äôs say that the projector is $3$ meters away from the screen, and there is a dot on the 2D image at the coordinate $(15, 21)$. This gives us the projective coordinate vector $(X,Y,W) = (15,21,3)$.  Now imagine that the projector was pushed closer to the screen so that the distance was $1$ meter. The closer the project gets to the screen, the smaller the image becomes. The projector has moved three times closer, so the image becomes three times smaller. If we take the original coordinate vector and divide all the values by three, we get the new vector where $W=1$:  $$(\frac{15}{3}, \frac{21}{3}, \frac{3}{3}) = (5,7,1)$$. The dot is now at coordinate $(5,7)$. This is how an incorrect homogeneous coordinate is converted to a correct coordinate: divide all the values by $W$. The process is exactly the same for 2D and 3D coordinates. Dividing all the values in a vector is done by a scalar multiplication with the reciprocal of the divisor. Here is a 4D example:  $$\frac{1}{5}(10, 20, 30, 5) = (\frac{10}{5}, \frac{20}{5}, \frac{30}{5}, \frac{5}{5}) = (2,4,6,1)$$ Uses of Homogeneous Coordinates in Computer Graphics: As mentioned earlier, in regard to 3D computer graphics, homogeneous coordinates are useful in certain situations. We will look at some of those situations here. Translation Matrices for 3D Coordinates:  A four-column matrix can only be multiplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors. Rotation and scaling transformation matrices only require three columns. But, in order to do translation, the matrices need to have at least four columns . This is why transformations are often $4 \times 4$ matices. However, a matrix with four columns cannot be multiplied by a 3D vector, due to the rules of matrix multiplication. A four-column matrix can only be mulitplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors. The 4th dimension $W$ is usually unchanged, when using homogeneous coordinates in matrix transformation. $W$ is set to $1$ when converting 3D coordinates into 4D, and is usually still $1$ after the transformation matrices are applied, at which point it can be converted back into a 3D coordinate by ignoring $W$. This is true for all translation, rotation, and scaling transformations, which by far are the most common types of transformations. The notable exception is projection matrices, which do affect the $W$ dimension. Perspective Transformation: In 3D, perspective is the phenomenon where an object appears smaller the further away it is from the camera. A far-away mountain can appear to be smaller than a cat, if the cat is close enough to the camera. Perspective is implemented in 3D computer graphics by using a transformation matrix that changes the $W$ element of each vertex. After the camera matrix is applied to each vertex, but before the projection matrix is applied, the $Z$ element of each vertex represents the distance away from the camera. Therefore, the larger $Z$ is, the more the vertex should be scaled down. The $W$ dimension affects the scale, so the projection matrix just changes the $W$ based on the $Z$ value. Here is an example of a perspective projection matrix being applied to a homogeneous coordinate:  $$ \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0&amp; \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;1&amp;0 \end{bmatrix} \begin{bmatrix} 2 \\ 3 \\ 4 \\ 1\end{bmatrix} = \begin{bmatrix} 2 \\ 3 \\ 4 \\ 1 \end{bmatrix} $$ Notice how the $W$ value is changed to $4$, which comes from the $Z$ value. After the perspective projection matrix is applied, each vertex undergoes perspective division. Perspective division is just a specific term for converting the homogeneous coordinate back to $W=1$, as explained earlier in the article. Continuing with the example above, the perspective division step would look like this:  $$\frac{1}{4}(2,3,4,4) = (0. 5,0. 75, 1,1)$$ After perspective division, the $W$ value is discarded, and we are left with a 3D coordinate that has been correctly scaled according to a 3D perspective projection. Positioning Directional Lights: One property of homogeneous coordinates is that they allow you to have points at infinity (infinite length vectors), which is not possible with 3D coordinates. Points at infinity occur when $W=0$. If you try to convert a $W=0$ homogeneous coordinate into a normal $W=1$ coordinate, it results in a bunch of divide-by-zero operations:  $$ \frac{1}{0}(2,3,4,0) = (\frac{2}{0}, \frac{3}{0}, \frac{4}{0}, \frac{0}{0})$$. This means that homogeneous coordinates with $W=0$ can not be converted back into 3D coordinates. What use does this have? Well, directional lights can be thought of as point lights that are infinitely far away. When a point light is infinitely far away, the rays of light become parallel, and all of the light travels in a single direction. This is basically the definition of a directional light. So, traditionally, in 3D graphics, directional lights are differentiated from point lights by the value of $W$ in the position vector of the light. If $W=1$, then it is a point light. If $W=0$, then it is a directional light. This is more of a traditional convention, rather than a useful way to write lighting code. Directional lights and point lights are usually implemented with separate code, because they behave differently. Summary: Homogeneous coordinates have an extra dimension called $W$, which scales the $X$, $Y$, and $Z$ dimensions. Matrices for translation and perspective projection can only be applied to homogeneous coordinates, which is why they are so common in 3D computer graphics. The $X$, $Y$, and $Z$ values are said to be correct when $W=1$. Any homogeneous coordinates can be converted to have $W=1$ by dividing all four dimensions by the $W$ value, except if $W=0$. When $W=0$, the coordinate represents a point at infinity (a vector with infinite length), and this is often used to denote the direction of directional lights. References:  Tomdalling‚Äôs Blog Post Image Processing and Computer Vision Lecture Notes"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});


    
function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




</ul>
<form class="bd-search hidden-sm-down" onsubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small" id="lunrsearch" name="q" value="" placeholder="Type keyword and enter..."> 
</form>
            
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        <div class="container">
    
 <!--endif page url is / -->
    


<!-- Now the rest of the posts with the usual loop but with an offset:4 on the first page so we can skeep the first 4 posts displayed above -->
    
<div class="row mt-3">
   
    <div class="col-md-8 main-loop">
        
        <h4 class="font-weight-bold spanborder"><span>All Stories</span></h4>
        

        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/rigid.html">3D Rigid Body Motion (Part 1)</a>
	</h2>
	<p class="excerpt">
	   
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Aug 31, 2021
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/rigid.html">
	<img height="150px" width="200px" src="/assets/images/rigid.png" alt="3D Rigid Body Motion (Part 1)">
	</a>
	</div>

</div>

        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/homogeneous.html">Homogeneous Coordinates and Projective Geometry</a>
	</h2>
	<p class="excerpt">
	   Introduction to Projective GeometryMost of the time when working with 3D, we are thinking in terms of Euclidean geometry-that is, coordinates in three-dimensional space ($X$, $Y$ and ...
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Aug 31, 2021
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/homogeneous.html">
	<img height="150px" width="200px" src="/assets/images/home.png" alt="Homogeneous Coordinates and Projective Geometry">
	</a>
	</div>

</div>

        
        
        
        <div class="mt-5">
         <!-- Pagination links -->
            
            <ul class="pagination"> 
              
                <li class="page-item"><a class="page-link" href="/">¬´ Prev</a></li>
              

              
                
                <li class="page-item"><a class="page-link" href="/">1</a></li>
                
              
                
                <li class="page-item disabled"><span class="webjeda page-link">2</span></li>
                
              

              
                <li class="page-item disabled"><span class="next page-link">¬ª</span></li>
              
            </ul>
                  
        </div>
        
    </div>
    
    <div class="col-md-4">
        <div class="sticky-top sticky-top-offset">
    <h4 class="font-weight-bold spanborder"><span>Featured</span></h4>  
    <ol class="list-featured">				
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/rigid2.html" class="text-dark">3D Rigid Body Motion (Part 2)</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/geometry.html" class="text-dark">Geometry</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/gan.html" class="text-dark">All About Training GAN</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/extrinsic.html" class="text-dark">Dissecting the Camera Matrix (Part 2)</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/pytorch.html" class="text-dark">Advanced PyTorch: Things You Didn't Know</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#pytorch">PyTorch</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/no-bullshit.html" class="text-dark">Guide to Linear Algebra (Part 1)</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#linear%20algebra">linear algebra</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/group-norm.html" class="text-dark">Batch Normalization and Group Normalization</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#deep%20learning">deep learning</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/disparity.html" class="text-dark">Depth from Disparity</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/camera.html" class="text-dark">Dissecting the Camera Matrix (Part 1)</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/depth.html" class="text-dark">Depth Estimation: Basics and Intuition</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/rigid.html" class="text-dark">3D Rigid Body Motion (Part 1)</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/homogeneous.html" class="text-dark">Homogeneous Coordinates and Projective Geometry</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#computer%20vision">computer vision</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
           
    </ol>
</div>     
    </div>
    
</div>



</div>

    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/custom.js"></script>
    

    <!-- Footer -->
    <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                <span class="navbar-brand mr-2 mb-0"><strong>Seri Lee</strong></span>
                <span>Copyright ¬© <script>document.write(new Date().getFullYear())</script>.</span>

                <!--  Github Repo Star Btn-->
                
            </div>
            </div>
        </div>
    </footer>

    <!-- All this area goes before </body> closing tag --> 


</body>

</html>

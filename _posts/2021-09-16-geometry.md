---
layout: post
title:  "Geometry"
author: seri
categories: [ computer vision ]
image: assets/images/pointvec.png
tags: featured
exerpt: "Geometry is a branch of mathematics concerned with questions of shape, size, relative position of figures, and the properties of space. Points, vectors, and matrices are instrumental in the process of making computer vision/graphics images; In this blog post, you will learn what these constructs are, how they work and the various techniques that can be used to manipulate them."
---

<!--more-->
<h2> Coordinate Systems </h2>

<h3> Introducing Coordinate Systems </h3>

Coordinate systems play an essential role in the graphics pipeline. They are not complicated; However, learning a few things about them will make it easier to understand matrices.

I mentioned that points and vectors (as used in computer vision/graphics) are represented with 3 real numbers. But what do these numbers mean? Each number represents <span class="blue"> a signed distance </span> from the origin of a line to the position of the point on that line. 

Consider drawing a line and putting a mark in the middle. We will call this mark origin. This mark becomes our point of reference: the position from which we will measure the distance to any other points. If a point lies to the right side of the origin, we take the signed distance to be greater than zero. On the other hand, if it is on the left side of the origin, the values will be negative.

Now that we have a line and an origin, we add some additional marks at a regular interval (unit length) on each side of the origin, effectively turning our line into a ruler. With the ruler established, we can simply use it to measure the coordinate of a point from the origin (coordinate is another way of saying the signed distance from the origin to the point). In mathematics, the ruler defines what we call <span class="red"> axis </span>. We have just learned to define the coordinate of a point along an axis. 

<h3> Dimensions and Cartesian Coordinate Systems </h3>

By placing two axes called $x$-axis and $y$-axis, we have defined a two dimensional space called a <span class="neon"> plane </span>. These two axes are said to define a coordinate system. <span class="underline"> If these two rulers are perpendicular to each other, they define what we call a Cartesian coordinate system. </span>

We now know how to make a two-dimensional Cartesian coordinate system and define the coordinates of a 2D point in that coordinate system. Note that <mark class="gold"> the coordinates of points defined in a coordinate system are unique </span>. The same point cannot be represented by two different sets of coordinates in one system. We are free to choose any coordinate system that we please. 

<picture><img src="{{site.baseurl}}/assets/images/axis2d.png" style="width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;"><img src="{{site.baseurl}}/assets/images/coor.png" style="width: 300px !important; float: left !important; margin: 0px 0px 25px 25px !important;"></picture>

In fact, we can choose to define infinitely many coordinate systems in a plane. Let's assume we drew two Cartesian coordinate system like the figure above. On this paper, we place one point. <span class="stroke"> The coordinates of that point will be different </span> depending on which of the two coordinate system we consider. 

<span class="highlight-gradient"> If you know the coordinates of $P$ in coordinate system $A$, </span> what do you need to do <span class="underline-pink"> to find the coordinate of the same point in another coordinate system $B$? </span> This represents an extremely important operation in computer vision, and we will soon learn why and how to find the map which translates the coordinates of a point from one coordinate system to another.

Another common operation is to move the point in the coordinate system $A$ to another location in the same coordinate system. This is called a <span class="gradient"> translation </span> and is certainly one of the basic operations you can do on points. 

Note that all sorts of other linear operators can be applied to point coordinates. A multiplication of a real number to the coordinate of point produces <span class="blue"> scale </span>. A scale moves $P$ along the line that is going through the point and the origin. That is because when we are transforming a point we are actually transforming the vector going from origin to the point. 

<h3> The Third Dimension </h3>

The 3D coordinate system is a simple extension of the 2D case. We will be adding a third axis orthogonal to both the $x$- and $y$-axis called the $z$-axis (representative of depth). In geometry, 3D coordinate system defines what is more formally known as <span class="blink"> Euclidean Space </span>. In linear algebra, the three axes from what we call the <span class="flow"> basis </span> of that coordinate system. 

A basis is a set of linearly independent vectors that, in a linear combination, can represent every vector (or point) in a given vector space (the coordinate system). 

<div class="sidenote"> Vectors from a set are said to be linearly independent if and only if none of the vectors in the set can be written as a linear combination of other vectors in that set. </div>

Change of basis, or change of coordinate system, is a common operation in mathematics and computer vision pipeline.

<h3> Left-Handed vs Right-Handed Coordinate Systems </h3>

<picture><img src="{{site.baseurl}}/assets/images/rhlh.png"></picture>

Unfortunately, due to various conventions concerning handedness, coordinate systems are not that simple. The problem can be illustrated in the following figure: when the up and forward vectors are oriented in the same way, an appropriate right vector can either point to the left or to the right.

To differentiate the two conventions, we call the first coordinate system the left-handed coordinate system, and the other, the right-handed coordinate system. 

<mark class="coral"> Remember that the middle finger always represent the right vector when checking the coordinate handedness. </mark> 

<div class="blockquote"> The handedness of the coordinate system also plays a role in the orientation of normals computed from the edges of polygonal faces. If the orientation is right-handed, then polygons whose vertices were specified in counterclockwise order will be front-facing. This will be explained in the part on rendering polygon objects. </div>

<h3> The Right, Up and Forward Vectors </h3>

The Cartesian coordinate system is only defined by three perpendicular vectors of unit length. As far as the mathematical notation is concerned, this coordinate system does not convey anything about what these three axes actually mean. The developer is the one that decides how these axes should be interpreted. It is thus very important to make a clear distinction between the handedness of the coordinate system and the conventions used to label the corresponding axes. 

The choice of coordinate system handedness also plays a critical role when it comes to rotation and the cross product of two vectors. It's actually easy enough (but painful) to go from one coordinate system to another. All that is needed is to scale the point coordinates and the camera-to-world matrix by $(1,1,-1)$. 

<h3> The World Coordinate System </h3>

In most 3D applications, each different type of coordinate system is defined with respect to a master coordinate system called the world coordinate system. It defines the origin and the main $x$,$y$,$z$-axes from which all other coordinate systems are defined. 

<h2> Math Operations on Points and Vectors </h2>

I have explained the concept of (Cartesian) coordinate system. Now we can look at some of the most common operations which can be performed on points and vectors. 

<h3> Vector Length </h3> 

The vector itself indicates not only the direction of point $B$ from $A$ but also can be used to find out the distance between $A$ and $B$. This is given by the length of a vector which can easily be computed with the following formula:

$$
\lVert V \rVert = \sqrt{x^2 + y^2 + z^2}
$$

<mark class="teal"> The vector's length is sometimes also called norm or magnitude. </mark> Note that the axes of the three-dimensional Cartesian coordinate systems are unit vectors. 

<h3> Normalizing a Vector </h3>

<span class="red"> A normalized vector is a vector whose length is 1.</span> Such a vector is also called a unit vector (it is a vector which has unit length). Normalizing a vector is very simple. We first compute the length of the vector and divide each one of the vector coordinates with this length. 

$$
\hat{V} = \frac{V}{\lVert V \rVert}
$$

In mathematics, you will also find the term norm to define a function that assigns a length or size (or distance) to a vector. The function we have just described is called the Euclidean norm.

<h3> Dot Product </h3>

The dot product or scalar product requires two vectors $A$ and $B$ and can be seen as the projection of one vector onto the other. The result of the dot product is a real number. A dot product between two vectors is denoted with the dot sign: $A \cdot B$ (it can also sometimes be written as $<A,B>$). 

The dot product consists of multiplying each element of the $A$ vector with its counterpart from vector $B$ and taking the sum of each product. In the case of 3D vectors (they have three coefficients of elements which are $x$, $y$ and $z$), it consists of the following operation:

$$
A \cdot B = A.x * B.x + A.y * B.y + A.z * B.z
$$

Note that this is quite similar to the way we compute the length of a vector. If we take the square root of the dot product between two vectors ($\sqrt{A \cdot B}$) that are equal ($A=B$), then what we get is the length of the vector. We can write:

$$
{\lVert V \rVert}^2 = V \cdot V
$$

<picture><img src="{{site.baseurl}}/assets/images/dotproduct.png" style="width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;"></picture>

The dot product between two vectors is an extremely important and common operation in any 3D application because the result of this operation relates to the cosine of the angle between the two vectors. In this example vector $A$ is projected in the direction of vector $B$. 

<ul><li> If $B$ is a unit vector then the product $A \cdot B$ gives $\lVert A \rVert \cos (\theta)$, the magnitude of the projection of $A$ in the direction of $B$, with a minus sign if the direction is opposite. This is called the scalar projection of $A$ onto $B$. </li>

<li> When neither $A$ nor $B$ is a unit vector, we can write that $A \cdot B / \lVert B \rVert$, since $B$ as a unit vector is $B/\lVert B rVert$. </li>

<li> In mathematics, $ {\cos}^{-1}$ is the inverse of the cosine function. When the two vectors are normalized ($A \cdot B / \lVert A \rVert \lVert B \rVert$), taking the arc cosine of the dot product gives you the angle $\theta$ between two vectors: $\theta = {\cos}^{-1}(A \cdot B / \lVert A \rVert \lVert B \rVert)$ or $\theta = {\cos}^{-1}(\hat{A} \cdot \hat{B})$. </li><ul>


<div class="sidenote"> <picture><img src="{{site.baseurl}}/assets/images/dot.png" style="width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;"></picture>
The dot product is a very important operation in 3D. It can be used for many things. As a test of orthogonality. When two vectors $A$,$B$ are perpendicular to each other, the result of the dot product between these two vectors is $0$. 

It is also used intensively to find out the angle between two vectors or compute the angle between a vector and the axis of a coordinate system. </div> 

<h3> Cross Product </h3>

The cross product is also an operation on two vectors. The difference between cross product and dot product is that the dot product returns a number, whereas the cross product returns a vector. 

The particularity of this operation is that <mark class="blue"> the vector resulting from the cross product is perpendicular to the other two. </mark> The cross product operation is written using the following syntax:

$$
C = A \times B
$$

<picture><img src="{{site.baseurl}}/assets/images/crossproduct.png" style="width: 300px !important;"></picture>

To compute the cross product we will need to implement the following formula:

$$
C_x = A_Y * B_Z - A_Z * B_Y
C_Y = A_Z * B_X - A_X * B_Z
C_Z = A_X * B_Y - A_Y * B_X
$$

The result of this cross product is another vector which is <span class="reveal">  orthogonal </span> to the other two. The two vectors $A$ and $B$ define a plane and the resulting vector $C$ is perpendicular to that plane. 

$A$ and $B$ don't have to be perpendicular to each other, but when they are, the resulting $A$, $B$ and $C$ vectors form a Cartesian coordinate system (assuming the vectors have unit length).

If you need a mnemonic way of remembering this formula, we like to use the technique that consists of asking ourselves the question "why z?". $y$ and $z$ being the coordinates of vector $A$ and $B$ used to compute the $x$ coordinates of the resulting vector $C$. 

It is important to note that the order of the vectors involved in the cross product has an effect on the resulting vector $C$. You can see that $A \times B$ doesn't give you the same result as $B \times A$. 

<h2> How Does Matrix Work </h2>

<h3> Point-Matrix Multiplication </h3>

Two matrices need to have compatible sizes in order to be multiplied with each other. For instance, the matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. 

Point can be written in a matrix form $P = [xyz]$. There is two things we need to remember. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point.

The second thing we need to remember is that a $m \times p$ matrix multiplied by $p \times n$ matrix, gives a $m \times n$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point.

<h3> The Identity Matrix </h3>

The identity matrix or unit matrix is a square matrix whose coefficients are all 0 except the coefficients along the diagonal which are set to $1$. 

$$
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

The result of $P$ multiplied by the identity matrix is $P$. 

<h3> The Scaling Matrix </h3>

When these coefficients of the identity matrix are different than 1 (whether smaller or bigger than 1), then they act as a multiplier on the point's coordinates. In other words, the points coordinates are scaled up or down by some amount.

$$
\begin{bmatrix}
S_X & 0 & 0 \\
0 & S_Y & 0 \\
0 & 0 & S_Z
\end{bmatrix}
$$

Note that <mark class="coral"> if either one of the scaling coefficiuent in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped </mark> (it will be mirrored to the other side of the matrix).

<h3> The Rotation Matrix </h3>

We are now talking about building a matrix that will rotate a point or a vector around one axis of the cartesian coordinate system. And for doing so, we will need to use trigonometric functions. 

<picture><img src="{{site.baseurl}}/assets/images/rotation-mat.png" style="width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;"><img src="{{site.baseurl}}/assets/images/rotation45.png" style="width: 300px !important; float: left !important; margin: 0px 0px 25px 25px !important;"></picture> 

Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of a rotation (we could do this with a translation but using a rotation will be easier). $P_T$ coordinates are $(0,1,0)$. 

As you can see, this can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ into $P_T$. 

$$
\begin{aligned}
P_T.x = P.x * R_{00} + P.y * R_{10} + P.z * R_{20} \\
P_T.y = P.x * R_{01} + P.y * R_{11} + P.z * R_{21} \\
P_T.z = P.x & R_{02} + P.y * R_{12} + P.z * R_{22}
\end{aligned}
$$

As we said, we don't care so much about $P_T.z$ for now which represents the $z$-coordinate of $P_T$. Let's concentrate instead on $P_T.x$ and $P_T.y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. It means that $R_{00}$ has to be equal to $0$. Considering that $P.y$ and $P.z$ are 0 anyway we don't care much about the values that $R_{10}$ and $R_{20}$ may be for now. 

What do we know about $P$? We know that $P.x$ is 1 and that all the other coordinates of $P$ are $0$. Which necessarily means that $R_{01}$ has to be 1. 

Let's recap. We know that $R_{00}$ is 0 and $R_{01}$ is 1. Let's write it down and see what $R$ looks like: (compare this matrix with the identity matrix)

$$
R_z = 
\begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
$$

If you use this matrix to transform $P=(1,0,0)$ you will get $P_T = (0,1,0)$.

<h2> How Does Matrix Work? </h2>

<h3> Point-Matrix Multiplication </h3>

We will start to put all the things we have learned on points, vectors, matrices and coordinate systems together. We mentioned that two matrices needed to have compatible sizes in order to be multiplied with each other. The matrices of size $m \times p$ and $p \times n$ can be multiplied with each other. In computer vision, we would primarily deal with $4 \times 4$ matrices. 

A point or a vector is a sequence of three numbers and for this reason they too can be written as a $1 \times 3$ matrix, a matrix that has one row and three columns. Point written in a matrix form $P=[xyz]$. 

The trick here is that, if we can write points and vectors as $1 \times 3$ matrices, we can multiply them by other matrices. Remember that the matrix $m \times p$ can be multiplied by the matrix $p \times n$ to give the matrix $m \times n$. So this implies that we can multiply something of the form $3 \times n$ where n can be any number greater than 1. 

There is two things we need to remember now to make sense of what we are going to explain. The first one is that a point multiplied by a matrix transforms the point to a new position. The result of a point multiplied by a matrix has to be a point. If it wasn't the case, we wouldn't be using matrices as a convenient way of transforming points. The second thing we need to remember is that a $m \times p$ matrix multiplied by a $p \times n$ matrix, gives a $m \times n$ matrix. 

If we look at our point as a $1 \times 3$ matrix, we need the result of the multiplication to be another point, that is a $1 \times 3$ matrix. Multiplying a $1 \times 3$ matrix by a $3 \times 3$ matrix gives as expected, a $1 \times 3$ matrix which is another point. 

<h3> The Identity Matrix </h3>

The identity matrix or unit matrix is a square matrix whose coefficients are all $0$ except the coefficients along the diagonal which are set to $1$.

$$
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

The result of $P$ multiplied by the identity matrix is $P$.

<h3> The Scaling Matrix </h3>

If you look at the code of the point-matrix multiplication, you can see that the coordinates of the point $P$ are respectively multiplied by the coefficients $R_{00}$ for $x$, $R_{11}$ for $y$, and $R_{22}$ for $z$. When these coefficients are set to $1$ (and all the other coefficients are set to $0$), we get the identity matrix. 

However, when these coefficients (along the diagonal) are different than $1$ (whether smaller or bigger than $1$), then they act as a multiplier on the point's coordinates (in other words, the points coordinates are scaled up or down by some amount). If you remember what we have said about coordinate systems, multiplying the coordinates ofa point by some real numbers result in scaling the point's coordinates. The scaling matrix can therefore be written as:

$$
\begin{bmatrix}
S_X & 0 & 0 \\
0 & S_Y & 0 \\
0 & 0 & S_Z
\end{bmatrix}
$$

Note that if either one of the scaling coefficients in the matrix are negative, then the point's coordinate for the corresponding axis will be flipped (it will be mirrored to the other side of the axis). 

<h3> The Rotation Matrix </h3>

What we will be talking about now is about building a matrix that will rotate a point or a vector around one axis of the Cartesian coordinate system. And for doing so, we will need to use trigonometric functions. 

Let's take a point $P$ defined in a three-dimensional coordinate system with coordinate $(1,0,0)$. Let's ignore the $z$-axis for a while and assume that the point lies in the $xy$ plane. What we want is to transform the point from $P$ to $P_T$ by the mean of rotation (we could do this with a translation but using a rotation will make our demonstration easier). $P_T$ coordinates are $(0,1,0)$. This can be done by rotating the point around the $z$-axis by $90$ degrees counterclockwise. Let's assume now that we have a matrix $R$. When $P$ is multiplied by $R$ it transforms $P$ to $P_T$. Considering what we know about matrix multiplication let's see how we can re-write a point-matrix multiplication and isolate the computation of each of the transformed coordinates. 

$$
\begin{aligned}
P_T.x = P.x * R_{00} + P.y * R_{10} + P.z * R_{20} \\
P_T.y = P.x * R_{01} + P.y * R_{11} + P.z * R_{21} \\
P_T.z = P.x * R_{02} + P.y * R_{12} + P.z * R_{22}
\end{aligned}  
$$

As we said, we don't care so much about $P_T.z$ for now which represents the $z$-coordinate of $P_T$. Let's concentratte instead on $P_T.x$ and $P_T.y$ which represent respectively the $x$ and $y$ coordinates of $P_T$. From $P$ to $P_T$, the $x$-coordinate goes from $1$ to $0$. If we look at the first line of the code we wrote to compute $P_T$, it means that $R_{00}$ has to be equal to 0. Considering that $P.y$ and $P.z$ are $0$ anyway we don't care so much about the values that $R_{10}$ and $R_{20}$ may have for now. From P to $P_T$, the $y$-coordinate goes from $0$ to $1$. Let's have a look at the second line of code. What do we know about $P$? We know that $P.x$ is $1$ and that all the other coordinates of $P$ are $0$, which necessarily means that $R_{01}$ has to be $1$. Let's recap. We know that $R_{00}$ is $0$ and $R_{01}$ is $1$. Let's write it down and see what $R$ looks like (compare this matrix with the identity matrix):

$$
R_z = 
\begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 
\end{bmatrix}
$$

Don't worry for now if you don't understand why the coefficients have the value they have. That will be explained soon. All you want to see, is that if you use this matrix to transform $P=(1,0,0)$ you will get $P_T=(0,1,0)$.

$$
\begin{aligned}
P_T.x = P.x * 0 + P.y * 1 + P.z * 0 = 0 \\
P_T.y = P.x * 1 + P.y * 0 + P.z * 0 = 1 \\
P_T.z = P.x * 0 + P.y * 0 + P.z * 1 = 0
\end{aligned}
$$

This is where our knowledge of trigonometric functions will become handy. If we look at a point on the unit circle we know that its $x$ and $y$ coordinates can be computed using the sine and cosine of the angle $\theta$. 

$$
\begin{aligned}
x = cos(\theta) = 0 \\
y = sin(\theta) = 1 \\
\theta = \frac{\pi}{2}
\end{aligned}
$$

When $\theta=0$, $x=1$ and $y=0$. When $\theta = 90$ degrees (or $\frac{\pi}{2}$), $x=0$ and $y=1$. That is interesting because you will notice that $x=0$ and $y=1$ are values of $R_{00}/R_{11}$ and $R_{01}/R_{10}$ respectively. So we could re-write the matrix $R$ as:

$$
R_z(\theta) = 
\begin{bmatrix}
cos(\theta) & sin(\theta) & 0 \\
sin(\theta) & cos(\theta) & 0 \\
0 & 0 & 1
\end{bmatrix}
= 
\begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 
\end{bmatrix}
$$

<h3> Combining Rotation Matrices </h3>

We have learned that multiplying matrices together combines their transformations. Now that we know how to rotate points around individual axis, it is possible to multiply $R_x$, $R_y$, $R_z$ together to create more complex rotations. If for instance you want to rotate a point around the $x$-axis, and then the $y$-axis, you can create two matrices using the matrices $R_x$ and $R_y$ and combine them using matrix multiplication $R_x * R_y$ to create a $R_{xy}$ matrix encoding the two individual rotations. 

Note that the order of the rotation is important and makes a difference. If you rotate a point around the $x$-axis first and then the $y$-axis second, you will end up with a result which is different from a rotation around the $y$-axis and then around the $x$-axis. 

<h3> Relation Between Matrices and Cartesian Coordinate System </h3>

If you imagine that you have a point $P_x$ with coordinates $(1,0,0)$ and want to rotate this point around the $z$-axis by 10 degrees clockwise, we know that these new coordinates can be found using simple trigonometry. 

<h3> Orthogonal Matrices </h3>
 
In fact, the type of matrices we ahve described (the rotation matrices) are called in linear algebra, orthogonal matrices. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors.

We have mentioned previously that each row from the matrix represents an axis of a Cartesian coordinate system. If the matrix is a rotation matrix or the result of several rotation matrices multiplied with each other, then each row necessarily represents an axis of unit length (because the elements of the rows are constructed from the sine and cosine trigonometric functions which are used to compute the coordinates of points lying on the unit circle). You can see them as a Cartesian coordinate system which is originally aligned with the world coordinate system (the identity matrix's rows represent the axes of the world coordinate system) and rotated around one particular axis or a random axis. Orthogonal matrices have a few interesting properties but maybe the most useful one in computer vision, is that the transpose of an orthogonal matrix is equal to its inverse. Assuming $Q$ is an orthogonal matrix, we can write:

$$
Q^T = Q^{-1}
$$ 

which entials that $QQ^T = I$, where $I$ is the identity matrix.

<h3> Affine Transformations </h3>

You will sometimes find the terms affine transformations used in place of matrix transformation. This technical term is actually more accurate to designate the transformations that you get from using the type of matrices we have described so far. 

In short, an affine transformation, is a transformation that preserves straight lines. The translation, rotation, shearing matrix are all affine transformations as are their combinations. The other type of transformation we will be studying in computer vision are called projective transformations (perspective projection is a projective transformation). As you may have guessed, such transformations do not necessarily preserve parallelism between lines. 

Not only you have learned how to create rotation matrices but we have also given you a way of visualizing what a matrix is: each row of the matrix represents one axis of a Cartesian coordinate system. The orientation (rotation), size (scale), and position (translation) of this coordinate system represents the transformation that will be applied to the points when they are multiplied by this matrix. 

The key idea is that points are originally defined in a certain coordinate system. If a point is attached to a local coordinate system $B$ (the matrix) and that we move, rotate, and translate that local coordinate system (i.e. the matrix), the point coordinates will not change in regard to the local coordinate system $B$. The point is somehow constrained to the transformation applied to the local coordinate system $B$. However, the coordinates of that point will change in the coordinate system $A$. 

Multiplying the point whose coordinates are expressed in regards to $A$ by the matrix $B$ will provide us with the point's new coordinates in the coordinate system $A$. What you need to remember is how to find the formula for the basic rotation matrices. That the order by which you multiply this basic matrices is important. And finally (and that's almost the most important) that a matrix can be seen as a local Cartesian system where each row of the matrix represents one axis of that local coordinate system. Such matrix is called an orientation matrix. 

<h2> Transforming Points and Vectors </h2>

Even though translation seems to be the easiest linear operator that can be applied to point, we haven't mentioned it often in the previous chapter. Because to get the translation working with the theory of matrix multiplication, we need to make a change to the point structure that might confuse you slightly. 

As we mentioned in the last two chapters, a matrix-matrix multiplication can only work if the two matrices involved have a compatible size. That is if they have the size $m \times p$ and $p \times n$. Let's keep that in mind.

Let's start from a $3 \times 3$ identity matrix. We know that a point multiplied by this matrix have its coordinates unchanged. Let's see what changes we need to bring to that matrix to handle translation. Translation on a point is nothing more than adding a number to each of its coordinates (these numbers can be positive or negative). For instance if we want to move the point $(1,1,1)$ to the coordinate $(2,3,4)$ we need to add values $1$,$2$ and $3$ respectively to each of the points' $x$, $y$ and $z$ coordinates. It is very simple. Note that from now on, we will keep looking at points and vectors as matrix of size $1 \times 3$. 

Let's get back to the code that transforms a point using a matrix. What do we need to get the rotation matrix extended so that it handles translation as well? We would need to be able to have a fourth term to the right that would encode translation.

Now remember that we want to come up with a matrix that encodes scale, rotation, and translation. So, somehow we need to get $T_x$, $T_y$, $T_z$ to fit within the code of point-matrix multiplication (and store these three values somewhere in the matrix). 

Look at the first line for now. Note that to compute $x', we only use the coefficients ofthe matrix first column. If the column had four coefficients instead of three, then $T_x$ would be $M_{30}$. The same reasoning can be done with $T_y$ and $T_z$. 

However, this is assuming that our matrix now has the size $4 \times 3$ not $3 \times 3$ anymore. This is alright. We said that matrices could have any size. However, we know that matrix multiplication can be valid if their sizes are compatible. 

We try to multiply a point $1 \times 3$ matrix with a $4 \times 3$ matrix and theory tells us that this is not possible. What shall we do? The solution is simple. We will add one additional column to the point to turn it into a $1 \times 4$ matrix and set the fourth coefficient of this point to $1$. Our point now looks like this $(x,y,z,1)$. In computer vision, it is called a homogeneous point (or a point with homogeneous coordinates). With such a point we can easily encode translation in our matrix. 

This is the theory. In order to encode translation, scale and rotation in a matrix we need to deal with points that have homogeneous coordinates. But because the fourth value is always $1$ we never really explicitly define it in the code. We only define $x$,$y$,$z$ and assume that there is a fourth value. 

Our matrix is now a $4 \times 3$ matrix. So you may wonder, how do we go from $4 \times 3$ matrix to our final $4 \times 4$ matrix which is the form that is the most commonly used in computer vision? The fourth columns plays a role in perspective projection and for some other type of transformations that are not very common (such as the shear transformation), but generally it is simply set to $(0,0,0,1)$. 

What happens though when the coefficients of this column have different values than the default (we said its uncommon but it happens sometimes)? Before we can answer this question, we first need to learn a few things more about homogeneous points. 

<h3> The Trick About Homogenous Points </h3>

Presenting a point as an homogeneous point is necessary to allow point-multiplication by $4 \times 4$ matrices however, in the code, this is only done implicitly, since as we have explained, $w$ is always $1$. 

But as we mentioned briefly, this fourth column is not always set to $(0,0,0,1)$ particularly when you deal with projection matrices (matrices that can project points to the screen). In these special cases, the result for $w'$ can be different than $1$ (which is intentional) but for this point to be usable as a Cartesian point, we need to normalize $w'$ back to $1$ by dividing it by itself which requires to divide the other coordinates ($x'$,$y'$ and $z'$) by $w'$ as well. 

As you can see we don't need to declare a $w$ coordinate in the Point's type. We can just compute a value for $w'$ on the fly as we assume implicitly that the point we are transforming is a Cartesian point which you can see as a homogeneous point whose $w$ coordinate is not declared explicitly (because it's always equal to 1). However, if the matrix we are multiplying the point with is a projection matrix for instance, the result of $w'$ might be different than $1$. In this particular caase, we need to normalize all the coordinates of $P'$ to set it back to $1$. Once this is done, we get a point which we can use in our Cartesian coordinate system again.

All you need to remember is that generally, you will never have to care about homogeneous coordinates, expect when points are multiplied by a perspective projection matrix. However, you will actually probably not come across this issue if you work on a ray tracer, as this special type of matrix is not used in ray tracing.

<h3> Transforming Vectors </h3>

Vectors somehow are simpler to transform than points. Vectors, as we said in the preamble of this lesson, represent direction whereas points represent position in space. As such vectors do not need to be translated because their position is in fact meaningless. With vectors we are only interested in the direction in which they point and eventually their length which is sometimes an information we need to solve geometric or shading problems. 

Vectors can be transformed like we transformed point but we can remove the part of the code that is responsible for the translation bit. 

Now that the matrix has size $4 \times 4$ we need to extend the size of the point by adding an extra coordinate. We can do this by implicitly treating points as homogeneous points but to continue using them in a Cartesian coordinate system (as Cartesian points) we need to be sure that $w$, this fourth coordinate is always set to $1$. Most of the time the matrices we use to transform a point will have their fourth column set to $(0,0,0,1)$ and with these matrices, the value of $w'$ should always be $1$. However, in special cases (projection matrix, shear transform) the value of $w'$ might be different than $1$ in which case you will need to normalize it (we divide $w'$ by itself) which requires to also divide the other transformed coordinates $x'$, $y'$, and $z'$ by $w'$.

Matrices are not the only method to encode or store transformations. You can also for instance represent a rotation using a method proposed initially by Euler. The idea is to define a rotation in this casae as a vector and an angle representing a rotation around the vector. 

While uncommon, both techniques are used to solve problems in computer vision from time to time. Rotations in computer vision are also commonly done using quaternions. Matrices themselves have certain limitations especially when it comes to rotation by an angle greater than $360$ degrees. This can lead to a problem known as the gimbal lock. Matrices are also hard to interpolate which is often needed in rendering to compute the motion blur of objects. For this particular reason, quaternions are generally preferred though they are considered to be generally harder to understand. 

<h2> Row Major and Column Major Vector </h2>

Earlier in this lession, we have explained that vectors (or points) can be written down as $1 \times 3$ matrices (one row, three columns). Note however that we could have also written them down as $3 \times 1$ matrices (three rows, one column). Technically, these two ways of expressing points and vectors as matrices are perfectly valid and choosing one mode or the other is just a matter of convention.

In the first example, we have expressed our vector or point in what we call the row-major order: the vector (or point) is written as a row of three numbers. In the second example, we say that points or vectors are written in column-major order: we write the three coordinates of the vector or point vertically, as a column.

Remember that we express points and vectors as matrices to multiply them by $3 \times 3$ transformation matrices (for the sake of simplicity we will work with $3 \times 3$ rather than $4 \times 4$ matrices).

So what do we do? We move the point or vector to the right side of the multiplication. Note that the result of this operation is a transformed poitn written in the form of a $3 \times 1$ matrix. So we get a point to start with and we finish with a transformed point which is what we want. Problem solved. To summarize, when by convention we decide to express vectors or points in row-major order, we need to put the point on the left side of the multiplication and the $3 \times 3$ on the right inside of the multiplication sign. This is called in mathematics, a left or pre-multiplication. If you decide to write the vectors in column-major order, matrix needs to be on the left side of the multiplication and the vector or point on the right side. This is called a right or post-multiplication. 

Multiplying a point or a vector by a matrix should give us the same result whether we use row- or column-major order. If you use a 3D application to rotate a point by a certain angle around the $z$-axis, you expect the point to be in certain position after the rotation no matter what internal convention the developer used to represent points and vectors. 

Multiplying a row-major and column-major point (or vector) by the same matrix clearly wouldn't give us the same result. We would actually need to transpose the $3 \times 3$ matrix used in the column-major multiplication to be sure that $x'$,$y'$, and $z'$ are the same.

In conclusion, going from row-major order to column-major order not only involves to swap the point or vector and the matrix in the multiplication but also to transpose the $3 \times 3$ matrix, to guarantee that both conventions give the same result (and vice versa).

From these observations, we can see that any series of transformations applied to a point or a vector when a row-major convention is used can be written in sequential order. Imagine for instance that you wnat to translate point $P$ with matrix $T$ then rotate it around the $z$-axis with $R_z$ then around the $y$-axis with $R_y$. You can write:

$$
P' = P * T * R_z * R_y
$$

If you were to use a column-major notation you would need to call the transform in reverse order (which one might find counter-intuitive):

$$
P' = R_y * R_z * T * P
$$

Order of transformation when we use column-major matrices is more similar in mathematics to the way we write function evaluation and composition.

<h3> Implication in Coding </h3>

There is another potentially very important aspect to take into consideration if you need to choose between row-major and column-major, but this has nothing to do really with the conventions themselves and how practical one is over the other. It has more to do with the computer and the way it works. 

Typically the implementation of a matrix are laid out contiguouosly in memory. In the world of computing, accessing elements from an array in a non-sequential order, is not necessarily a good thing. It actually potentially degrades the cache performance of the CPU. 

Applied to our matrix problem, accessing the coefficients of the matrix in non-sequential order can therefore be a problem. Assuming the CPU loads the requested float in the cache plus 3 floats next to it, our current implementation might lead to many cache misses, since the coefficients used to compute $x'$, $y'$ and $z'$ are 5 floats apart in the array. 

On the other hand, if you use a column-major order notation, computing $x'$ for instance requires to access the 1st, 2nd and 3rd element of the matrix. In conclusion, we can say that form a programming point of view, implementing our point- or vector-matrix multiplication using a column-major order convention might be better, performance wise, than the version using the row-major order convention. 

<h2> Matrix Operations </h2>
<h3> Transpose </h3>

The transpose of a matrix $M$ is another matrix which we write using the following convention: $M^T$. We can describe the process of transposing a matrix in different ways. It can be seen as: reflecting $M$ over its main diagonal to obtain $M^T$, writing the rows of $M$ as the columns of $M^T$ or reciprocally, writing the columns of $M$ as the rows of $M^T$. 

The idea is to swap the rows and columns and since the operation can't be done in place we need to assign the result to a new matrix which is returned by the function. Transposing matrices can be useful when you want to convert matrices from a 3D application using row-major matrices to another using a column-major convention (and vice versa).

<h3> Inverse </h3>

If the multiplying point $A$ by the matrix $M$ gives point $B$, multiplying a point $B$ the inverse of the matrix $M$ gives point $A$. In mathematics, a matrix inversion is usually written using the following notation:

$$
M^{-1}
$$

From this observation, we can write that:

$$
MM^{-1} = I
$$

where $I$ is the identity matrix. Multiplying a matrix by its inverse gives the identity matrix. We have mentioned the case of the orthogonal matrix which inverse can easily be obtained from computing its transpose. An orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors. 

Matrix inversion is an important process in 3D. We know that we can use point- or vector-matrix multiplication to convert points and vectors but it is sometimes useful to be able to move the transformed points or vectors back into the coordinate system in which they were originally defined into. It is often necessary for instance, to transform the ray direction and origin in object space to test for a primitive-ray intersection. If there is an intersection resulting hit point is in object space and needs to be converted back into world space to be usuable.

<h2> Spherical Coordinates and Trigonometric Functions </h2>

Besides points, vectors, normals and matrices the last useful technique from linear algebra we will need to render images is to express vectors in terms of spherical coordinates. We could certainly render images without using them, but you will see that using them simplifies many problems especially when it comes to shading. 

<h3> Trigonometric Functions </h3>

Rendering a computer generated images is almost entirely a geometric problem so not understanding or using trigonometry for creating such images would be very hard. Let's start to review the sine and cosine function as well as the way angles can be computed from 2D coordinates. Usually these functions are defined in regards to the unit circle (a circle of radius 1). When we draw a point $P$ on this unit circle, the $x$-coordinate of the point can be computed using the cosine of the angle subtended by the $x$-axis and a line that goes from the origin of the coordinate system to $P$. This angle is usually called $\theta$. Similarly, the sine of this angle gives the $y$-coordinate of the point $P$. Note that angle $\theta$ is defined in radians. ${\theta}_{radians} = \frac{\pi}{180}{\theta}_{degrees}$. Remember that a complete turn around the unit circle represents 360 degrees of $2\pi$. 

It is also important to remember that the cosine, sine and tangent functions are defined from a simple relationship between the edges of a right triangle (right-angled triangle). The tangent formula is interesting because to come back to our example using the unit circle, you can see that it can be computed using the ratio of $y$ over $x$. 

Another very useful function in computer graphics is the arctangent which is the tangent inverse function. In other words, if you feed the arctangent function with the result of tangent function you get $\theta$. In programming you can use the `atan` function but this function doesn't take the sign of the parameters $x$ and $y$ into account. To fix the issue, you need to use the `atan2` instead which takes into account the sign of the point's coordinates in the computation of the angle. Similarly to `atan2`, you can compute the inverse of sine and cosine using arcsine and arccosine. 

$$
\begin{aligned}
\theta = acos(P_x) \\
\theta = asin(P_y) \\
\theta = atan2(P_y, P_x)
\end{aligned}
$$

The interesting thing to note is that the angle returned by the `atan2` function is positive for counter-clockwise angles (upper half-plane, $y>0$) and negative for clockwise angles (lower half-plane, $y<0$). It produces results in the range $[-\pi, \pi]$. 

<h3> Representing Vectors with Spherical Coordinates </h3>

So far we have learned how to represent vectors (as in directions) using Cartesian coordinates (with three values, one for each axis). It is also possible though to represent the same vectors with only two values. 


<h2> References </h2>
<ul><li><a href="https://www.scratchapixel.com"> scratchpixel </a></li>
</ul>


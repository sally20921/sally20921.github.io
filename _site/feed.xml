<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-10-17T13:10:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Seri Lee Blog</title><subtitle>This is where I write posts about my research field.</subtitle><entry><title type="html">A Machine Learning Primer</title><link href="http://localhost:4000/linear.html" rel="alternate" type="text/html" title="A Machine Learning Primer" /><published>2021-10-17T00:00:00+09:00</published><updated>2021-10-17T00:00:00+09:00</updated><id>http://localhost:4000/linear</id><content type="html" xml:base="http://localhost:4000/linear.html">&lt;!--more--&gt;

&lt;h2&gt; Fundamentals of Linear Regression &lt;/h2&gt;

&lt;p&gt;In this section, we investigate one of the most common and widely used machine learning techniques: linear regression.&lt;/p&gt;

&lt;p&gt;Linear regression is a very intuitive supervised learning algorithm and as its name suggests, it is a regression technique. This means that is is used &lt;span class=&quot;underline&quot;&gt; when we have labels that are continuous values &lt;/span&gt; such as car prices or the temperature in a room.&lt;/p&gt;

&lt;p&gt;Linear regression seeks to find fits of data that are lines. What does this mean?&lt;/p&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/disparity.png&quot; /&gt;&lt;/picture&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;a=href=&quot;&quot;&amp;gt; TheAILearner &amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="machine learning" /><category term="featured" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/depth/1.jpg" /><media:content medium="image" url="http://localhost:4000/assets/images/depth/1.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Image Processing: the Basics</title><link href="http://localhost:4000/paradox.html" rel="alternate" type="text/html" title="Image Processing: the Basics" /><published>2021-10-17T00:00:00+09:00</published><updated>2021-10-17T00:00:00+09:00</updated><id>http://localhost:4000/paradox</id><content type="html" xml:base="http://localhost:4000/paradox.html">&lt;!--more--&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/disparity.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Once I realized that my should and shouldn’t instructions were part of what was getting in the way, I began to explore ways of helping student learn without them. I would hasten to say that I wasn’t asking him to make any change, but just to observe what was happening.&lt;/p&gt;

&lt;p&gt;What amazed me was that in this nonjudgemental mode of observation of the ball, many of the technical elements of his swings would change spontaneously. The body was allowed its natural response to the perception of the ball, which was to step into it and hit it. This felt better and naturally produced better results.&lt;/p&gt;

&lt;p&gt;As coach, my first responsibility was to maintain a nonjudgemental focus, provide appropriate opportunity for natural learning, and stay out of the way. Paradoxicall,y it is conscious acceptance of oneself and one’s actions as they are that frees up both the incentive and the capacity for spontaneous change.&lt;/p&gt;

&lt;p&gt;Performance was equal to one’s potential after the interference factor had been subtracted from the equation.&lt;/p&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;a=href=&quot;&quot;&amp;gt; TheAILearner &amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/depth/1.jpg" /><media:content medium="image" url="http://localhost:4000/assets/images/depth/1.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Geometry</title><link href="http://localhost:4000/geometry.html" rel="alternate" type="text/html" title="Geometry" /><published>2021-09-16T00:00:00+09:00</published><updated>2021-09-16T00:00:00+09:00</updated><id>http://localhost:4000/geometry</id><content type="html" xml:base="http://localhost:4000/geometry.html">&lt;!--more--&gt;
&lt;h2&gt; Coordinate Systems &lt;/h2&gt;

&lt;h3&gt; Introducing Coordinate Systems &lt;/h3&gt;

&lt;p&gt;Coordinate systems play an essential role in the graphics pipeline. They are not complicated; However, learning a few things about them will make it easier to understand matrices.&lt;/p&gt;

&lt;p&gt;I mentioned that points and vectors (as used in computer vision/graphics) are represented with 3 real numbers. But what do these numbers mean? Each number represents &lt;span class=&quot;blue&quot;&gt; a signed distance &lt;/span&gt; from the origin of a line to the position of the point on that line.&lt;/p&gt;

&lt;p&gt;Consider drawing a line and putting a mark in the middle. We will call this mark origin. This mark becomes our point of reference: the position from which we will measure the distance to any other points. If a point lies to the right side of the origin, we take the signed distance to be greater than zero. On the other hand, if it is on the left side of the origin, the values will be negative.&lt;/p&gt;

&lt;p&gt;Now that we have a line and an origin, we add some additional marks at a regular interval (unit length) on each side of the origin, effectively turning our line into a ruler. With the ruler established, we can simply use it to measure the coordinate of a point from the origin (coordinate is another way of saying the signed distance from the origin to the point). In mathematics, the ruler defines what we call &lt;span class=&quot;red&quot;&gt; axis &lt;/span&gt;. We have just learned to define the coordinate of a point along an axis.&lt;/p&gt;

&lt;h3&gt; Dimensions and Cartesian Coordinate Systems &lt;/h3&gt;

&lt;p&gt;By placing two axes called $x$-axis and $y$-axis, we have defined a two dimensional space called a &lt;span class=&quot;neon&quot;&gt; plane &lt;/span&gt;. These two axes are said to define a coordinate system. &lt;span class=&quot;underline&quot;&gt; If these two rulers are perpendicular to each other, they define what we call a Cartesian coordinate system. &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We now know how to make a two-dimensional Cartesian coordinate system and define the coordinates of a 2D point in that coordinate system. Note that &lt;mark class=&quot;gold&quot;&gt; the coordinates of points defined in a coordinate system are unique &amp;lt;/span&amp;gt;. The same point cannot be represented by two different sets of coordinates in one system. We are free to choose any coordinate system that we please.&lt;/mark&gt;&lt;/p&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/axis2d.png&quot; style=&quot;width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;&quot; /&gt;&lt;img src=&quot;/assets/images/coor.png&quot; style=&quot;width: 300px !important; float: left !important; margin: 0px 0px 25px 25px !important;&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;In fact, we can choose to define infinitely many coordinate systems in a plane. Let’s assume we drew two Cartesian coordinate system like the figure above. On this paper, we place one point. &lt;span class=&quot;stroke&quot;&gt; The coordinates of that point will be different &lt;/span&gt; depending on which of the two coordinate system we consider.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;highlight-gradient&quot;&gt; If you know the coordinates of $P$ in coordinate system $A$, &lt;/span&gt; what do you need to do &lt;span class=&quot;underline-pink&quot;&gt; to find the coordinate of the same point in another coordinate system $B$? &lt;/span&gt; This represents an extremely important operation in computer vision, and we will soon learn why and how to find the map which translates the coordinates of a point from one coordinate system to another.&lt;/p&gt;

&lt;p&gt;Another common operation is to move the point in the coordinate system $A$ to another location in the same coordinate system. This is called a &lt;span class=&quot;gradient&quot;&gt; translation &lt;/span&gt; and is certainly one of the basic operations you can do on points.&lt;/p&gt;

&lt;p&gt;Note that all sorts of other linear operators can be applied to point coordinates. A multiplication of a real number to the coordinate of point produces &lt;span class=&quot;blue&quot;&gt; scale &lt;/span&gt;. A scale moves $P$ along the line that is going through the point and the origin. That is because when we are transforming a point we are actually transforming the vector going from origin to the point.&lt;/p&gt;

&lt;h3&gt; The Third Dimension &lt;/h3&gt;

&lt;p&gt;The 3D coordinate system is a simple extension of the 2D case. We will be adding a third axis orthogonal to both the $x$- and $y$-axis called the $z$-axis (representative of depth). In geometry, 3D coordinate system defines what is more formally known as &lt;span class=&quot;blink&quot;&gt; Euclidean Space &lt;/span&gt;. In linear algebra, the three axes from what we call the &lt;span class=&quot;flow&quot;&gt; basis &lt;/span&gt; of that coordinate system.&lt;/p&gt;

&lt;p&gt;A basis is a set of linearly independent vectors that, in a linear combination, can represent every vector (or point) in a given vector space (the coordinate system).&lt;/p&gt;

&lt;div class=&quot;sidenote&quot;&gt; Vectors from a set are said to be linearly independent if and only if none of the vectors in the set can be written as a linear combination of other vectors in that set. &lt;/div&gt;

&lt;p&gt;Change of basis, or change of coordinate system, is a common operation in mathematics and computer vision pipeline.&lt;/p&gt;

&lt;h3&gt; Left-Handed vs Right-Handed Coordinate Systems &lt;/h3&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/rhlh.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Unfortunately, due to various conventions concerning handedness, coordinate systems are not that simple. The problem can be illustrated in the following figure: when the up and forward vectors are oriented in the same way, an appropriate right vector can either point to the left or to the right.&lt;/p&gt;

&lt;p&gt;To differentiate the two conventions, we call the first coordinate system the left-handed coordinate system, and the other, the right-handed coordinate system.&lt;/p&gt;

&lt;p&gt;&lt;mark class=&quot;coral&quot;&gt; Remember that the middle finger always represent the right vector when checking the coordinate handedness. &lt;/mark&gt;&lt;/p&gt;

&lt;div class=&quot;blockquote&quot;&gt; The handedness of the coordinate system also plays a role in the orientation of normals computed from the edges of polygonal faces. If the orientation is right-handed, then polygons whose vertices were specified in counterclockwise order will be front-facing. This will be explained in the part on rendering polygon objects. &lt;/div&gt;

&lt;h3&gt; The Right, Up and Forward Vectors &lt;/h3&gt;

&lt;p&gt;The Cartesian coordinate system is only defined by three perpendicular vectors of unit length. As far as the mathematical notation is concerned, this coordinate system does not convey anything about what these three axes actually mean. The developer is the one that decides how these axes should be interpreted. It is thus very important to make a clear distinction between the handedness of the coordinate system and the conventions used to label the corresponding axes.&lt;/p&gt;

&lt;p&gt;The choice of coordinate system handedness also plays a critical role when it comes to rotation and the cross product of two vectors. It’s actually easy enough (but painful) to go from one coordinate system to another. All that is needed is to scale the point coordinates and the camera-to-world matrix by $(1,1,-1)$.&lt;/p&gt;

&lt;h3&gt; The World Coordinate System &lt;/h3&gt;

&lt;p&gt;In most 3D applications, each different type of coordinate system is defined with respect to a master coordinate system called the world coordinate system. It defines the origin and the main $x$,$y$,$z$-axes from which all other coordinate systems are defined.&lt;/p&gt;

&lt;h2&gt; Math Operations on Points and Vectors &lt;/h2&gt;

&lt;p&gt;I have explained the concept of (Cartesian) coordinate system. Now we can look at some of the most common operations which can be performed on points and vectors.&lt;/p&gt;

&lt;h3&gt; Vector Length &lt;/h3&gt;

&lt;p&gt;The vector itself indicates not only the direction of point $B$ from $A$ but also can be used to find out the distance between $A$ and $B$. This is given by the length of a vector which can easily be computed with the following formula:&lt;/p&gt;

\[\lVert V \rVert = \sqrt{x^2 + y^2 + z^2}\]

&lt;p&gt;&lt;mark class=&quot;teal&quot;&gt; The vector's length is sometimes also called norm or magnitude. &lt;/mark&gt; Note that the axes of the three-dimensional Cartesian coordinate systems are unit vectors.&lt;/p&gt;

&lt;h3&gt; Normalizing a Vector &lt;/h3&gt;

&lt;p&gt;&lt;span class=&quot;red&quot;&gt; A normalized vector is a vector whose length is 1.&lt;/span&gt; Such a vector is also called a unit vector (it is a vector which has unit length). Normalizing a vector is very simple. We first compute the length of the vector and divide each one of the vector coordinates with this length.&lt;/p&gt;

\[\hat{V} = \frac{V}{\lVert V \rVert}\]

&lt;p&gt;In mathematics, you will also find the term norm to define a function that assigns a length or size (or distance) to a vector. The function we have just described is called the Euclidean norm.&lt;/p&gt;

&lt;h3&gt; Dot Product &lt;/h3&gt;

&lt;p&gt;The dot product or scalar product requires two vectors $A$ and $B$ and can be seen as the projection of one vector onto the other. The result of the dot product is a real number. A dot product between two vectors is denoted with the dot sign: $A \cdot B$ (it can also sometimes be written as $&amp;lt;A,B&amp;gt;$).&lt;/p&gt;

&lt;p&gt;The dot product consists of multiplying each element of the $A$ vector with its counterpart from vector $B$ and taking the sum of each product. In the case of 3D vectors (they have three coefficients of elements which are $x$, $y$ and $z$), it consists of the following operation:&lt;/p&gt;

\[A \cdot B = A.x * B.x + A.y * B.y + A.z * B.z\]

&lt;p&gt;Note that this is quite similar to the way we compute the length of a vector. If we take the square root of the dot product between two vectors ($\sqrt{A \cdot B}$) that are equal ($A=B$), then what we get is the length of the vector. We can write:&lt;/p&gt;

\[{\lVert V \rVert}^2 = V \cdot V\]

&lt;picture&gt;&lt;img src=&quot;/assets/images/dotproduct.png&quot; style=&quot;width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;The dot product between two vectors is an extremely important and common operation in any 3D application because the result of this operation relates to the cosine of the angle between the two vectors. In this example vector $A$ is projected in the direction of vector $B$.&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; If $B$ is a unit vector then the product $A \cdot B$ gives $\lVert A \rVert \cos (\theta)$, the magnitude of the projection of $A$ in the direction of $B$, with a minus sign if the direction is opposite. This is called the scalar projection of $A$ onto $B$. &lt;/li&gt;

&lt;li&gt; When neither $A$ nor $B$ is a unit vector, we can write that $A \cdot B / \lVert B \rVert$, since $B$ as a unit vector is $B/\lVert B rVert$. &lt;/li&gt;

&lt;li&gt; In mathematics, $ {\cos}^{-1}$ is the inverse of the cosine function. When the two vectors are normalized ($A \cdot B / \lVert A \rVert \lVert B \rVert$), taking the arc cosine of the dot product gives you the angle $\theta$ between two vectors: $\theta = {\cos}^{-1}(A \cdot B / \lVert A \rVert \lVert B \rVert)$ or $\theta = {\cos}^{-1}(\hat{A} \cdot \hat{B})$. &lt;/li&gt;&lt;ul&gt;


&lt;div class=&quot;sidenote&quot;&gt; &lt;picture&gt;&lt;img src=&quot;/assets/images/dot.png&quot; style=&quot;width: 300px !important;float: left !important; margin: 0px 0px 25px 25px !important;&quot; /&gt;&lt;/picture&gt;
The dot product is a very important operation in 3D. It can be used for many things. As a test of orthogonality. When two vectors $A$,$B$ are perpendicular to each other, the result of the dot product between these two vectors is $0$. 

It is also used intensively to find out the angle between two vectors or compute the angle between a vector and the axis of a coordinate system. &lt;/div&gt; 

&lt;h3&gt; Cross Product &lt;/h3&gt;

The cross product is also an operation on two vectors. The difference between cross product and dot product is that the dot product returns a number, whereas the cross product returns a vector. 

The particularity of this operation is that &lt;mark class=&quot;blue&quot;&gt; the vector resulting from the cross product is perpendicular to the other two. &lt;/mark&gt; The cross product operation is written using the following syntax:

$$
C = A \times B
$$

&lt;picture&gt;&lt;img src=&quot;/assets/images/crossproduct.png&quot; style=&quot;width: 300px !important;&quot; /&gt;&lt;/picture&gt;

To compute the cross product we will need to implement the following formula:

$$
C_x = A_Y * B_Z - A_Z * B_Y
C_Y = A_Z * B_X - A_X * B_Z
C_Z = A_X * B_Y - A_Y * B_X
$$

The result of this cross product is another vector which is &lt;span class=&quot;reveal&quot;&gt;  orthogonal &lt;/span&gt; to the other two. The two vectors $A$ and $B$ define a plane and the resulting vector $C$ is perpendicular to that plane. 

$A$ and $B$ don't have to be perpendicular to each other, but when they are, the resulting $A$, $B$ and $C$ vectors form a Cartesian coordinate system (assuming the vectors have unit length).

If you need a mnemonic way of remembering this formula, we like to use the technique that consists of asking ourselves the question &quot;why z?&quot;. $y$ and $z$ being the coordinates of vector $A$ and $B$ used to compute the $x$ coordinates of the resulting vector $C$. 

It is important to note that the order of the vectors involved in the cross product has an effect on the resulting vector $C$. You can see that $A \times B$ doesn't give you the same result as $B \times A$. 





&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.scratchapixel.com&quot;&gt; scratchpixel &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/ul&gt;&lt;/ul&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/pointvec.png" /><media:content medium="image" url="http://localhost:4000/assets/images/pointvec.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">All About Training GAN</title><link href="http://localhost:4000/gan.html" rel="alternate" type="text/html" title="All About Training GAN" /><published>2021-09-14T00:00:00+09:00</published><updated>2021-09-14T00:00:00+09:00</updated><id>http://localhost:4000/gan</id><content type="html" xml:base="http://localhost:4000/gan.html">&lt;!--more--&gt;

&lt;h2&gt; 1.  Generative Adversarial Networks &lt;/h2&gt;

&lt;p&gt;Ultimately, if everything goes well, the generator learns the true distribution of the training data and becomes really good at generating fake images. The discriminator should not be able to distinguish between real and fake images.&lt;/p&gt;

&lt;p&gt;Another way to look at the GAN setup is that the discriminator is trying to guide the generator by telling what real images look like. The two networks try to achieve what is called the Nash Equilibrium with respect to each other.&lt;/p&gt;

&lt;h2&gt; 2.  Training GANs &lt;/h2&gt;

&lt;p&gt;GAN networks are a dynamic system where the optimization process is seeking not a minimum, but a equilibrium between two forces. There are no good objective metrics for evaluating whether a GAN is performing well during training, e.g. reviewing the loss is not sufficient. Instead the best approach is to visually inspect the generated examples and use subjective evaluation.&lt;/p&gt;

&lt;p&gt;Other quantitative measures, such as Inception Score (IS) or Frechet Inception Distance (FID) rely on pretrained models with a specific set of object classes. They lack an upper bound (which means hypothetically the highest possible score is infinity).&lt;/p&gt;

&lt;h3&gt; 2.1  Look at the Loss &lt;/h3&gt;

&lt;p&gt;In a discriminative model,the loss measures the accuracy of the prediction and we use it to monitor the progress of training. However, the loss in GAN measures how well we are doing compared with our opponent. Often, the generator cost increases but the image quality is actually improving.&lt;/p&gt;

&lt;p&gt;If you see the discriminator loss rapidly approaching, there is probably no chance of recovery and it is time to change something.&lt;/p&gt;

&lt;h3&gt; 2.1  Look at the Gradients &lt;/h3&gt;
&lt;p&gt;Monitor the gradients along with the losses in the networks. These can give you a good idea about the progress of training and can even help in debugging if things are not really working well.&lt;/p&gt;

&lt;p&gt;Ideally, the generator should receive large gradients early in the training because it needs to learn how to generate real-looking data. The discriminator on the other hand does not always get large gradients early on, because it can easily distinguish real and fake images.&lt;/p&gt;

&lt;p&gt;If the gradients at the layer of generator are too small, learning might be slow or not happening at all. The generator should get large gradients early on and the discriminator getting consistently high gradients at the top layer once the generator has been trained enough.&lt;/p&gt;

&lt;h2&gt; 3. Detecting GAN Failure Modes &lt;/h2&gt;
&lt;p&gt;The reason why GANs are difficult to train is that both generator and the discriminator are trained simultaneously in a zero-sum game. This means that improvements to one model come at the expense of the other model. 
The goal of training two models involves finding a point of equilibrium between the two competing concerns. It also means that everytime the parameters of one model are updated the nature of the optimization problem that is being solved is updated as well. The technical challenge of training two competing neural networks at the same time is that they can fail to converge.&lt;/p&gt;

&lt;ul&gt;&lt;li class=&quot;highlight&quot;&gt; &lt;b&gt; Convergence Failure &lt;/b&gt;&lt;/li&gt;
&lt;div class=&quot;indent&quot;&gt; The fact that GANs are composed by two networks, and each of them has its loss function leads to GANs unstability. In GAN architecture, the discriminator tries to minimize a cross-entropy while the generator tries to maximize it. When discriminator confidence is high and the discriminator starts to reject the samples that are produced by the generator, generator's gradient vanishes. 

This scenario happens when the generator score reaches near zero and the discriminator score reaches near one. The discriminator is overpowering the generator. If the score does not recover from these values for many iterations, it is better to stop training. &lt;/div&gt;

&lt;li class=&quot;highlight&quot;&gt;&lt;b&gt; Mode Collapse &lt;/b&gt; &lt;/li&gt;
&lt;div class=&quot;indent&quot;&gt; Mode collapse is when the GAN produces a small variety of images with many duplicates. This happens when the generator is unable to learn a rich feature representation because  it learns to associate similar outputs to multiple different inputs. The most promising way to check for mode collapse is to inspect the generated images. If there is little diversity in the output and some of them are almost identical, there is likely mode collapse. If you observe this happening, you should try to increase the ability of the generator to create more diverse outputs or impair the discriminator by randomly giving false labels to real images.

Another type of behavior you should look out for is when the generator oscillates between generating specific examples in the domain. They progress from generating one kind of sample to generating another kind of sample without eventually reaching equilibrium.
&lt;/div&gt;

&lt;li class=&quot;highlight&quot;&gt; &lt;b&gt; Diminisheed Gradient &lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;
&lt;div class=&quot;indent&quot;&gt; This situation happens when the discriminator gets too successful that the generator gradient vanishes and learns nothing.


&lt;h2&gt; Lessons I Learned &lt;/h2&gt;
&lt;div class=&quot;three&quot;&gt; Use a batch size smaller than or equal to 64.&lt;/div&gt;
&lt;div class=&quot;textbox&quot;&gt; In my experience, using bigger batch sizes often hurt the performance. I suspect it fuels the problem of discriminator getting too good at discriminating the real and fake images, since large batch size means providing a lot of examples to train on. &lt;/div&gt;

&lt;div class=&quot;three&quot;&gt; Add noise to both real and synthetic data. &lt;/div&gt;
&lt;div class=&quot;textbox&quot;&gt; It is well known that making the training of discriminator more difficult is beneficial for the overall stability. Adding noise increases the complexity of the discriminator training and stabilizes the data distribution of the two competing networks. &lt;/div&gt;

&lt;div class=&quot;three&quot;&gt; Use Label Smoothing &lt;/div&gt;
&lt;div class=&quot;textbox&quot;&gt; If the label for real images is set to 1, change it to a lower value like 0.9. This solution discourages the discriminator from being overconfident. &lt;/div&gt;

&lt;div class=&quot;three&quot;&gt; Different learning rates for the generator and discriminator a.k.a. Two Time-Scale Update Rule &lt;/div&gt;
&lt;div class=&quot;textbox&quot;&gt; In my experience, choosing a higher learning rate for the discriminator(i.e. 0.0004) and a lower one(i.e. 0.0001) for the generator works well in practice. I guess the reason is that the generator has to make small steps to fool the discriminator so it does not choose fast but not precise solutions to win the adversarial game. &lt;/div&gt;

&lt;div class=&quot;three&quot;&gt; Use some kind of normalization method &lt;/div&gt;
&lt;div class=&quot;textbox&quot;&gt; For me, applying Spectral Normalization, a particular kind of normalization applied on the convolutional kernels, greatly helped the stability of training.&lt;/div&gt;

&lt;blockquote&gt; I learned that hyperparameter tuning takes a lot of time and patience especially for training GANs. &lt;/blockquote&gt;



&lt;/div&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html">I wrote a short article about what I learned training GANs. GAN is well known for its instability in training and there are pitfalls worth knowing.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/gan.png" /><media:content medium="image" url="http://localhost:4000/assets/images/gan.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Dissecting the Camera Matrix (Part 2)</title><link href="http://localhost:4000/extrinsic.html" rel="alternate" type="text/html" title="Dissecting the Camera Matrix (Part 2)" /><published>2021-09-14T00:00:00+09:00</published><updated>2021-09-14T00:00:00+09:00</updated><id>http://localhost:4000/extrinsic</id><content type="html" xml:base="http://localhost:4000/extrinsic.html">&lt;!--more--&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/cali.png&quot; /&gt;&lt;/picture&gt;
&lt;div class=&quot;caption&quot;&gt; Overview of the Camera Calibration Parameters &lt;/div&gt;

&lt;h2&gt; The Extrinsic Camera Matrix &lt;/h2&gt;

&lt;p&gt;The extrinsic matrix takes the form of a rigid transformation matrix: a $3 \times 3$ rotation matrix in the left-block, and $3 \times 1$ translation column-vector in the right.&lt;/p&gt;

\[\begin{bmatrix}
\begin{array}{ccc|c}
  r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_1 \\
  r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_2 \\
  r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_3
\end{array}
\end{bmatrix}\]

&lt;p&gt;It is common to see a version of this matrix with extra row of $(0,0,0,1)$ added to the bottom. This makes the matrix square, which allows us to further decompose this matrix into a rotation followed by translation:&lt;/p&gt;

\[\begin{bmatrix}
\begin{array}{ccc|c}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; t_1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; t_2 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; t_3 \\
\hline
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
\end{array}
\end{bmatrix}

\times

\begin{bmatrix}
\begin{array}{ccc|c}
r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; 0 \\
r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; 0 \\
r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; 0 \\
\hline
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
\end{array}
\end{bmatrix}\]

&lt;p&gt;The matrix describes how to transform points in world coordinates to camera coordinates. The important thing to remember about the extrinsic matrix is that it describes how the &lt;span class=&quot;blue&quot;&gt; world &lt;/span&gt; is transformed &lt;span class=&quot;blue&quot;&gt; relative to the camera &lt;/span&gt;. This if often counter-intuitive, because we usually want to specify how the &lt;span class=&quot;red&quot;&gt; camera &lt;/span&gt; is transformed &lt;span class=&quot;red&quot;&gt; relative to the world &lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt; Building the Extrinsic Matrix from Camera Pose &lt;/h2&gt;

&lt;p&gt;Like I said before, it is often more natural to &lt;span class=&quot;highlight-yellow&quot;&gt; specify the camera’s pose directly &lt;/span&gt; rather than specifying &lt;span class=&quot;highlight-pink&quot;&gt; how world points should transform to camera coordinates &lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Luckily, building an extrinsic camera matrix this way is easy: just &lt;span class=&quot;highlight-green&quot;&gt; build a rigid transformation matrix that describes the camera’s pose &lt;/span&gt; and then &lt;span class=&quot;rainbow&quot;&gt; take its inverse &lt;/span&gt;.&lt;/p&gt;

\[\begin{bmatrix}
\begin{array}{c|c}
R &amp;amp; t \\
0 &amp;amp; 1 
\end{array}
\end{bmatrix}

= 

\begin{bmatrix}
\begin{array}{c|c}
R_c &amp;amp; C \\
0 &amp;amp; 1 
\end{array}
\end{bmatrix}^{-1}\]

&lt;p&gt;Let $C$ be a column vector describing the location of the camera-center in world coordinates, and let $R_c$ be the rotation matrix describing the camera’s orientation with respect to the world coordinate axes. Then extrinsic matrix is obtained by inverting the camera’s pose matrix.&lt;/p&gt;

&lt;blockquote&gt; Algebraically a rotation matrix in $n$-dimensions is a $n \times n$ special orthogonal matrix, i.e. an orthogonal matrix whose determinant is 1. &lt;/blockquote&gt;

&lt;div class=&quot;sidenote&quot;&gt; We can define matrix $R$ that rotates in the $xy$-Cartesian plane counterclock-wise through an angle $\theta$ about the origin of the Cartesian system as follows:

$$
R = \begin{bmatrix}
\cos\theta &amp;amp; -\sin\theta \\
\sin\theta &amp;amp; \cos\theta
\end{bmatrix}
$$

&lt;/div&gt;

&lt;div class=&quot;sidenote&quot;&gt; The set of all rotation matrices form a group, known as the special orthogonal group. The inverse of a rotation matrix is its transpose, which is also a rotation matrix. 

$$
\displaylines{
R^T = R^{-1} \\
det(R) = 1
}
$$
&lt;/div&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/rotation.png&quot; /&gt;&lt;/picture&gt;
&lt;div class=&quot;caption&quot;&gt; the extrinsic matrix is obtained by inverting the camera's pose matrix &lt;/div&gt;

&lt;p&gt;We here use the fact that the inverse of a rotation matrix is its transpose, and inverting a translation matrix simply negates the translation vector. Relationship between the extrinsic matrix parameters and the camera’s pose is straightforward:&lt;/p&gt;

\[\displaylines{
R = R^T_c \\
t = -RC
}\]

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt; 
&lt;li&gt;&lt;a href=&quot;https://ksimek.github.io/2012/08/14/decompose/&quot;&gt; ksimek blog &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://prateekvjoshi.com/2014/05/31/understanding-camera-calibration/&quot;&gt; prateekvjoshi blog &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html">This is the second part of our journey to master the camera matrix. In this blog post, we will study the extrinsic camera parameters. Extrinsic matrix describes the camera's location in the world.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/extrinsic.png" /><media:content medium="image" url="http://localhost:4000/assets/images/extrinsic.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Image Processing: the Basics</title><link href="http://localhost:4000/template.html" rel="alternate" type="text/html" title="Image Processing: the Basics" /><published>2021-09-14T00:00:00+09:00</published><updated>2021-09-14T00:00:00+09:00</updated><id>http://localhost:4000/template</id><content type="html" xml:base="http://localhost:4000/template.html">&lt;!--more--&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/disparity.png&quot; /&gt;&lt;/picture&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;a=href=&quot;&quot;&amp;gt; TheAILearner &amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/depth/1.jpg" /><media:content medium="image" url="http://localhost:4000/assets/images/depth/1.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Advanced PyTorch: Things You Didn’t Know</title><link href="http://localhost:4000/pytorch.html" rel="alternate" type="text/html" title="Advanced PyTorch: Things You Didn’t Know" /><published>2021-09-12T00:00:00+09:00</published><updated>2021-09-12T00:00:00+09:00</updated><id>http://localhost:4000/pytorch</id><content type="html" xml:base="http://localhost:4000/pytorch.html">&lt;!--more--&gt;

&lt;h2&gt; Flatten Operation for a Batch of Image Inputs to a CNN 
&lt;/h2&gt;
&lt;p&gt;Flattening specific tensor axis is often required with CNNs because we work with batches of inputs opposed to single inputs. A tensor flatten operation is a common operation inside convolutional neural networks. This is because convolutional layer outputs that are passed to fully connected layers must be flattened out so that the fully connected layer can accept them as the input. A flatten operation is a specific type of reshaping operation where by all of the axes are smooshed or squashed together.&lt;/p&gt;

&lt;p&gt;To flatten a tensor, we need to have at least two axes. This makes it so that we are starting with something that is not already flat. For example, in the MNIST dataset, we will look at an handwritten image of eight. This image has 2 distinct dimensions, height and width.&lt;/p&gt;

&lt;p&gt;The height and width are $18 \times 18$ respectively. These dimensions tell use that this is a cropped image becaue the MNIST dataset contains $28 \times 28$ images. Let’s see how these two axes of height and width are flattened out into a single axis of length 324 (c.f. 324 what we get when multiplying 18 with 18).&lt;/p&gt;

&lt;h3&gt; Flattening Specific Axes of a Tensor &lt;/h3&gt;

&lt;p&gt;Tensor inputs to a convolutional neural network typically have 4 axes, one for batch size, one for color channels, and one each for height and width.&lt;/p&gt;

\[[B,C,H,W]\]

&lt;p&gt;Suppose we have the following three tensors:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each of these has a shape of $4 \times 4$, so we have three rank-2 tensors. For our purpose, we’ll consider these to be three $4 \times 4$ images that we will use to create a batch that can be passed to a CNN. Batches are represented using a single tensor, so we’ll need to combine these three tensors into a single larger tensor that has 3 axes instead of 2.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, we used the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack()&lt;/code&gt; method to concatenate our sequence of tensors along a new axis. Since we have three tensors along a new axis, we know that the length of this axis should be 3. At this point, we have a rank-3 tensor that contains a batch of three $4 \times 4$ images. All we need to do now to get this tensor into a form that a CNN expects is add an axis for the color channels. We basically have an implicit single color channel for each of these image tensors, so in practice, these would be grayscale images.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reshape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how the additional axis of length 1 doesn’t change the number of elements in the tensor. This is because the product of the components values doesn’t change when we multiply by one.&lt;/p&gt;

&lt;p&gt;The first axis has 3 elements. Each element of the first axis represents an image. For each image, we have a single color channel on the channel axis. Each of these channels contain 4 arrays that contain 4 numbers or scalar components.&lt;/p&gt;

&lt;h3&gt; Flattening the Tensor Batch &lt;/h3&gt;

&lt;p&gt;Let’s see how to flatten images in this batch. Remember the whole batch is a single tensor that will be passed to the CNN, &lt;span class=&quot;underline&quot;&gt; we don’t want to flatten the whole thing &lt;/span&gt; We only want to &lt;span class=&quot;glow&quot;&gt; flatten the image tensors &lt;/span&gt; within the batch tensor.&lt;/p&gt;

&lt;p&gt;For example, if we do the following operations on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# this is the same operation as t.flatten()
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reshape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;What I want you to notice about this output is that we have flattened the entire batch, and this smashes all the batches together into a single axis. The flattened batch won’t work well inside our CNN because we need individual predictions for each image within our batch tensor, and now we have a flattened mess.&lt;/p&gt;

&lt;p&gt;The solution here, is to flatten each image while &lt;span color=&quot;blink&quot;&gt; still maintaining the batch axis &lt;/span&gt;. This means we want to &lt;span class=&quot;underline&quot;&gt; flatten only part of the tensor &lt;/span&gt;. We want to flatten the color channel axis with the height and width axes.&lt;/p&gt;

&lt;blockquote&gt; The Axes that Need to be Flattened: $[C,H,W]$ &lt;/blockquote&gt;
&lt;p&gt;This can be done with PyTorch’s built in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatten()&lt;/code&gt; function.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Notice how we specified the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_dim&lt;/code&gt; parameter.This tells the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatten()&lt;/code&gt; method which axis it should start the flatten operation. Now we have a rank-2 tensor with three single color channel images that have been flattened out into 16 pixels.&lt;/p&gt;

&lt;h3&gt; Flattening an RGB Image &lt;/h3&gt;
&lt;p&gt;If we flatten an RGB image, what happens to the color? Each color channel will be flattened first, then the flattened channels will be lined up side by side on a single axis of the tensor.&lt;/p&gt;

&lt;p&gt;For example, we build an RGB image tensor like the following code:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;By flattening the image tensor, this is how it is going to look like.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2&gt; Broadcasting and Element-Wise Operations with PyTorch &lt;/h2&gt;

&lt;blockquote&gt; Remember, all these rules apply to PyTorch Tensors! Python built-in types such as list will not behave this way.&lt;/blockquote&gt;
&lt;h3&gt; Element-Wise Operations &lt;/h3&gt;
&lt;p&gt;An element-wise operation is an operation between two tensors that operates on corresponding elements within the respective tensors. Two elements are said to be corresponding if the two elements occupy the same position within the tensor. The position is determined by the indexes used to locate each element. Therefore, we can deduce that tensors must have the same shape in order to perform an element-wise operation.&lt;/p&gt;

&lt;h3&gt; Broadcasting Tensors &lt;/h3&gt;
&lt;p&gt;Broadcasting describes how tensors with different shapes are treated during element-wise operations. For example, suppose we have the following two tensors:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;What will be the result of this two tensors’ element-wise addition operation? Even though these two tensors have differing shapes, the element-wise operation is possible, and broadcasting is what makes the operation possible. The lower rank tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt; will be transformed via broadcasting to match the shape of the higher rank tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;, and the element-wise operation will be performed as usual.&lt;/p&gt;

&lt;p&gt;The concept of broadcasting is the key to understanding how this operation will be carried out. We can check the broadcast transformation using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;broadcast_to()&lt;/code&gt; numpy function.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;broadcast_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;When do we actually use broadcasting? We often need to use broadcasting when we are preprocessing and especially during normalization routines.&lt;/p&gt;

&lt;h3&gt; Element-Wise Operation Applies to Comparision and Functions &lt;/h3&gt;
&lt;p&gt;Comparison operations are also element-wise operations. For a given comparison operation between two tensors, a new tensor of the same shape is returned with each element containing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.bool&lt;/code&gt; value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;. It is also fine to assume that the function is applied to each element of the tensor.&lt;/p&gt;

&lt;div class=&quot;sidenote&quot;&gt; there are other ways to refer to element-wise operations, such as component-wise or point-wise &lt;/div&gt;

&lt;h2&gt; Argmax and Reduction Operations for Tensors &lt;/h2&gt;
&lt;p&gt;Now, we will focus in on the frequently used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argmax()&lt;/code&gt; function, and we’ll see how to access the data inside our tensors.&lt;/p&gt;

&lt;h3&gt; Tensor Reduction Operation &lt;/h3&gt;

&lt;blockquote&gt; A reduction operation on a tensor is an operation that reduces the number of elements contained within the tensor.&lt;/blockquote&gt;

&lt;p&gt;Reduction operations allow us to perform operations on element within a single tensor. Let’s look at an example. Suppose we have the following rank-2 tensor:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;8.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The sum of our tensor’s scalar components is calculated using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum()&lt;/code&gt; tensor method. The result of this call is a &lt;span class=&quot;rainbow&quot;&gt; scalar-valued tensor &lt;/span&gt;. Since the number of elements have been reduced by the operation, we can conclude that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum()&lt;/code&gt; method is a reduction operation.&lt;/p&gt;

&lt;p&gt;Other common reduction functions include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.sum()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.prod()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.mean()&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.std()&lt;/code&gt;. All of these tensor methods reduce the tensor to a single element scalar valued tensor by operating on all the tensor’s elements.&lt;/p&gt;

&lt;p&gt;Reduction operations in general allow us to compute aggregate values across data structures. But do reduction operations always reduce to a tensor with a single element? The answer is no. In fact, we often reduce specific axes at a time. This process is important.&lt;/p&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://deeplizard.com/learn/video/K3lX3Cltt4c&quot;&gt; deeplizard &lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content><author><name>seri</name></author><category term="PyTorch" /><category term="featured" /><summary type="html">This blog post is for those who know the basics of PyTorch but want to go a step further. We will be diving into principles and applications of deep learning via PyTorch.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/pytorch.png" /><media:content medium="image" url="http://localhost:4000/assets/images/pytorch.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Guide to Linear Algebra (Part 1)</title><link href="http://localhost:4000/no-bullshit.html" rel="alternate" type="text/html" title="Guide to Linear Algebra (Part 1)" /><published>2021-09-09T00:00:00+09:00</published><updated>2021-09-09T00:00:00+09:00</updated><id>http://localhost:4000/no-bullshit</id><content type="html" xml:base="http://localhost:4000/no-bullshit.html">&lt;!--more--&gt;

&lt;h2&gt; Computational Linear Algebra &lt;/h2&gt;

&lt;p&gt;This chapter covers the computational aspects of performing matrix calculations. Understanding matrix computations is important because all later chapters depend on them. Suppose we’re given a huge matrix $ A \in R^{n \times n} $ with $ n=1000 $. Hidden behind the innocent-looking mathematical notation of the matrix inverse $A^{-1}$, the matrix product $AA$, and the matrix determinant $ | A |$, lie monster coputations involving all the $1000 \times 1000 = 1$ million entries of the matrix $A$. Millions of arithmetic operations must be performed, so I hope you have at least a thousand pencil ready!&lt;/p&gt;

&lt;p&gt;Okay, calm down. I won’t actually make you calculate millions of arithmetic operations. In fact, to learn linear algebra, it is sufficient to know how to carry out calculations with $3 \times 3$ and $4 \times 4$ matrices. Even for such moderately sized matrices, computing products, inverses, and determinants by hand are serious computational tasks. If you’re ever required to take a linear algebra final exam, you need to make sure you can do these calculations quickly. Even if no exam looms in your imminent future, it’s important to practice matrix operations by hand to get a feel for them.&lt;/p&gt;

&lt;p&gt;This chapter will introduce you to the following computational tasks involving matrices:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;blue&quot;&gt;Gauss-Jordan elimination &lt;/span&gt; Suppose we're trying to solve two equations in two unknowns $x$ and $y$:

$$ 
\displaylines{
ax+by = c \\\
dx+ ey= f
}
$$

If we add $\alpha$\times the first equation to the second equation, we obtain an equivalent system of equations:

$$
\displaylines{
ax + by = c \\\
(d + \alpha a)x + (e + \alpha b)y = f + \alpha c
}
$$

This is called a &lt;span class=&quot;highlight-sketch&quot;&gt; row operation &lt;/span&gt;: we added $\alpha$-times the first row to the second row. Row operations change the coefficient of the system of equations, but leave the solution unchanged. Gauss-Jordan elimination is a systematic procedure for solving systems of linear equations using row operations. &lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;blue&quot;&gt; Matrix product &lt;/span&gt; The product $AB$ between matrices $A \in \mathbb{R}^{m \times l}$ and $B \in \mathbb{R}^{l \times n}$ is the matrix $C \in \mathbb{R}^{m \times n}$ whose coefficients $c_{ij}$ are defined by the formula $c_{ij} = \sum_{k=1}^{l}a_{ik}b_{kj}$ for all $i \in \lbrack 1, \dots, m \rbrack $ and $j \in \lbrack 1, \dots, n \rbrack $. We'll soon unpack this formula and learn about its intuitive interpretation: that computing $C = AB$ is computing all the dot products between the rows of $A$ and the columns of $B$. &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;blue&quot;&gt; Determinant &lt;/span&gt; The determinant of a matrix $A$, denoted $|A|$ is an operation that gives us useful information about the linear independence of the rows of the matrix. The determinant is connected to many notions of linear algebra: linear independence, geometry of vectors, solving systems of equations, and matrix invertibility. We'll soon discuss these aspects. &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;blue&quot;&gt; Matrix inverse &lt;/span&gt; We'll build upon our knowledge of Gauss-Jordan elimination, matrix products, and determinants to derive three different procedures for computing the matrix inverse $A^{-1}$.&lt;/li&gt;&lt;/ul&gt;

&lt;h3&gt; Reduced Row Echelon Form &lt;/h3&gt;
&lt;p&gt;In this section, we’ll learn to solve systems of linear equations using the Gauss-Jordan elimination procedure. A system of equations can be represented as a matrix of coefficients. The Gauss-Jordan elimination procedure converts any matrix into its &lt;span class=&quot;highlight-sketch&quot;&gt; &lt;b&gt; reduced row echelon form (RREF) &lt;/b&gt;&lt;/span&gt;. We can easily find the solution (or solutions of the system of equations from the RREF.&lt;/p&gt;

&lt;p&gt;Listen up: the material covered in this section requires your full on, caffeinated attention, as the procedures you’ll learn are somewhat tedious. Gauss-Jordan elimination involves many repetitive mathematical manipulations of arrays of numbers. It’s important you hang in there and follow through the step-by-step manipulations, as well as verify each step I present on your own with pen and paper.&lt;/p&gt;

&lt;h4&gt; Solving Equations &lt;/h4&gt;
&lt;p&gt;Suppose you’re asked to solve the following system of equations:&lt;/p&gt;

\[\displaylines{
1x_1 + 2x_2  = 5 \\\
3x_1 + 9x_2 = 21}\]

&lt;p&gt;The standard approach is to use one of the equation-solving tricks we learned to combine the equations and find the values of the two unknowns $x_1$ and $x_2$.&lt;/p&gt;

&lt;p&gt;Observe that the names of the two unknowns are irrelevant to the solution of the system of equations. Indeed, the solution $(x_1, x_2)$ to the above system of equations is the same as the solution $(s,t)$ to the system of equations&lt;/p&gt;

\[\displaylines{
1s+ 2t = 5 \\\
3s+ 9t = 21}\]

&lt;p&gt;The important parts of a system of linear equations are the &lt;span class=&quot;highlight-yellow&quot;&gt; coefficients &lt;/span&gt; in front of the variables and the constants on the right-hand side of each equation.&lt;/p&gt;

&lt;h4&gt; Augmented Matrix &lt;/h4&gt;
&lt;p&gt;The system of linear equations can be written as an &lt;span class=&quot;highlight-green&quot;&gt; augmented matrix &lt;/span&gt;:&lt;/p&gt;

\[\begin{pmatrix} 1 &amp;amp; 2 &amp;amp;\bigm | &amp;amp; 5 \\\
                3 &amp;amp; 9 &amp;amp;\bigm | &amp;amp; 21
\end{pmatrix}\]

&lt;p&gt;The first column corresponds to the coefficients of the first variable, the second column is for the second variable, and the last column corresponds to the constants of the right-hand side. It is customary to draw a vertical line where the equal signs in the equations would normally appear. This line helps distinguish the coefficients of the equations from the column of constants on the right-hand side.&lt;/p&gt;

&lt;p&gt;Once we have the augmented matrix, we can simplify it by using &lt;span class=&quot;highlight-yellow&quot;&gt; row operations &lt;/span&gt; (which we’ll discuss shortly) on its entries. After simplification by row operations, the augmented matrix will be transformed to&lt;/p&gt;

\[\begin{pmatrix}
1 &amp;amp; 0 &amp;amp;\bigm | &amp;amp; 5 \\\
0 &amp;amp; 1 &amp;amp;\bigm | &amp;amp; 2
\end{pmatrix}\]

&lt;p&gt;which corresponds to the system of equations&lt;/p&gt;

\[\displaylines{
x_1 = 1 \\\
x_2 = 2}\]

&lt;p&gt;This is a &lt;span class=&quot;monospace&quot;&gt; trivial &lt;/span&gt; system of equations; there is nothing left to solve and we can see that the solutions are $x_1 = 1$ and $x_2 = 2$. This example illustrates the general idea of the Gauss-Jordan elimination procedure for solving the system of equations by manipulating an augmented matrix.&lt;/p&gt;

&lt;h4&gt; Row Operations &lt;/h4&gt;
&lt;p&gt;We can manipulate the rows of an augmented matrix without changing its solutions. We’re allowed to perform the following three types of row operations:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; Add a multiple of one row to another row &lt;/li&gt;
&lt;li&gt; Swap the position of the two rows &lt;/li&gt;
&lt;li&gt; Multiply a row by a constant &lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Let’s trace the sequence of row operations needed to solve the system of equations&lt;/p&gt;

\[\displaylines{x_1 + 2x_2 = 5 \\\
3x_1 + 9x_2 = 21}\]

&lt;p&gt;starting from its augmented matrix:&lt;/p&gt;

\[\begin{pmatrix}
1 &amp;amp; 2 &amp;amp;\bigm | &amp;amp; 5 \\\
3 &amp;amp; 2 &amp;amp;\bigm | &amp;amp; 21
\end{pmatrix}\]

&lt;ol&gt;
  &lt;li&gt;As a first step, we eliminate the first variable in the second row by subtracting three times the first row from the second row.&lt;/li&gt;
&lt;/ol&gt;

\[\begin{pmatrix}
1 &amp;amp; 2 &amp;amp;\bigm | &amp;amp; 5 \\\
0 &amp;amp; 3 &amp;amp;\bigm | &amp;amp; 6
\end{pmatrix}\]

&lt;p&gt;We denote this row operation as $R_2 \leftarrow R_2 - 3R_1$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;To simplify the second row, we divide it by 3 to obtain&lt;/li&gt;
&lt;/ol&gt;

\[\begin{pmatrix}
1 &amp;amp; 2 &amp;amp;\bigm | &amp;amp; 5 \\\
0 &amp;amp; 1 &amp;amp;\bigm | &amp;amp; 2 
\end{pmatrix}\]

&lt;p&gt;This row operation is denoted $R_2 \leftarrow \frac{1}{3}R_2$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The final step is to eliminate the second variable from the first row. We do this by subtracting two times the second row from the first row $R_1 \leftarrow R_1 - 2 R_2$:&lt;/li&gt;
&lt;/ol&gt;

\[\begin{pmatrix}
1 &amp;amp; 0 &amp;amp;\bigm | &amp;amp; 1 \\\
0 &amp;amp;  1 &amp;amp;\bigm | &amp;amp; 2
\end{pmatrix}\]

&lt;p&gt;We can now read off the solution: $x_1 =1$ and $x_2 = 2$.&lt;/p&gt;

&lt;p&gt;Note how we simplified the augmented matrix through a specific procedure: we followed the &lt;span class=&quot;rainbow&quot;&gt; Gauss-Jordan elimination algorithm &lt;/span&gt; to bring the matrix into its reduced row echelon form.&lt;/p&gt;

&lt;p&gt;The reduced row echelon form (RREF) is the simplest form for an augmented matrix. Each row contains a &lt;span class=&quot;circle-sketch-highlight&quot;&gt;&lt;b&gt; leading one &lt;/b&gt;&lt;/span&gt; (a numeral 1) also known as a &lt;span class=&quot;circle-sketch-highlight&quot;&gt; &lt;b&gt;pivot &lt;/b&gt;&lt;/span&gt;. Each column’s pivot is used to eliminate the numbers that lie below and above it in the same column. The end result of this procedure is the reduced row echelon form:&lt;/p&gt;

\[\begin{pmatrix}
1 &amp;amp; 0 &amp;amp; \ast &amp;amp; 0 &amp;amp;\bigm | \ast \\\
0 &amp;amp; 1 &amp;amp; \ast &amp;amp; 0 &amp;amp;\bigm | \ast \\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp;\bigm | \ast
\end{pmatrix}\]

&lt;p&gt;Note the matrix contains only zero entries below and above the pivots. The asterisks $\ast$ denote arbitrary numbers that could not be eliminated because no leading one is present in these columns.&lt;/p&gt;

&lt;div class=&quot;definition&quot;&gt;The solution to a system of linear equations in the variables $x_1, x_2, \dots, x_n$ is the set of values $\{(x_1, x_2, \dots, x_n)\}$ that satisfy all the equations.&lt;/div&gt;

&lt;div class=&quot;definition&quot;&gt; Gaussian elimination is the process of bringing a matrix into row echelon form. &lt;/div&gt;
&lt;div class=&quot;definition&quot;&gt; A matrix is said to be in row echelon form (REF) if all entries below the leading ones are zero. This form can be obtained by adding or subtracting the row with the leading one from the rows below it. &lt;/div&gt;
&lt;div class=&quot;definition&quot;&gt; Gaussian-Jordan elimination is the process of bringing a matrix into reduced row echelon form. &lt;/div&gt;
&lt;div class=&quot;definition&quot;&gt; A matrix is said to be in reduced row echelon form (RREF) if all the entries below and above the pivots are zero. Starting from the REF, we obtain the RREF by subtracting the row containing the pivots from the rows above them.&lt;/div&gt;
&lt;div class=&quot;definition&quot;&gt; the rank of the matrix $A$ is the number of pivots in the RREF of $A$. &lt;/div&gt;

&lt;h3&gt; Number of Solutions &lt;/h3&gt;

&lt;p&gt;A system of linear equations in three variables could have:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;rainbow&quot;&gt; one solution &lt;/span&gt; If the RREF of a matrix has a pivot in each row, we can read off the values of the solution by inspection. 

$$

\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; c_1 \\\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; c_2 \\\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; c_3
\end{bmatrix}

$$

The unique solution is $x_1 = c_1$, $x_2 = c_2$, and $x_3 = c_3$. &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;rainbow&quot;&gt; Infinitely many solutions 1 &lt;/span&gt; If one of the equations is redundant, a row of zeros will appear when the matrix is brought to the RREF. This happens when one of the original equations is a linear combination of the other two. In such cases, we're really solving two equations  in three variables, so can't pin down one of the unknown variables. We say the solution contains &lt;span class=&quot;underline&quot;&gt; a free variable &lt;/span&gt;. For example, consider the following RREF:

$$
\begin{bmatrix} 
1 &amp;amp; 0 &amp;amp; a_1 &amp;amp; c_1 \\\
0 &amp;amp; 1 &amp;amp; a_2 &amp;amp; c_2 
\end{bmatrix}
$$

The column that doesn't contain a leading one corresponds to the free variable. To indicate that $x_3$ is a free variable, we give it a special label $x_3 \equiv t$. The variable $t$ could be any number $t \in \mathbb{R}$. In other words, when we say $t$ is free, it means $t$ can take on any value from $-\infty$ to $+\infty$. The information in the augmented matrix can now be used to express $x_1$ and $x_2$ in terms of the right-hand constants and the free variable $t$:

$$
\begin{Bmatrix} x_1 = c_1 - a_1 t \\ x_2 = c_2 - a_2 t \\ x_3 = t, \forall t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} c_1 \\ c_2 \\ 0 \end{bmatrix} + t \begin{bmatrix} -a_1 \\ -a_2 \\ 1 \end{bmatrix}, \forall t \in \mathbb{R}\end{Bmatrix}
$$.

The solution corresponds to the equation of a line passing through the point $(c_1, c_2, 0)$ with direction vector $(-a_1, -a_2, 1)$. We'll discuss the geometry of lines in the next section. For now, it's important that you understand that a system of equations can have more than one solution; any point on the line $l \equiv \{(c_1, c_2, 0) + t(-a_1, -a_2, 1), \forall t \in \mathbb{R}\}$ is a solution to the above system of equations. &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;rainbow&quot;&gt; Infinitely many solutions 2 &lt;/span&gt; It's also possible to obtain a two-dimensional solution space. This happens when two of the three equations are redundant. In this case, there will be a single leading one, and thus two free variables. For example, in the RREF

$$
\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; a_1 &amp;amp; c_1 \\\ 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\ 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 
\end{bmatrix}
$$

the variables $x_1$ and $x_3$ are free. As in the previous infinitely-many-solutions case, we define new labels for the free variables $x_1 \equiv s$ and $x_3 \equiv t$, where $ s \in \mathbb{R}$ and $t \in \mathbb{R}$ are two arbitrary numbers. The solution to this system of equations is 

$$ 
\begin{Bmatrix} 
x_1 = s \\ x_2 = c_2 - a_2 t \\ x_3 = t , \\ \forall s,t \in \mathbb{R} \end{Bmatrix} = \begin{Bmatrix} \begin{bmatrix} 0 \\ c_2 \\ 0 \end{bmatrix} + s \begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix} + t \begin{bmatrix} 0 \\ -a_2 \\ 1 \end{bmatrix}, \forall s,t \in \mathbb{R} 
\end{Bmatrix} 
$$

This solution set corresponds to the parametric equation of a plane that contains the point $(0,c_2, 0)$ and the vectors $(1,0,0)$ and $(0, -a_2, 1)$. 

The general equation for the solution plane is $0x+1y+a_2z = c_2$, as can be observed from the first row of the augmented matrix. In the next section, we'll learn more about the geometry of planes and how to convert between their general and parametric forms. &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;rainbow&quot;&gt; no solutions &lt;/span&gt; If there are no numbers $(x_1, x_2, x_3)$ that simultaneously satisfy all three equations, the system of equations has no solution. An example of a system of equations with no solution is the pair $ s+t = 4$ and $s+t = 44$. There are no numbers $(s,t)$ that satisfy both these equations. 

A system of equations has no solution if its reduced row echelon form contains a row of zero coefficients with a nonzero constant in the right-hand side:

$$
\begin{Bmatrix}
\begin{array}{ccc|c}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; c_1 \\\ 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; c_2 \\\ 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; c_3 
\end{array}
\end{Bmatrix}
$$

If $c_3 \neq 0$ this system of equations is impossible to satisfy. There is no solution because there are no numbers $(x_1, x_2, x_3)$ such that $0x_1 + 0x_2 + 0x_3 = c_3$. 

Dear reader, we've reached the first moment in this book where you'll need to update your math vocabulary. The solution to an individual equation is a finite set of points. The solution to a system of equations can be an entire space containing infinitely many points, such as a line or a plane. 

The solution set of a system of three linear equations in three unknowns could be either the empty set $\{0\}$ (no solution), a set with one element $\{(x_1, x_2, x_3)\}$, or a set with infinitely many elements like a line $\{p_o + t \overrightarrow{v}, t \in \mathbb{R}\}$ or a plane $\{p_o + s \overrightarrow{v} + t \overrightarrow{w}, s,t \in \mathbb{R}\}$. Another possible solution set is all of $\mathbb{R}^3$; every vector $ \overrightarrow{x} \in \mathbb{R}^3 $ is a solution to the equation 

$$
\begin{bmatrix} 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 0 \end{bmatrix}
$$

Note the distinction between the three types of infinite solution sets. A line is one-dimensional, a plane is two-dimensional, and $\mathbb{R}^3$ is three-dimensional. Describing all points on a line requires one parameter, describing all points on a plane takes two parameters, and-of course-describing a point in $\mathbb{R}^3$ takes three parameters. 

&lt;h3&gt; Geometric Interpretation &lt;/h3&gt;
We can gain some intuition about solution sets by studying the geometry of the intersections of lines in $\mathbb{R}^2$ and planes in $\mathbb{R}^3$. 

&lt;h4&gt; Lines in two dimensions &lt;/h4&gt;
Equations of the form $ax+by = c$ corresponds to lines in $\mathbb{R}^2$. Solving systems of linear equations of the form

$$
\displaylines{
a_1 x + b_1 y = c_1 \\\
a_2 x + b_2 y = c_2
}
$$

requires finding the point $(x,y) \in \mathbb{R}^2$ where these lines intersect. There are three possibilities for the solution set:
- &lt;span class=&quot;highlight-sketch&quot;&gt; one solution &lt;/span&gt; if the two lines intersect at a point. 
- &lt;span class=&quot;highlight-sketch&quot;&gt; infinitely many solutions &lt;/span&gt; if the lines are superimposed.
- &lt;span class=&quot;highlight-sketch&quot;&gt; no solution &lt;/span&gt; if the two lines are parallel and never intersect.

&lt;h4&gt; Planes in three dimensions &lt;/h4&gt;
Equations of the form $ax+by+cz = d$ correspond to planes in $\mathbb{R}^3$. When solving three such equations, 

$$ 
\displaylines{
a_1 x + b_1 y + c_1 z = d_1 \\\
a_2 x + b_2 y + c_2 z = d_2 \\\
a_3 x + b_3 y + c_3 z = d_3
}
$$

we want to find a set of points $(x,y,z)$ that satisfy all three equations simultaneously. There are four possibilities for the solution set:

1. &lt;span class=&quot;highlight-green&quot;&gt; one solution &lt;/span&gt; three non-parallel planes intersect at a point. 
2. &lt;span class=&quot;highlight-yellow&quot;&gt; infinitely many solutions 1 &lt;/span&gt; if only one of the plane equations is redundant, the solution corresponds to the intersection of two planes which is a line.
3. &lt;span class=&quot;highlight-green&quot;&gt; infinitely many solutions 2 &lt;/span&gt; if two of the equations are redundant, then the solution space is a two-dimensional space. 
4. &lt;span class=&quot;highlight-yellow&quot;&gt; if two (or more) of the planes are parallel, they will never intersect. &lt;/span&gt;

&lt;h3&gt; Determinants &lt;/h3&gt;
&lt;h4&gt; Overview &lt;/h4&gt; 
What is the volume of a rectangular box of length $1m$, width $2$ and height $3m$? It's easy to compute the volume of this box because its shape is right rectangular prism. The volume of this prism is $V = l \times w \times h = 6m^3$. What if the shape of the box was a parallelpiped instead? A parallelpiped is a box whose opposite faces are parallel but whose sides are slanted. How do we compute the volume of a parallelpiped? The determinant operation, specifically the $3 \times 3$ determinant, is the perfect tool for this purpose. 

The determinant of a matrix, denoted $det(A)$ or $|A|$, is a particular way to multiply the entries of the matrix to produce a single number. We use determinants for all kinds of tasks: to compute areas and volumes, to solve systems of linear equations, to check whether a matrix is invertible or not, etc.

We can interpret the determinant of a matrix intuitively as a geometrical calculation. The &lt;span class=&quot;blue&quot;&gt; determinant &lt;/span&gt; is the &lt;span class=&quot;blue&quot;&gt; volume &lt;/span&gt; of the geometric shape whose edges are the rows of the matrix. For $2 \times 2$ matrices, the determinant corresponds to the area of a parallelogram. For $3 \times 3$ matices, the determinant corresponds to the volume of a parallelpiped. For dimensions $d &amp;gt; 3$, we say the determinant measures a &lt;span class=&quot;blue&quot;&gt; $d$-dimensional hyper-volume &lt;/span&gt;.

Consider the linear transformation $T: \mathbb{R}^2 \rightarrow \mathbb{R}^2$ defined through the matrix-vector product with a matrix $A_T: T(\overrightarrow{x}) \equiv A_T \overrightarrow{x}$. The determinant of the matrix $A_T$ is the &lt;span class=&quot;blue&quot;&gt; scale factor &lt;/span&gt; associated with the linear transformation $T$. The scale factor of the linear transformation $T$ describes &lt;mark&gt; how the area of a unit square in the input space (a square with dimensions $1 \times 1$) is transformed by $T$ &lt;/mark&gt;. After passing through $T$, the unit square is transformed to a parallelogram with with area $det(A_T)$. Linear transformations that shrink areas have $det(A_T) &amp;lt; 1$, while linear transformations that enlarge areas have $det(A_T) &amp;gt; 1$. A linear transformation that is area preserving has $det(A+T) = 1$. 

The determinant is also used to check &lt;span class=&quot;blue&quot;&gt; linear independence &lt;/span&gt; for a given set of vectors. We &lt;span class=&quot;underline&quot;&gt; construct a matrix using the vectors as the matrix rows &lt;/span&gt;, and compute its determinant. 

The determinant of a matrix tells us whether or not that matrix is &lt;span class=&quot;blue&quot;&gt; invertible &lt;/span&gt;. If $det(A) \neq 0$, then $A$ is invertible; if $det(A) = 0$, $A$ is not invertible. 

The determinant shares a connection with the &lt;span class=&quot;blue&quot;&gt; vector cross product &lt;/span&gt;, and is used in the definition of the &lt;span class=&quot;blue&quot;&gt; eigenvalue equation &lt;/span&gt;.

&lt;h4&gt; Formulas &lt;/h4&gt;
The determinant of a $2 \times 2$ matrix is 

$$
det(\begin{bmatrix} a_{11} &amp;amp; a_{12} \\ a_{21} &amp;amp; a_{22} \end{bmatrix}) = \begin{vmatrix} a_{11} &amp;amp; a_{12} \\ a_{21} &amp;amp; a_{22} \end{vmatrix} = a_{11}a_{22} - a_{12}a{21}
$$

The formulas for the determinants of larger matrices are defined recursively. For example, the determinant of $3 \times 3$ matirx is defined in terms of $2 \times 2$ determinants:

$$ 
\begin{vmatrix} a_{11} &amp;amp; a_{12} &amp;amp; a_{13} \\ a_{21} &amp;amp; a_{22} &amp;amp; a_{23} \\ a_{31} &amp;amp; a_{32} &amp;amp; a_{33} \end{vmatrix} = a_{11} 

= a_{11} \begin{vmatrix}a_{22} &amp;amp; a_{23} \\ a_{32} &amp;amp; a_{33} \end{vmatrix} -a_{12} \begin{vmatrix} a_{21} &amp;amp; a_{23} \\ a_{31} &amp;amp; a_{33} \end{vmatrix}+ a_{13} \begin{vmatrix} a_{21} &amp;amp; a_{22} \\ a_{31} &amp;amp; a_{32} \end{vmatrix}
$$ 

There's a neat computational trick for computing $3 \times 3$ determinants by hand. The trick consists of extending the matrix $A$ into a $3 \times 5$ array that contains copies the columns of $A$: the $1^{st}$ column of $A$ is copied to the $4^{th}$ column of the extended array, and the $2^{nd}$ column of $A$ is copied to the $5^{th}$ column. The determinant is then computed by summing the products of the entries on the three positive diagonals and subtracting the products of the entries on the three negative diagonals. 

&lt;picture&gt;&lt;img src=&quot;/assets/images/3x3.png&quot; /&gt;&lt;/picture&gt;

The general formula for the determinant of an $n \times n$ matrix is

$$
det(A)  = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}
$$

where $M_{ij}$ is called the &lt;mark&gt; minor &lt;/mark&gt; associated with the entry $a_{ij}$. The minor $M_{ij}$ is the determinant of the submatrix obtained by removing the $i^{th}$ row and the $j^{th}$ column of the matrix $A$. Note the alternating factor $(-1)^{i+j}$ that changes value between $+1$ and $-1$ for different terms in the formula.

The determinant of a $4 \times 4$ matrix $B$ is 

$$ 
det(B) = b_{11}M_{11} - b_{12}M_{12} + b_{13}M_{13} - b_{14}M_{14}
$$

The general formula for determinants $det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}$ assumes we're expanding the determinant along the first row of the matrix. In fact, a determinant formula can be obtained by expanding the determinant along anyrow or column of the matrix.

The expand-along-any-row-or-column nature of determinants can be very handy: if you need to calculate the determinant of a matrix with one row (or column) containing many zero entries, it makes sense to expand along that row since many of the terms in the formula will be zero. If a matrix contains a row (or column) consisting entirely of zeros, we can immediately tell its determinant is zero. 

&lt;h4&gt; Geometric interpretation &lt;/h4&gt;
&lt;h5&gt; Area of a parallelogram &lt;/h5&gt;
Suppose we're given vectors $overrightarrow{v} = (v_1, v_2)$ and $\overrightarrow{w} = (w_1, w_2)$ in $\mathbb{R}^2$ and we construct a parallelogram with corner points $(0,0), \overrightarrow{v}, \overrightarrow{w}$ and $\overrightarrow{v} + \overrightarrow{w}$.

The area of this parallelogram is equal to the determinant of the matrix that contains $(v_1, v_2)$ and $(w_1, w_2)$ as rows:

$$
area = \begin{vmatrix} v_1 &amp;amp; v_2 \\ w_1 &amp;amp; w_2 \end{vmatrix} = v_1 w_2 - v_2 w_1 
$$

&lt;h2&gt; Theoretical Linear Algebra &lt;/h2&gt;
The things we are going to learn now are less concerned with calculations and more about mind expansion. This section extends what we know about the vector space $\mathbb{R}^n$ to the realm of &lt;span class=&quot;blue&quot;&gt; abstract vector spaces &lt;/span&gt; of &lt;u&gt;vector-like mathematical objects. &lt;/u&gt;

&lt;h3&gt; Eigenvalues and Eigenvectors &lt;/h3&gt;
The set of &lt;u&gt; eignevectors &lt;/u&gt; of a matrix is a special set of input vectors for which the action of the matrix is described as &lt;u&gt; simple scaling &lt;/u&gt;. 

Decomposing a matrix in terms of its eigenvalues and its eigenvectors gives valuable insights into the properties of the matrix. Certain matrix calculations, like &lt;b&gt; computing the power of the matrix&lt;/b&gt;, become much easier when use the &lt;u&gt; eigendecomposition of the matrix &lt;/u&gt;

For example, suppose we're given a square matrix $A$ and want to compute $A^7$. To make this example more concrete, we'll analyze the matrix 
$$
A = \begin{bmatrix} 9 &amp;amp; -2 \\ -2 &amp;amp; 6 \end{bmatrix}
$$

We want to compute $A^7$. That would be an awful lot of matrix multiplications. Every matrix corresponds to some linear operation. This means it's legit to ask, &lt;u&gt; &quot;what does the matrix A do?&quot; &lt;/u&gt; Once we figure out this part, we can compute $A^{77}$ by simply doing what $A$ does $77$ times. 

The best way to see what a matrix does is to look inside it and see what it's made of. To understand the matrix $A$, you must find it its eigenvectors and its eigenvalues. The eigenvectors of a matrix are a &lt;span class=&quot;rainbow&quot;&gt; natural basis &lt;/span&gt; for describing the action ofthe matrix. The eigendecomposition is a change-of-basis operation that expresses the matrix $A$ with respect to its eigenbasis (own-basis). The eigendecompositions of the matrix $A$ is a product of three matrices:






&lt;/li&gt;&lt;/ul&gt;</content><author><name>seri</name></author><category term="linear algebra" /><category term="featured" /><summary type="html">This article goes through the fundamentals of linear algebra. Linear algebra is the branch of mathematics concerning linear equations and their representations in vector spaces. This ultimate guide will prove very useful or understanding deep learning techniques.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/linear.png" /><media:content medium="image" url="http://localhost:4000/assets/images/linear.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Batch Normalization and Group Normalization</title><link href="http://localhost:4000/group-norm.html" rel="alternate" type="text/html" title="Batch Normalization and Group Normalization" /><published>2021-09-08T00:00:00+09:00</published><updated>2021-09-08T00:00:00+09:00</updated><id>http://localhost:4000/group-norm</id><content type="html" xml:base="http://localhost:4000/group-norm.html">&lt;!--more--&gt;

&lt;h2&gt; Batch Normalization: the Principles &lt;/h2&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/bn2.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Batch Normalization is an algorithmic method which makes the training of Deep Neural Networks &lt;span class=&quot;blue&quot;&gt; faster and more stable &lt;/span&gt;. Batch normalization is computed differently during the training and the testing phase.&lt;/p&gt;

&lt;p&gt;At &lt;span class=&quot;circle-sketch-highlight&quot;&gt; training &lt;/span&gt;, the BN layer determines the mean and standard deviation of the activation values across the batch. It then &lt;span class=&quot;underline&quot;&gt; normalizes the activation vector &lt;/span&gt; with $\mu$ and $\sigma$. That way, each neuron’s output follows a standard &lt;span class=&quot;blue&quot;&gt; normal distribution &lt;/span&gt; across the &lt;span class=&quot;blue&quot;&gt; batch &lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;It finally applies a &lt;span class=&quot;blue&quot;&gt; linear transformation &lt;/span&gt; with $\gamma$ and $\beta$ which are the two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trainable parameters&lt;/code&gt;. Such step allows the model to choose the optimum distribution for each hidden layer. $\gamma$ allows to adjust the standard deviation while $\beta$ allows to adjust the bias, shifting the curve on the right or on the left side.&lt;/p&gt;

&lt;p&gt;At each iteration, the network computes the mean $\mu$ and the standard deviation $\sigma$ corresponding to the current batch. Then it trains $\gamma$ and $\beta$ through &lt;mark&gt; gradient descent &lt;/mark&gt; using an &lt;mark&gt; Exponential Moving Average (EMA) &lt;/mark&gt; to give more importance to the latest iterations.&lt;/p&gt;

&lt;div class=&quot;sidenote&quot;&gt; We mostly use &lt;mark&gt; Exponential Moving Average algorithm &lt;/mark&gt; to reduce the noise or to smooth the data. The weight of each element decreases progressively over time, meaning &lt;span class=&quot;underline&quot;&gt; the EMA gives greater weight to recent data points &lt;/span&gt;. EMA reacts faster to changes compared to Simple Moving Average. &lt;/div&gt;

&lt;p&gt;At the &lt;span class=&quot;rainbow&quot;&gt; evaluation phase &lt;/span&gt;, we may not have a full batch to feed into the model. To tackle this issue, &lt;span class=&quot;underline&quot;&gt; we compute $\mu_{pop}$ and $\sigma_{pop}$ as the estimated mean and standard deviation of the studied population &lt;/span&gt;. Those values are computed using all the $\mu_{batch}$ and $\sigma_{batch}$ during training, and directly fed during the evaluation phase.&lt;/p&gt;

&lt;h2&gt; Why Normalization? &lt;/h2&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/bn4.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;What we can conclude from the original Batch Normalization paper is that:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Adding BN layers leads to &lt;b&gt; better convergence and higher accuracy &lt;/b&gt;&lt;/li&gt;
  &lt;li&gt;Adding BN layers allows us to &lt;b&gt; use higher learning rate &lt;/b&gt; without compromising convergence.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To quote Ian Goodfellow about the use of batch normalization:&lt;/p&gt;
&lt;blockquote&gt; Before BN, we thought it was almost &lt;span class=&quot;underline&quot;&gt; impossible to efficiently train deep models using sigmoid &lt;/span&gt; in the hidden layers. Batch Normalization makes those unstable networks trainable. &lt;/blockquote&gt;

&lt;p&gt;In practice, it is widely admitted that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; For &lt;span class=&quot;highlight-green&quot;&gt; CNNs, Batch Normalization is better &lt;/span&gt; &lt;/li&gt;&lt;li&gt; &lt;span class=&quot;highlight-yellow&quot;&gt; For Recurrent Networks, Layer Normalization is better &lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;While BN uses the current batch to normalize every single value, LN uses all the current layer to do so. &lt;span class=&quot;underline&quot;&gt; The normalization is performed using other features from a single example &lt;/span&gt; instead of using the same feature across all current batch examples.&lt;/p&gt;

&lt;p&gt;The best way to understand why BN works is to understand &lt;span class=&quot;highlight-sketch&quot;&gt; the optimization landscape smoothness &lt;/span&gt;. BN &lt;u&gt; reparameterizes the underlying optimization problem &lt;/u&gt;, making the training faster and easier. In additional recent studies, researchers observed that this effect is not unique to BN, but applies to other normalization methods (i.e. L1 normalization or L2 normalization).&lt;/p&gt;

&lt;h2&gt; The Drawbacks of BN &lt;/h2&gt;

&lt;p&gt;For BN to work, the &lt;span class=&quot;rainbow&quot;&gt; batch size is required to be sufficiently large &lt;/span&gt;, usually at least &lt;span class=&quot;circle-sketch-highlight&quot;&gt; 32 &lt;/span&gt;. However, there are situations when we have to settle for a small batch size. For example, when each &lt;span class=&quot;underline&quot;&gt; data sample is highly memory consuming &lt;/span&gt; or when we train a &lt;span class=&quot;underline&quot;&gt; very large neural network &lt;/span&gt; which leaves little GPU memory for processing data. For computer vision applications other than image classification, the restriction on batch sizes are more demanding and it is difficult to have higher batch sizes.&lt;/p&gt;

&lt;h2&gt; Comparisions of Normalization Methods &lt;/h2&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/bn3.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Group Normalization is one of the latest normalization methods that &lt;u&gt; avoids exploiting the batch dimension&lt;/u&gt;, thus is &lt;u&gt;independent of batch size&lt;/u&gt;. But there are other normalization methods as well.&lt;/p&gt;

&lt;h3&gt; Layer Normalization &lt;/h3&gt;

&lt;p&gt;Layer Normalization computes $\mu_i$ and $\sigma_i$ along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(C,H,W)&lt;/code&gt; axes. The computation for an input feature is entirely independent of other input features in a batch.&lt;/p&gt;

&lt;h3&gt; Instance Normalization &lt;/h3&gt;

&lt;p&gt;Instance Normalization computes $\mu_i$ and $\sigma_i$ along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(H,W)&lt;/code&gt; axes. Since the computation of IN is the same as that of BN with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;batch_size=1&lt;/code&gt;, IN actually makes the situation worse in most cases. However, for &lt;span class=&quot;highlight-pink&quot;&gt; style transfer tasks &lt;/span&gt;, IN is better at discarding contrast information of an image, thus having superior performance than BN.&lt;/p&gt;

&lt;h3&gt; Group Normalization &lt;/h3&gt;

&lt;p&gt;Also notice that IN can be viewed as applying Layer Normalization to each channel individually as if the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num_channels = 1&lt;/code&gt;. Group Normalization is the middle ground between IN and LN. It &lt;span class=&quot;gif&quot;&gt; organizes the channels into different groups &lt;/span&gt; and &lt;span class=&quot;highlight-yellow&quot;&gt; computes $\mu_i$ and $\sigma_i$ along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(H,W)&lt;/code&gt; axes and along a group of channels.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;First, the batch with dimension &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N,C,H,W)&lt;/code&gt; is reshaped to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N,G,C//G,H,W)&lt;/code&gt;. The number of group &lt;span class=&quot;underline&quot;&gt; $G$ is a pre-defined hyperparameter &lt;/span&gt;. Then we normalize along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(C//G,H,W)&lt;/code&gt; dimension and return the result after reshaping the batch back to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N,C,H,w)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Group Normalization is better than Layer Normalization as GN allows different distribution to be learned for each group of channels. GN is also thought to be better than IN because GN can exploit the dependence across channels. If &lt;mark&gt;`C = G`&lt;/mark&gt;, that is, if the number of groups are set to be equal to the number of channels, &lt;mark&gt; GN becomes IN &lt;/mark&gt; . Likewise, if &lt;mark&gt;`G = 1`&lt;/mark&gt; &lt;mark&gt; GN becomes LN &lt;/mark&gt;.&lt;/p&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt; 
&lt;li&gt;&lt;a href=&quot;https://amaarora.github.io/2020/08/09/groupnorm.html&quot;&gt; blog post &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/what-is-group-normalization-45fe27307be7&quot;&gt; medium article &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/batch-normalization-in-3-levels-of-understanding-14c2da90a338&quot;&gt; medium article2 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="deep learning" /><category term="featured" /><summary type="html">Batch normalization is used in most state-of-the-art computer vision techniques to stabilize training, but it also suffers from drawbacks. Group normalization can be an awesome alternative when the batch size is too small.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/bn.png" /><media:content medium="image" url="http://localhost:4000/assets/images/bn.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Depth from Disparity</title><link href="http://localhost:4000/disparity.html" rel="alternate" type="text/html" title="Depth from Disparity" /><published>2021-09-05T00:00:00+09:00</published><updated>2021-09-05T00:00:00+09:00</updated><id>http://localhost:4000/disparity</id><content type="html" xml:base="http://localhost:4000/disparity.html">&lt;!--We will be looking at depth estimation as a multi-image problem. Multi-view problems span different problem domains: these include stereo vision, Structure from Motion, optical flow etc. In the first part of the series, we will focus on stereo vision.--&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;h2 class=&quot;glow&quot;&gt;🌟 3D Reconstruction from 2D Signals &lt;/h2&gt;&lt;/div&gt;

&lt;p&gt;We are going to look at depth estimation as a multi-view problem. Multi-view problems can span into different domains including stereo vision, Structure from Motion and optical flow. Although each carries great importance in the problem of Virtual Reality (VR) and robotics, we will focus on stereo vision in this multi-part series. Specifically, the progress of deep learning in stereo vision technology.&lt;/p&gt;

&lt;p&gt;How can we automatically &lt;span class=&quot;highlight-sketch&quot;&gt; compute 3D geometry from images &lt;/span&gt;? What cues in the image provide 3D information? Before looking at binocular, let’s consider single view characteristics.&lt;/p&gt;

&lt;p&gt;Well, we humans do so naturally. Here are several cues we use to infer depth information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; shading &lt;/li&gt;
&lt;li&gt; texture &lt;/li&gt; 
&lt;li&gt; focus &lt;/li&gt;
&lt;li&gt; motion &lt;/li&gt; 
&lt;li&gt; perspective &lt;/li&gt;
&lt;li&gt; occlusion &lt;/li&gt; 
&lt;li&gt; symmetry &lt;/li&gt;
&lt;/ul&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/single.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Nonetheless, structure and depth are inherently ambiguous from a single view. As seen from the optical center (i.e., camera location), $P1$ and $P2$ are projected onto the image plane as equivalent.&lt;/p&gt;

&lt;h2&gt; The Stereo Problem &lt;/h2&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/stereo.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Stereo vision systems reference the knowledge of two images captured simultaneously from a pair of cameras (left and right) with camera parameters (extrinsic and intrinsic). Stereo is heavily motivated by biology. Classic stereo problem include disparity, depth, occlusion, Structure from Motion, motion parallax etc. Provided left and right images, the ambiguity problem of the aforementioned is satisfied via triangulation from the two image planes by matching correspondences of a point in the world coordinate to the ones that can be seen in both images.&lt;/p&gt;

&lt;p&gt;The basic principle of triangulation is shown above: the reconstruction via the intersection of two rays. Requirements? Calibration and correspondences.&lt;/p&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/epipolar.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;Furthermore,  &lt;span class=&quot;rainbow&quot;&gt; the Epipolar Constraint &lt;/span&gt; reduces the correspondence problem to $1D$ search along &lt;span class=&quot;frozen&quot;&gt; conjugate epipolar lines &lt;/span&gt; shown in the above figure.&lt;/p&gt;

&lt;p&gt;Thus, &lt;span class=&quot;rainbow&quot;&gt; Epipolar Constraint &lt;/span&gt; assumes that stereo pairs are rectified images, meaning the same &lt;span class=&quot;frozen&quot;&gt; epipolar line &lt;/span&gt; aligns across rows such that it is orthogonal to both and aligned with one another. Rectification is achieved by learning a transformation based on intrinsic and extrinsic parameters: a process that dates back several decades.&lt;/p&gt;

&lt;p&gt;From the rectified image pair, the depth $Z$ can be determined by its inversely proportionate relationhip with disparity $d$, where the disparity is defined as the pixel difference along the horizontal when comparing correspondences of left and right. This can be written as:&lt;/p&gt;

\[I(x,y) = D(x+d, y)\]

&lt;p&gt;This relationship is easiest to grasp visually. Provided a point in the left image plane $P_L(x,y)$ along with the correspondence in the right image plane and the world coordinates $(X,Y,Z)$ projected as a point in a 3D scene, our goal is to reconstruct the missing $Z$ (depth) provided the stereo pair.&lt;/p&gt;

&lt;picture&gt;&lt;img src=&quot;/assets/images/disparity.png&quot; /&gt;&lt;/picture&gt;

&lt;p&gt;We set the relative coordinates (red axis) along with having known baseline $b$ between the two camera centers. Then $/frac{x_L}{f}$ can be expressed as $\frac{X+b/2}{Z}$ and $\frac{x_R}{f} = \frac{X-b/2}{Z}$. Therefore,&lt;/p&gt;

\[\frac{y_L}{f} = \frac{y_R}{f} = \frac{Y}{Z}\]

&lt;p&gt;and the world coordinate can be expressed as&lt;/p&gt;

\[X = \frac{b(x_L+x_R)}{2(x_L - x_R)} Y = \frac{b(y_L + y_R}{2(x_L-x_R} Z = \frac{bf}{(x_L - x_R)}\]

&lt;blockquote class=&quot;black&quot;&gt; $d = x_L - x_R$ is the &lt;span class=&quot;neon-green&quot;&gt;disparity&lt;/span&gt; between corresponding left and right image points &lt;/blockquote&gt;

&lt;h2&gt; References &lt;/h2&gt;
&lt;ul&gt; 
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/depth-from-disparity-via-deep-learning-part-0-458827141b23&quot;&gt; article from medium &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>seri</name></author><category term="computer vision" /><category term="featured" /><summary type="html">We will be looking at depth estimation as a multi-image problem. Multi-view problems span different problem domains: these include stereo vision, SfM, optical flow, etc.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/depth/12.png" /><media:content medium="image" url="http://localhost:4000/assets/images/depth/12.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>